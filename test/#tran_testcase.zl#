25.3.5. TestCase Objects
Each TestCase instance represents a single test, but each concrete subclass may be used to define multiple tests — the concrete class represents a single test fixture. The fixture is created and cleaned up for each test case.
每个TestCase实例代表一个单独的测试，但是每个实际的子类都可以用来定义多个测试，实际的类代表一个单独的测试fixture,这个fixture为每个测试用例创建和清楚。

TestCase instances provide three groups of methods: one group used to run the test, another used by the test implementation to check conditions and report failures, and some inquiry methods allowing information about the test itself to be gathered.

TestCase实例提供3组方法，一组用来执行测试，另外一组检查条件和报告失败，还有一些方法允许收集关于测试本身的信息。
Methods in the first group (running the test) are:

TestCase.setUp()

Method called to prepare the test fixture. This is called immediately before calling the test method; any exception raised by this method will be considered an error rather than a test failure. The default implementation does nothing.

这个方法执行准备测试fixture，这个方法在被电泳测试方法前执行，任何由这个方法抛出的异常都被认为是错误而不是测试失败。默认的方法不执行任何东西。

TestCase.tearDown()
Method called immediately after the test method has been called and the result recorded. This is called even if the test method raised an exception, so the implementation in subclasses may need to be particularly careful about checking internal state. Any exception raised by this method will be considered an error rather than a test failure. This method will only be called if the setUp() succeeds, regardless of the outcome of the test method. The default implementation does nothing.
测试完成后执行，这个方法会调用即使测试抛出异常，
TestCase.run([result])

Run the test, collecting the result into the test result object passed as result. If result is omitted or None, a temporary result object is created (by calling the defaultTestCase() method) and used; this result object is not returned to run()‘s caller.

执行测试，收集测试的结果构建结果对象，
The same effect may be had by simply calling the TestCase instance.

TestCase.debug()
Run the test without collecting the result. This allows exceptions raised by the test to be propagated to the caller, and can be used to support running tests under a debugger.
The test code can use any of the following methods to check for and report failures.

TestCase.assert_(expr[, msg])
TestCase.failUnless(expr[, msg])
TestCase.assertTrue(expr[, msg])
Signal a test failure if expr is false; the explanation for the error will be msg if given, otherwise it will be None.
TestCase.assertEqual(first, second[, msg])
TestCase.failUnlessEqual(first, second[, msg])
Test that first and second are equal. If the values do not compare equal, the test will fail with the explanation given by msg, or None. Note that using failUnlessEqual() improves upon doing the comparison as the first parameter to failUnless(): the default value for msg can be computed to include representations of both first and second.
TestCase.assertNotEqual(first, second[, msg])
TestCase.failIfEqual(first, second[, msg])
Test that first and second are not equal. If the values do compare equal, the test will fail with the explanation given by msg, or None. Note that using failIfEqual() improves upon doing the comparison as the first parameter to failUnless() is that the default value for msg can be computed to include representations of both first and second.
TestCase.assertAlmostEqual(first, second[, places[, msg]])
TestCase.failUnlessAlmostEqual(first, second[, places[, msg]])
Test that first and second are approximately equal by computing the difference, rounding to the given number of decimal places (default 7), and comparing to zero. Note that comparing a given number of decimal places is not the same as comparing a given number of significant digits. If the values do not compare equal, the test will fail with the explanation given by msg, or None.
TestCase.assertNotAlmostEqual(first, second[, places[, msg]])
TestCase.failIfAlmostEqual(first, second[, places[, msg]])
Test that first and second are not approximately equal by computing the difference, rounding to the given number of decimal places (default 7), and comparing to zero. Note that comparing a given number of decimal places is not the same as comparing a given number of significant digits. If the values do not compare equal, the test will fail with the explanation given by msg, or None.
TestCase.assertRaises(exception, callable, ...)
TestCase.fa