<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="wjl.20110328233312.1243"><vh>@chapters</vh></v>
<v t="wjl.20110328233312.1242"><vh>关于python的标准库--unittest</vh></v>
<v t="wjl.20110328233312.1244" a="E"><vh>test/pydoc_test.py</vh>
<v t="wjl.20110328233312.1245"><vh>pydoc_test declarations</vh></v>
<v t="wjl.20110328233312.1246" a="E"><vh>class TestSequenceFunctions</vh>
<v t="wjl.20110328233312.1247"><vh>setUp</vh></v>
<v t="wjl.20110328233312.1248"><vh>test_shuffle</vh></v>
<v t="wjl.20110328233312.1249"><vh>test_choice</vh></v>
<v t="wjl.20110328233312.1250"><vh>test_sample</vh></v>
</v>
</v>
<v t="wjl.20110328233312.1251" a="E"><vh>test/unittest.py</vh>
<v t="wjl.20110328233312.1252"><vh>unittest declarations</vh></v>
<v t="wjl.20110328233312.1253"><vh>_CmpToKey</vh></v>
<v t="wjl.20110328233312.1254"><vh>_strclass</vh></v>
<v t="wjl.20110328233312.1255"><vh>class TestResult</vh>
<v t="wjl.20110328233312.1256"><vh>__init__</vh></v>
<v t="wjl.20110328233312.1257"><vh>startTest</vh></v>
<v t="wjl.20110328233312.1258"><vh>stopTest</vh></v>
<v t="wjl.20110328233312.1259"><vh>addError</vh></v>
<v t="wjl.20110328233312.1260"><vh>addFailure</vh></v>
<v t="wjl.20110328233312.1261"><vh>addSuccess</vh></v>
<v t="wjl.20110328233312.1262"><vh>wasSuccessful</vh></v>
<v t="wjl.20110328233312.1263"><vh>stop</vh></v>
<v t="wjl.20110328233312.1264"><vh>_exc_info_to_string</vh></v>
<v t="wjl.20110328233312.1265"><vh>_is_relevant_tb_level</vh></v>
<v t="wjl.20110328233312.1266"><vh>_count_relevant_tb_levels</vh></v>
<v t="wjl.20110328233312.1267"><vh>__repr__</vh></v>
</v>
<v t="wjl.20110328233312.1268"><vh>class TestCase</vh>
<v t="wjl.20110328233312.1269"><vh>__init__</vh></v>
<v t="wjl.20110328233312.1270"><vh>setUp</vh></v>
<v t="wjl.20110328233312.1271"><vh>tearDown</vh></v>
<v t="wjl.20110328233312.1272"><vh>countTestCases</vh></v>
<v t="wjl.20110328233312.1273"><vh>defaultTestResult</vh></v>
<v t="wjl.20110328233312.1274"><vh>shortDescription</vh></v>
<v t="wjl.20110328233312.1275"><vh>id</vh></v>
<v t="wjl.20110328233312.1276"><vh>__eq__</vh></v>
<v t="wjl.20110328233312.1277"><vh>__ne__</vh></v>
<v t="wjl.20110328233312.1278"><vh>__hash__</vh></v>
<v t="wjl.20110328233312.1279"><vh>__str__</vh></v>
<v t="wjl.20110328233312.1280"><vh>__repr__</vh></v>
<v t="wjl.20110328233312.1281"><vh>run</vh></v>
<v t="wjl.20110328233312.1282"><vh>__call__</vh></v>
<v t="wjl.20110328233312.1283"><vh>debug</vh></v>
<v t="wjl.20110328233312.1284"><vh>_exc_info</vh></v>
<v t="wjl.20110328233312.1285"><vh>fail</vh></v>
<v t="wjl.20110328233312.1286"><vh>failIf</vh></v>
<v t="wjl.20110328233312.1287"><vh>failUnless</vh></v>
<v t="wjl.20110328233312.1288"><vh>failUnlessRaises</vh></v>
<v t="wjl.20110328233312.1289"><vh>failUnlessEqual</vh></v>
<v t="wjl.20110328233312.1290"><vh>failIfEqual</vh></v>
<v t="wjl.20110328233312.1291"><vh>failUnlessAlmostEqual</vh></v>
<v t="wjl.20110328233312.1292"><vh>failIfAlmostEqual</vh></v>
</v>
<v t="wjl.20110328233312.1293"><vh>class TestSuite</vh>
<v t="wjl.20110328233312.1294"><vh>__init__</vh></v>
<v t="wjl.20110328233312.1295"><vh>__repr__</vh></v>
<v t="wjl.20110328233312.1296"><vh>__eq__</vh></v>
<v t="wjl.20110328233312.1297"><vh>__ne__</vh></v>
<v t="wjl.20110328233312.1298"><vh>__iter__</vh></v>
<v t="wjl.20110328233312.1299"><vh>countTestCases</vh></v>
<v t="wjl.20110328233312.1300"><vh>addTest</vh></v>
<v t="wjl.20110328233312.1301"><vh>addTests</vh></v>
<v t="wjl.20110328233312.1302"><vh>run</vh></v>
<v t="wjl.20110328233312.1303"><vh>__call__</vh></v>
<v t="wjl.20110328233312.1304"><vh>debug</vh></v>
</v>
<v t="wjl.20110328233312.1305"><vh>class FunctionTestCase</vh>
<v t="wjl.20110328233312.1306"><vh>__init__</vh></v>
<v t="wjl.20110328233312.1307"><vh>setUp</vh></v>
<v t="wjl.20110328233312.1308"><vh>tearDown</vh></v>
<v t="wjl.20110328233312.1309"><vh>runTest</vh></v>
<v t="wjl.20110328233312.1310"><vh>id</vh></v>
<v t="wjl.20110328233312.1311"><vh>__eq__</vh></v>
<v t="wjl.20110328233312.1312"><vh>__ne__</vh></v>
<v t="wjl.20110328233312.1313"><vh>__hash__</vh></v>
<v t="wjl.20110328233312.1314"><vh>__str__</vh></v>
<v t="wjl.20110328233312.1315"><vh>__repr__</vh></v>
<v t="wjl.20110328233312.1316"><vh>shortDescription</vh></v>
</v>
<v t="wjl.20110328233312.1317" a="E"><vh>class TestLoader</vh>
<v t="wjl.20110328233312.1318"><vh>loadTestsFromTestCase</vh></v>
<v t="wjl.20110328233312.1319"><vh>loadTestsFromModule</vh></v>
<v t="wjl.20110328233312.1320"><vh>loadTestsFromName</vh></v>
<v t="wjl.20110328233312.1321"><vh>loadTestsFromNames</vh></v>
<v t="wjl.20110328233312.1322"><vh>getTestCaseNames</vh></v>
</v>
<v t="wjl.20110328233312.1323"><vh>_makeLoader</vh></v>
<v t="wjl.20110328233312.1324"><vh>getTestCaseNames</vh></v>
<v t="wjl.20110328233312.1325"><vh>makeSuite</vh></v>
<v t="wjl.20110328233312.1326"><vh>findTestCases</vh></v>
<v t="wjl.20110328233312.1327"><vh>class _WritelnDecorator</vh>
<v t="wjl.20110328233312.1328"><vh>__init__</vh></v>
<v t="wjl.20110328233312.1329"><vh>__getattr__</vh></v>
<v t="wjl.20110328233312.1330"><vh>writeln</vh></v>
</v>
<v t="wjl.20110328233312.1331"><vh>class _TextTestResult</vh>
<v t="wjl.20110328233312.1332"><vh>__init__</vh></v>
<v t="wjl.20110328233312.1333"><vh>getDescription</vh></v>
<v t="wjl.20110328233312.1334"><vh>startTest</vh></v>
<v t="wjl.20110328233312.1335"><vh>addSuccess</vh></v>
<v t="wjl.20110328233312.1336"><vh>addError</vh></v>
<v t="wjl.20110328233312.1337"><vh>addFailure</vh></v>
<v t="wjl.20110328233312.1338"><vh>printErrors</vh></v>
<v t="wjl.20110328233312.1339"><vh>printErrorList</vh></v>
</v>
<v t="wjl.20110328233312.1340"><vh>class TextTestRunner</vh>
<v t="wjl.20110328233312.1341"><vh>__init__</vh></v>
<v t="wjl.20110328233312.1342"><vh>_makeResult</vh></v>
<v t="wjl.20110328233312.1343"><vh>run</vh></v>
</v>
<v t="wjl.20110328233312.1344"><vh>class TestProgram</vh>
<v t="wjl.20110328233312.1345"><vh>__init__</vh></v>
<v t="wjl.20110328233312.1346"><vh>usageExit</vh></v>
<v t="wjl.20110328233312.1347"><vh>parseArgs</vh></v>
<v t="wjl.20110328233312.1348"><vh>createTests</vh></v>
<v t="wjl.20110328233312.1349"><vh>runTests</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="wjl.20110328233312.1242">最近纠结于各种测试，所以想对python的单元测试作一番深入的了解，所以就有了下面的分析。
下面有2个文件，pydoc_test.py,这个例子是在python的库文档里复制出来的，没有什么实际的价值，仅作分析用，
另一个文件是python的库文件，直接复制过来的。

其实最开始吸引我的分析的地方是，这个例子中有3个以'test'开头的函数，我只是想看看如何写可以让这3个函数依次运行，
虽然我也可以写，但是看看人家怎么写的，怎么说，也放到标准库里的东西，一定有啥新奇的写法。
结果这个东西隐藏的那是相当的深阿，学点新东西怎吗就那么难阿！！

if __name__ == '__main__':
    unittest.main()
pydoc_test.py开始运行从unittest.main()开始的。

In [1]: import unittest
  
In [2]: unittest.main
Out[2]: &lt;class 'unittest.TestProgram'&gt;

unittest.main是一个叫TestProgram的类，然后看TestProgram是如何运作的：
    TestProgram所有的操作都是在__init__方法中实现的。
    self.defaultTest = defaultTest
    self.testRunner = testRunner
    self.testLoader = testLoader
    self.progName = os.path.basename(argv[0])
    self.parseArgs(argv)
    self.runTests()
本着解决最初的疑问（如何执行三个已test开头的函数，虽然后来已经跑不知道哪去了），略过枝节，直接看runTests

最关键一句：result = testRunner.run(self.test)
    函数testRunner = TextTestRunner，
    参数self.test
先说函数TextTestRunner，
    startTime = time.time()
    test(result)
    stopTime = time.time()
    
    self.stream.writeln("Ran %d test%s in %.3fs" %(run, run != 1 and "s" or "", timeTaken))
    这里有个好玩的事情，run是一个整数值，如果等于1这个是没有表示为负数的's'的，否则有这个's',好玩的是这个
    run != 1 and "s" or "" ,虽然这个方法自己也知道，可是还没有真正用过，所以看到还是觉得新鲜，等觉得不新鲜的时候才是真正掌握了，
你看把，看着看着就跑到别的地方了，，

现在看参数test：
在TestProgram这个函数中，
self.test = self.testLoader.loadTestsFromModule(self.module)
看吧，有么有点java的意思，我猜这个作者以前是写java的，这叫一个找阿，幸亏所有的函数都在一个文件中，不然就要死人了，，
self.testLoader就是TestLoader，
这个函数调用的是TestLoader的loadTestsFromModule函数，
def loadTestsFromModule(self, module):
    """Return a suite of all tests cases contained in the given module"""
    tests = []
    for name in dir(module):
        obj = getattr(module, name)
        if (isinstance(obj, (type, types.ClassType)) and
            issubclass(obj, TestCase)):
            tests.append(self.loadTestsFromTestCase(obj))
    return self.suiteClass(tests)
为了直观的分析，module就是&lt;module '__main__' from 'pydoc_test.py'&gt;这个东西，
符合if条件的只有我们唯一的TestCase的子类，就是这个东西TestSequenceFunctions(unittest.TestCase)，，
看吧，又要调用loadTestsFromTestCase()这个方法了，
def loadTestsFromTestCase(self, testCaseClass):
    """Return a suite of all tests cases contained in testCaseClass"""
    testCaseNames = self.getTestCaseNames(testCaseClass)
    if not testCaseNames and hasattr(testCaseClass, 'runTest'):
        testCaseNames = ['runTest']
    return self.suiteClass(map(testCaseClass, testCaseNames))
忽略异常，
def getTestCaseNames(self, testCaseClass):
    """Return a sorted sequence of method names found within testCaseClass
    """
    def isTestMethod(attrname, testCaseClass=testCaseClass, prefix=self.testMethodPrefix):
        return attrname.startswith(prefix) and hasattr(getattr(testCaseClass, attrname), '__call__')
    #这个方法写的诡异阿，prefix就是‘test’，前面的方法是判断函数名前缀，后面的是判断可执行？    
    #这就是最初都问题的答案：startswith()....
    testFnNames = filter(isTestMethod, dir(testCaseClass))
    #到这里的时候就返回['test_choice', 'test_sample', 'test_shuffle']
    if self.sortTestMethodsUsing:
        sortTestMethodsUsing = cmp
        #这个cmp是python内置，长见识了，
        testFnNames.sort(key=_CmpToKey(self.sortTestMethodsUsing))
    这里就是简单的排个序。
    return testFnNames
现在回头看loadTestsFromTestCase，
这个map(testCaseClass, testCaseNames)是个什么东西。。。

[&lt;pydoc_test.TestSequenceFunctions testMethod=test_choice&gt;,
 &lt;pydoc_test.TestSequenceFunctions testMethod=test_sample&gt;,
 &lt;pydoc_test.TestSequenceFunctions testMethod=test_shuffle&gt;]
anyone who can tell me what is it....

self.suiteClass(map(testCaseClass, testCaseNames))这个明天看把，，，，，
























</t>
<t tx="wjl.20110328233312.1243"></t>
<t tx="wjl.20110328233312.1244">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    unittest.main()
</t>
<t tx="wjl.20110328233312.1245">import random
import unittest

</t>
<t tx="wjl.20110328233312.1246">class TestSequenceFunctions(unittest.TestCase):
    @others
</t>
<t tx="wjl.20110328233312.1247">
def setUp(self):
    print 'setup'
    self.seq = range(10)

</t>
<t tx="wjl.20110328233312.1248">def test_shuffle(self):
    print 'test_shuffle'
    # make sure the shuffled sequence does not lose any elements
    random.shuffle(self.seq)
    self.seq.sort()
    self.assertEqual(self.seq, range(10))

</t>
<t tx="wjl.20110328233312.1249">def test_choice(self):
    print 'test_choice'
    element = random.choice(self.seq)
    self.assertTrue(element in self.seq)

</t>
<t tx="wjl.20110328233312.1250">def test_sample(self):
    print 'tese_sample'
    self.assertRaises(ValueError, random.sample, self.seq, 20)
    for element in random.sample(self.seq, 5):
        self.assertTrue(element in self.seq)

</t>
<t tx="wjl.20110328233312.1251">@language python
@tabwidth -4
@others
main = TestProgram


##############################################################################
# Executing this module from the command line
##############################################################################

if __name__ == "__main__":
    main(module=None)
</t>
<t tx="wjl.20110328233312.1252">#! /usr/bin/python2.6
'''
Python unit testing framework, based on Erich Gamma's JUnit and Kent Beck's
Smalltalk testing framework.

This module contains the core framework classes that form the basis of
specific test cases and suites (TestCase, TestSuite etc.), and also a
text-based utility class for running the tests and reporting the results
 (TextTestRunner).

Simple usage:

    import unittest

    class IntegerArithmenticTestCase(unittest.TestCase):
        def testAdd(self):  ## test method names begin 'test*'
            self.assertEquals((1 + 2), 3)
            self.assertEquals(0 + 1, 1)
        def testMultiply(self):
            self.assertEquals((0 * 10), 0)
            self.assertEquals((5 * 8), 40)

    if __name__ == '__main__':
        unittest.main()

Further information is available in the bundled documentation, and from

  http://docs.python.org/lib/module-unittest.html

Copyright (c) 1999-2003 Steve Purcell
This module is free software, and you may redistribute it and/or modify
it under the same terms as Python itself, so long as this copyright message
and disclaimer are retained in their original form.

IN NO EVENT SHALL THE AUTHOR BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OF
THIS CODE, EVEN IF THE AUTHOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.

THE AUTHOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE.  THE CODE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS,
AND THERE IS NO OBLIGATION WHATSOEVER TO PROVIDE MAINTENANCE,
SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
'''

__author__ = "Steve Purcell"
__email__ = "stephen_purcell at yahoo dot com"
__version__ = "#Revision: 1.63 $"[11:-2]

import time
import sys
import traceback
import os
import types

##############################################################################
# Exported classes and functions
##############################################################################
__all__ = ['TestResult', 'TestCase', 'TestSuite', 'TextTestRunner',
           'TestLoader', 'FunctionTestCase', 'main', 'defaultTestLoader']

# Expose obsolete functions for backwards compatibility
__all__.extend(['getTestCaseNames', 'makeSuite', 'findTestCases'])


##############################################################################
# Backward compatibility
##############################################################################
if sys.version_info[:2] &lt; (2, 2):
    def isinstance(obj, clsinfo):
        import __builtin__
        if type(clsinfo) in (tuple, list):
            for cls in clsinfo:
                if cls is type: cls = types.ClassType
                if __builtin__.isinstance(obj, cls):
                    return 1
            return 0
        else: return __builtin__.isinstance(obj, clsinfo)

</t>
<t tx="wjl.20110328233312.1253">def _CmpToKey(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) == -1
    return K

@doc 这个新鲜阿，</t>
<t tx="wjl.20110328233312.1254">##############################################################################
# Test framework core
##############################################################################

# All classes defined herein are 'new-style' classes, allowing use of 'super()'
__metaclass__ = type

def _strclass(cls):
    return "%s.%s" % (cls.__module__, cls.__name__)

</t>
<t tx="wjl.20110328233312.1255">__unittest = 1

class TestResult:
    """Holder for test result information.

    Test results are automatically managed by the TestCase and TestSuite
    classes, and do not need to be explicitly manipulated by writers of tests.

    Each instance holds the total number of tests run, and collections of
    failures and errors that occurred among those test runs. The collections
    contain tuples of (testcase, exceptioninfo), where exceptioninfo is the
    formatted traceback of the error that occurred.
    """
    @others
</t>
<t tx="wjl.20110328233312.1256">def __init__(self):
    self.failures = []
    self.errors = []
    self.testsRun = 0
    self.shouldStop = False

</t>
<t tx="wjl.20110328233312.1257">def startTest(self, test):
    "Called when the given test is about to be run"
    self.testsRun = self.testsRun + 1

</t>
<t tx="wjl.20110328233312.1258">def stopTest(self, test):
    "Called when the given test has been run"
    pass

</t>
<t tx="wjl.20110328233312.1259">def addError(self, test, err):
    """Called when an error has occurred. 'err' is a tuple of values as
    returned by sys.exc_info().
    """
    self.errors.append((test, self._exc_info_to_string(err, test)))

</t>
<t tx="wjl.20110328233312.1260">def addFailure(self, test, err):
    """Called when an error has occurred. 'err' is a tuple of values as
    returned by sys.exc_info()."""
    self.failures.append((test, self._exc_info_to_string(err, test)))

</t>
<t tx="wjl.20110328233312.1261">def addSuccess(self, test):
    "Called when a test has completed successfully"
    pass

</t>
<t tx="wjl.20110328233312.1262">def wasSuccessful(self):
    "Tells whether or not this result was a success"
    return len(self.failures) == len(self.errors) == 0

</t>
<t tx="wjl.20110328233312.1263">def stop(self):
    "Indicates that the tests should be aborted"
    self.shouldStop = True

</t>
<t tx="wjl.20110328233312.1264">def _exc_info_to_string(self, err, test):
    """Converts a sys.exc_info()-style tuple of values into a string."""
    exctype, value, tb = err
    # Skip test runner traceback levels
    while tb and self._is_relevant_tb_level(tb):
        tb = tb.tb_next
    if exctype is test.failureException:
        # Skip assert*() traceback levels
        length = self._count_relevant_tb_levels(tb)
        return ''.join(traceback.format_exception(exctype, value, tb, length))
    return ''.join(traceback.format_exception(exctype, value, tb))

</t>
<t tx="wjl.20110328233312.1265">def _is_relevant_tb_level(self, tb):
    return '__unittest' in tb.tb_frame.f_globals

</t>
<t tx="wjl.20110328233312.1266">def _count_relevant_tb_levels(self, tb):
    length = 0
    while tb and not self._is_relevant_tb_level(tb):
        length += 1
        tb = tb.tb_next
    return length

</t>
<t tx="wjl.20110328233312.1267">def __repr__(self):
    return "&lt;%s run=%i errors=%i failures=%i&gt;" % \
           (_strclass(self.__class__), self.testsRun, len(self.errors),
            len(self.failures))

</t>
<t tx="wjl.20110328233312.1268">class TestCase:
    """A class whose instances are single test cases.

    By default, the test code itself should be placed in a method named
    'runTest'.

    If the fixture may be used for many test cases, create as
    many test methods as are needed. When instantiating such a TestCase
    subclass, specify in the constructor arguments the name of the test method
    that the instance is to execute.

    Test authors should subclass TestCase for their own tests. Construction
    and deconstruction of the test's environment ('fixture') can be
    implemented by overriding the 'setUp' and 'tearDown' methods respectively.

    If it is necessary to override the __init__ method, the base class
    __init__ method must always be called. It is important that subclasses
    should not change the signature of their __init__ method, since instances
    of the classes are instantiated automatically by parts of the framework
    in order to be run.
    """

    # This attribute determines which exception will be raised when
    # the instance's assertion methods fail; test methods raising this
    # exception will be deemed to have 'failed' rather than 'errored'

    failureException = AssertionError

    @others
    # Synonyms for assertion methods

    assertEqual = assertEquals = failUnlessEqual

    assertNotEqual = assertNotEquals = failIfEqual

    assertAlmostEqual = assertAlmostEquals = failUnlessAlmostEqual

    assertNotAlmostEqual = assertNotAlmostEquals = failIfAlmostEqual

    assertRaises = failUnlessRaises

    assert_ = assertTrue = failUnless

    assertFalse = failIf



</t>
<t tx="wjl.20110328233312.1269">def __init__(self, methodName='runTest'):
    """Create an instance of the class that will use the named test
       method when executed. Raises a ValueError if the instance does
       not have a method with the specified name.
    """
    try:
        self._testMethodName = methodName
        testMethod = getattr(self, methodName)
        self._testMethodDoc = testMethod.__doc__
    except AttributeError:
        raise ValueError, "no such test method in %s: %s" % \
              (self.__class__, methodName)

</t>
<t tx="wjl.20110328233312.1270">def setUp(self):
    "Hook method for setting up the test fixture before exercising it."
    pass

</t>
<t tx="wjl.20110328233312.1271">def tearDown(self):
    "Hook method for deconstructing the test fixture after testing it."
    pass

</t>
<t tx="wjl.20110328233312.1272">def countTestCases(self):
    return 1

</t>
<t tx="wjl.20110328233312.1273">def defaultTestResult(self):
    return TestResult()

</t>
<t tx="wjl.20110328233312.1274">def shortDescription(self):
    """Returns a one-line description of the test, or None if no
    description has been provided.

    The default implementation of this method returns the first line of
    the specified test method's docstring.
    """
    doc = self._testMethodDoc
    return doc and doc.split("\n")[0].strip() or None

</t>
<t tx="wjl.20110328233312.1275">def id(self):
    return "%s.%s" % (_strclass(self.__class__), self._testMethodName)

</t>
<t tx="wjl.20110328233312.1276">def __eq__(self, other):
    if type(self) is not type(other):
        return False

    return self._testMethodName == other._testMethodName

</t>
<t tx="wjl.20110328233312.1277">def __ne__(self, other):
    return not self == other

</t>
<t tx="wjl.20110328233312.1278">def __hash__(self):
    return hash((type(self), self._testMethodName))

</t>
<t tx="wjl.20110328233312.1279">def __str__(self):
    return "%s (%s)" % (self._testMethodName, _strclass(self.__class__))

</t>
<t tx="wjl.20110328233312.1280">def __repr__(self):
    return "&lt;%s testMethod=%s&gt;" % \
           (_strclass(self.__class__), self._testMethodName)

</t>
<t tx="wjl.20110328233312.1281">def run(self, result=None):
    if result is None: result = self.defaultTestResult()
    result.startTest(self)
    testMethod = getattr(self, self._testMethodName)
    try:
        try:
            self.setUp()
        except KeyboardInterrupt:
            raise
        except:
            result.addError(self, self._exc_info())
            return

        ok = False
        try:
            testMethod()
            ok = True
        except self.failureException:
            result.addFailure(self, self._exc_info())
        except KeyboardInterrupt:
            raise
        except:
            result.addError(self, self._exc_info())

        try:
            self.tearDown()
        except KeyboardInterrupt:
            raise
        except:
            result.addError(self, self._exc_info())
            ok = False
        if ok: result.addSuccess(self)
    finally:
        result.stopTest(self)

</t>
<t tx="wjl.20110328233312.1282">def __call__(self, *args, **kwds):
    return self.run(*args, **kwds)

</t>
<t tx="wjl.20110328233312.1283">def debug(self):
    """Run the test without collecting errors in a TestResult"""
    self.setUp()
    getattr(self, self._testMethodName)()
    self.tearDown()

</t>
<t tx="wjl.20110328233312.1284">def _exc_info(self):
    """Return a version of sys.exc_info() with the traceback frame
       minimised; usually the top level of the traceback frame is not
       needed.
    """
    return sys.exc_info()

</t>
<t tx="wjl.20110328233312.1285">def fail(self, msg=None):
    """Fail immediately, with the given message."""
    raise self.failureException, msg

</t>
<t tx="wjl.20110328233312.1286">def failIf(self, expr, msg=None):
    "Fail the test if the expression is true."
    if expr: raise self.failureException, msg

</t>
<t tx="wjl.20110328233312.1287">def failUnless(self, expr, msg=None):
    """Fail the test unless the expression is true."""
    if not expr: raise self.failureException, msg

</t>
<t tx="wjl.20110328233312.1288">def failUnlessRaises(self, excClass, callableObj, *args, **kwargs):
    """Fail unless an exception of class excClass is thrown
       by callableObj when invoked with arguments args and keyword
       arguments kwargs. If a different type of exception is
       thrown, it will not be caught, and the test case will be
       deemed to have suffered an error, exactly as for an
       unexpected exception.
    """
    try:
        callableObj(*args, **kwargs)
    except excClass:
        return
    else:
        if hasattr(excClass,'__name__'): excName = excClass.__name__
        else: excName = str(excClass)
        raise self.failureException, "%s not raised" % excName

</t>
<t tx="wjl.20110328233312.1289">def failUnlessEqual(self, first, second, msg=None):
    """Fail if the two objects are unequal as determined by the '=='
       operator.
    """
    if not first == second:
        raise self.failureException, \
              (msg or '%r != %r' % (first, second))

</t>
<t tx="wjl.20110328233312.1290">def failIfEqual(self, first, second, msg=None):
    """Fail if the two objects are equal as determined by the '=='
       operator.
    """
    if first == second:
        raise self.failureException, \
              (msg or '%r == %r' % (first, second))

</t>
<t tx="wjl.20110328233312.1291">def failUnlessAlmostEqual(self, first, second, places=7, msg=None):
    """Fail if the two objects are unequal as determined by their
       difference rounded to the given number of decimal places
       (default 7) and comparing to zero.

       Note that decimal places (from zero) are usually not the same
       as significant digits (measured from the most signficant digit).
    """
    if round(abs(second-first), places) != 0:
        raise self.failureException, \
              (msg or '%r != %r within %r places' % (first, second, places))

</t>
<t tx="wjl.20110328233312.1292">def failIfAlmostEqual(self, first, second, places=7, msg=None):
    """Fail if the two objects are equal as determined by their
       difference rounded to the given number of decimal places
       (default 7) and comparing to zero.

       Note that decimal places (from zero) are usually not the same
       as significant digits (measured from the most signficant digit).
    """
    if round(abs(second-first), places) == 0:
        raise self.failureException, \
              (msg or '%r == %r within %r places' % (first, second, places))

</t>
<t tx="wjl.20110328233312.1293">class TestSuite:
    """A test suite is a composite test consisting of a number of TestCases.

    For use, create an instance of TestSuite, then add test case instances.
    When all tests have been added, the suite can be passed to a test
    runner, such as TextTestRunner. It will run the individual test cases
    in the order in which they were added, aggregating the results. When
    subclassing, do not forget to call the base class constructor.
    """
    @others
</t>
<t tx="wjl.20110328233312.1294">def __init__(self, tests=()):
    self._tests = []
    self.addTests(tests)

</t>
<t tx="wjl.20110328233312.1295">def __repr__(self):
    return "&lt;%s tests=%s&gt;" % (_strclass(self.__class__), self._tests)

</t>
<t tx="wjl.20110328233312.1296">__str__ = __repr__

def __eq__(self, other):
    if type(self) is not type(other):
        return False
    return self._tests == other._tests

</t>
<t tx="wjl.20110328233312.1297">def __ne__(self, other):
    return not self == other

</t>
<t tx="wjl.20110328233312.1298"># Can't guarantee hash invariant, so flag as unhashable
__hash__ = None

def __iter__(self):
    return iter(self._tests)

</t>
<t tx="wjl.20110328233312.1299">def countTestCases(self):
    cases = 0
    for test in self._tests:
        cases += test.countTestCases()
    return cases

</t>
<t tx="wjl.20110328233312.1300">def addTest(self, test):
    # sanity checks
    if not hasattr(test, '__call__'):
        raise TypeError("the test to add must be callable")
    if (isinstance(test, (type, types.ClassType)) and
        issubclass(test, (TestCase, TestSuite))):
        raise TypeError("TestCases and TestSuites must be instantiated "
                        "before passing them to addTest()")
    self._tests.append(test)

</t>
<t tx="wjl.20110328233312.1301">def addTests(self, tests):
    if isinstance(tests, basestring):
        raise TypeError("tests must be an iterable of tests, not a string")
    for test in tests:
        self.addTest(test)

</t>
<t tx="wjl.20110328233312.1302">def run(self, result):
    for test in self._tests:
        if result.shouldStop:
            break
        test(result)
    return result

</t>
<t tx="wjl.20110328233312.1303">def __call__(self, *args, **kwds):
    return self.run(*args, **kwds)

</t>
<t tx="wjl.20110328233312.1304">def debug(self):
    """Run the tests without collecting errors in a TestResult"""
    for test in self._tests: test.debug()


</t>
<t tx="wjl.20110328233312.1305">class FunctionTestCase(TestCase):
    """A test case that wraps a test function.

    This is useful for slipping pre-existing test functions into the
    unittest framework. Optionally, set-up and tidy-up functions can be
    supplied. As with TestCase, the tidy-up ('tearDown') function will
    always be called if the set-up ('setUp') function ran successfully.
    """
    @others
</t>
<t tx="wjl.20110328233312.1306">
def __init__(self, testFunc, setUp=None, tearDown=None,
             description=None):
    TestCase.__init__(self)
    self.__setUpFunc = setUp
    self.__tearDownFunc = tearDown
    self.__testFunc = testFunc
    self.__description = description

</t>
<t tx="wjl.20110328233312.1307">def setUp(self):
    if self.__setUpFunc is not None:
        self.__setUpFunc()

</t>
<t tx="wjl.20110328233312.1308">def tearDown(self):
    if self.__tearDownFunc is not None:
        self.__tearDownFunc()

</t>
<t tx="wjl.20110328233312.1309">def runTest(self):
    self.__testFunc()

</t>
<t tx="wjl.20110328233312.1310">def id(self):
    return self.__testFunc.__name__

</t>
<t tx="wjl.20110328233312.1311">def __eq__(self, other):
    if type(self) is not type(other):
        return False

    return self.__setUpFunc == other.__setUpFunc and \
           self.__tearDownFunc == other.__tearDownFunc and \
           self.__testFunc == other.__testFunc and \
           self.__description == other.__description

</t>
<t tx="wjl.20110328233312.1312">def __ne__(self, other):
    return not self == other

</t>
<t tx="wjl.20110328233312.1313">def __hash__(self):
    return hash((type(self), self.__setUpFunc, self.__tearDownFunc,
                                       self.__testFunc, self.__description))

</t>
<t tx="wjl.20110328233312.1314">def __str__(self):
    return "%s (%s)" % (_strclass(self.__class__), self.__testFunc.__name__)

</t>
<t tx="wjl.20110328233312.1315">def __repr__(self):
    return "&lt;%s testFunc=%s&gt;" % (_strclass(self.__class__), self.__testFunc)

</t>
<t tx="wjl.20110328233312.1316">def shortDescription(self):
    if self.__description is not None: return self.__description
    doc = self.__testFunc.__doc__
    return doc and doc.split("\n")[0].strip() or None



</t>
<t tx="wjl.20110328233312.1317">##############################################################################
# Locating and loading tests
##############################################################################

class TestLoader:
    """This class is responsible for loading tests according to various
    criteria and returning them wrapped in a TestSuite
    """
    testMethodPrefix = 'test'
    sortTestMethodsUsing = cmp
    suiteClass = TestSuite

    @others
</t>
<t tx="wjl.20110328233312.1318">def loadTestsFromTestCase(self, testCaseClass):
    """Return a suite of all tests cases contained in testCaseClass"""
    if issubclass(testCaseClass, TestSuite):
        raise TypeError("Test cases should not be derived from TestSuite. Maybe you meant to derive from TestCase?")
    testCaseNames = self.getTestCaseNames(testCaseClass)
    if not testCaseNames and hasattr(testCaseClass, 'runTest'):
        testCaseNames = ['runTest']
    return self.suiteClass(map(testCaseClass, testCaseNames))

</t>
<t tx="wjl.20110328233312.1319">def loadTestsFromModule(self, module):
    """Return a suite of all tests cases contained in the given module"""
    tests = []
    for name in dir(module):
        obj = getattr(module, name)
        if (isinstance(obj, (type, types.ClassType)) and
            issubclass(obj, TestCase)):
            tests.append(self.loadTestsFromTestCase(obj))
    return self.suiteClass(tests)

</t>
<t tx="wjl.20110328233312.1320">def loadTestsFromName(self, name, module=None):
    """Return a suite of all tests cases given a string specifier.

    The name may resolve either to a module, a test case class, a
    test method within a test case class, or a callable object which
    returns a TestCase or TestSuite instance.

    The method optionally resolves the names relative to a given module.
    """
    parts = name.split('.')
    if module is None:
        parts_copy = parts[:]
        while parts_copy:
            try:
                module = __import__('.'.join(parts_copy))
                break
            except ImportError:
                del parts_copy[-1]
                if not parts_copy: raise
        parts = parts[1:]
    obj = module
    for part in parts:
        parent, obj = obj, getattr(obj, part)

    if type(obj) == types.ModuleType:
        return self.loadTestsFromModule(obj)
    elif (isinstance(obj, (type, types.ClassType)) and
          issubclass(obj, TestCase)):
        return self.loadTestsFromTestCase(obj)
    elif (type(obj) == types.UnboundMethodType and
          isinstance(parent, (type, types.ClassType)) and
          issubclass(parent, TestCase)):
        return TestSuite([parent(obj.__name__)])
    elif isinstance(obj, TestSuite):
        return obj
    elif hasattr(obj, '__call__'):
        test = obj()
        if isinstance(test, TestSuite):
            return test
        elif isinstance(test, TestCase):
            return TestSuite([test])
        else:
            raise TypeError("calling %s returned %s, not a test" %
                            (obj, test))
    else:
        raise TypeError("don't know how to make test from: %s" % obj)

</t>
<t tx="wjl.20110328233312.1321">def loadTestsFromNames(self, names, module=None):
    """Return a suite of all tests cases found using the given sequence
    of string specifiers. See 'loadTestsFromName()'.
    """
    suites = [self.loadTestsFromName(name, module) for name in names]
    return self.suiteClass(suites)

</t>
<t tx="wjl.20110328233312.1322">def getTestCaseNames(self, testCaseClass):
    """Return a sorted sequence of method names found within testCaseClass
    """
    def isTestMethod(attrname, testCaseClass=testCaseClass, prefix=self.testMethodPrefix):
        return attrname.startswith(prefix) and hasattr(getattr(testCaseClass, attrname), '__call__')
    testFnNames = filter(isTestMethod, dir(testCaseClass))
    if self.sortTestMethodsUsing:
        testFnNames.sort(key=_CmpToKey(self.sortTestMethodsUsing))
    return testFnNames



</t>
<t tx="wjl.20110328233312.1323">defaultTestLoader = TestLoader()


##############################################################################
# Patches for old functions: these functions should be considered obsolete
##############################################################################

def _makeLoader(prefix, sortUsing, suiteClass=None):
    loader = TestLoader()
    loader.sortTestMethodsUsing = sortUsing
    loader.testMethodPrefix = prefix
    if suiteClass: loader.suiteClass = suiteClass
    return loader

</t>
<t tx="wjl.20110328233312.1324">def getTestCaseNames(testCaseClass, prefix, sortUsing=cmp):
    return _makeLoader(prefix, sortUsing).getTestCaseNames(testCaseClass)

</t>
<t tx="wjl.20110328233312.1325">def makeSuite(testCaseClass, prefix='test', sortUsing=cmp, suiteClass=TestSuite):
    return _makeLoader(prefix, sortUsing, suiteClass).loadTestsFromTestCase(testCaseClass)

</t>
<t tx="wjl.20110328233312.1326">def findTestCases(module, prefix='test', sortUsing=cmp, suiteClass=TestSuite):
    return _makeLoader(prefix, sortUsing, suiteClass).loadTestsFromModule(module)


</t>
<t tx="wjl.20110328233312.1327">##############################################################################
# Text UI
##############################################################################

class _WritelnDecorator:
    """Used to decorate file-like objects with a handy 'writeln' method"""
    @others
</t>
<t tx="wjl.20110328233312.1328">def __init__(self,stream):
    self.stream = stream

</t>
<t tx="wjl.20110328233312.1329">def __getattr__(self, attr):
    return getattr(self.stream,attr)

</t>
<t tx="wjl.20110328233312.1330">def writeln(self, arg=None):
    if arg: self.write(arg)
    self.write('\n') # text-mode streams translate to \r\n if needed


</t>
<t tx="wjl.20110328233312.1331">class _TextTestResult(TestResult):
    """A test result class that can print formatted text results to a stream.

    Used by TextTestRunner.
    """
    separator1 = '=' * 70
    separator2 = '-' * 70

    @others
</t>
<t tx="wjl.20110328233312.1332">def __init__(self, stream, descriptions, verbosity):
    TestResult.__init__(self)
    self.stream = stream
    self.showAll = verbosity &gt; 1
    self.dots = verbosity == 1
    self.descriptions = descriptions

</t>
<t tx="wjl.20110328233312.1333">def getDescription(self, test):
    if self.descriptions:
        return test.shortDescription() or str(test)
    else:
        return str(test)

</t>
<t tx="wjl.20110328233312.1334">def startTest(self, test):
    TestResult.startTest(self, test)
    if self.showAll:
        self.stream.write(self.getDescription(test))
        self.stream.write(" ... ")
        self.stream.flush()

</t>
<t tx="wjl.20110328233312.1335">def addSuccess(self, test):
    TestResult.addSuccess(self, test)
    if self.showAll:
        self.stream.writeln("ok")
    elif self.dots:
        self.stream.write('.')
        self.stream.flush()

</t>
<t tx="wjl.20110328233312.1336">def addError(self, test, err):
    TestResult.addError(self, test, err)
    if self.showAll:
        self.stream.writeln("ERROR")
    elif self.dots:
        self.stream.write('E')
        self.stream.flush()

</t>
<t tx="wjl.20110328233312.1337">def addFailure(self, test, err):
    TestResult.addFailure(self, test, err)
    if self.showAll:
        self.stream.writeln("FAIL")
    elif self.dots:
        self.stream.write('F')
        self.stream.flush()

</t>
<t tx="wjl.20110328233312.1338">def printErrors(self):
    if self.dots or self.showAll:
        self.stream.writeln()
    self.printErrorList('ERROR', self.errors)
    self.printErrorList('FAIL', self.failures)

</t>
<t tx="wjl.20110328233312.1339">def printErrorList(self, flavour, errors):
    for test, err in errors:
        self.stream.writeln(self.separator1)
        self.stream.writeln("%s: %s" % (flavour,self.getDescription(test)))
        self.stream.writeln(self.separator2)
        self.stream.writeln("%s" % err)


</t>
<t tx="wjl.20110328233312.1340">class TextTestRunner:
    """A test runner class that displays results in textual form.
    It prints out the names of tests as they are run, errors as they
    occur, and a summary of the results at the end of the test run.
    """
    @others
</t>
<t tx="wjl.20110328233312.1341">def __init__(self, stream=sys.stderr, descriptions=1, verbosity=1):
    self.stream = _WritelnDecorator(stream)
    self.descriptions = descriptions
    self.verbosity = verbosity

</t>
<t tx="wjl.20110328233312.1342">def _makeResult(self):
    return _TextTestResult(self.stream, self.descriptions, self.verbosity)

</t>
<t tx="wjl.20110328233312.1343">def run(self, test):
    "Run the given test case or test suite."
    result = self._makeResult()
    startTime = time.time()
    test(result)
    stopTime = time.time()
    timeTaken = stopTime - startTime
    result.printErrors()
    self.stream.writeln(result.separator2)
    run = result.testsRun
    self.stream.writeln("Ran %d test%s in %.3fs" %
                        (run, run != 1 and "s" or "", timeTaken))
    self.stream.writeln()
    print 'this must be just before the end of the result,coz no exception'
    if not result.wasSuccessful():
        self.stream.write("FAILED (")
        failed, errored = map(len, (result.failures, result.errors))
        if failed:
            self.stream.write("failures=%d" % failed)
        if errored:
            if failed: self.stream.write(", ")
            self.stream.write("errors=%d" % errored)
        self.stream.writeln(")")
    else:
        self.stream.writeln("OK")
    print 'this must be in the end'
    return result



</t>
<t tx="wjl.20110328233312.1344">##############################################################################
# Facilities for running tests from the command line
##############################################################################

class TestProgram:
    """A command-line program that runs a set of tests; this is primarily
       for making test modules conveniently executable.
    """
    USAGE = """\
Usage: %(progName)s [options] [test] [...]

Options:
  -h, --help       Show this message
  -v, --verbose    Verbose output
  -q, --quiet      Minimal output

Examples:
  %(progName)s                               - run default set of tests
  %(progName)s MyTestSuite                   - run suite 'MyTestSuite'
  %(progName)s MyTestCase.testSomething      - run MyTestCase.testSomething
  %(progName)s MyTestCase                    - run all 'test*' test methods
                                               in MyTestCase
"""
    @others
</t>
<t tx="wjl.20110328233312.1345">def __init__(self, module='__main__', defaultTest=None,
             argv=None, testRunner=None,
             testLoader=defaultTestLoader):

    if type(module) == type(''):
        self.module = __import__(module)
        for part in module.split('.')[1:]:
            self.module = getattr(self.module, part)
    else:
        self.module = module
    if argv is None:
        argv = sys.argv
    self.verbosity = 1
    self.defaultTest = defaultTest
    self.testRunner = testRunner
    self.testLoader = testLoader
    self.progName = os.path.basename(argv[0])
    self.parseArgs(argv)
    self.runTests()

</t>
<t tx="wjl.20110328233312.1346">def usageExit(self, msg=None):
    if msg: print msg
    print self.USAGE % self.__dict__
    sys.exit(2)

</t>
<t tx="wjl.20110328233312.1347">def parseArgs(self, argv):
    print argv
    import getopt
    try:
        options, args = getopt.getopt(argv[1:], 'hHvq',
                                      ['help','verbose','quiet'])
        for opt, value in options:
            if opt in ('-h','-H','--help'):
                self.usageExit()
            if opt in ('-q','--quiet'):
                self.verbosity = 0
            if opt in ('-v','--verbose'):
                self.verbosity = 2
        if len(args) == 0 and self.defaultTest is None:
            self.test = self.testLoader.loadTestsFromModule(self.module)
            print self.module
            return
        if len(args) &gt; 0:
            self.testNames = args
        else:
            self.testNames = (self.defaultTest,)
        self.createTests()
    except getopt.error, msg:
        self.usageExit(msg)

</t>
<t tx="wjl.20110328233312.1348">def createTests(self):
    print 'createTests'
    self.test = self.testLoader.loadTestsFromNames(self.testNames,
                                                   self.module)

</t>
<t tx="wjl.20110328233312.1349">def runTests(self):
    if self.testRunner is None:
        self.testRunner = TextTestRunner

    if isinstance(self.testRunner, (type, types.ClassType)):
        try:
            testRunner = self.testRunner(verbosity=self.verbosity)
        except TypeError:
            # didn't accept the verbosity argument
            testRunner = self.testRunner()
    else:
        # it is assumed to be a TestRunner instance
        testRunner = self.testRunner
    result = testRunner.run(self.test)#this is the key line to invoke the testRunner`s run method
    sys.exit(not result.wasSuccessful())

</t>
</tnodes>
</leo_file>
