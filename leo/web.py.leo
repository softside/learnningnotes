<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="zhanglei.20100830144432.1243"><vh>@chapters</vh></v>
<v t="zhanglei.20100830103303.1243" a="E"><vh>web.py</vh>
<v t="zhanglei.20100830144432.1813" a="E"><vh>web</vh>
<v t="zhanglei.20100830144432.1244"><vh>@file /home/zhanglei/web.py-0.33/web/application.py</vh>
<v t="zhanglei.20100830144432.1245"><vh>application declarations</vh></v>
<v t="zhanglei.20100830144432.1246"><vh>class application</vh>
<v t="zhanglei.20100830144432.1247"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1248"><vh>_load</vh></v>
<v t="zhanglei.20100830144432.1249"><vh>_unload</vh></v>
<v t="zhanglei.20100830144432.1250"><vh>_cleanup</vh></v>
<v t="zhanglei.20100830144432.1251"><vh>add_mapping</vh></v>
<v t="zhanglei.20100830144432.1252"><vh>add_processor</vh></v>
<v t="zhanglei.20100830144432.1253"><vh>request</vh></v>
<v t="zhanglei.20100830144432.1254"><vh>browser</vh></v>
<v t="zhanglei.20100830144432.1255"><vh>handle</vh></v>
<v t="zhanglei.20100830144432.1256"><vh>handle_with_processors</vh></v>
<v t="zhanglei.20100830144432.1257"><vh>wsgifunc</vh></v>
<v t="zhanglei.20100830144432.1258"><vh>run</vh></v>
<v t="zhanglei.20100830144432.1259"><vh>cgirun</vh></v>
<v t="zhanglei.20100830144432.1260"><vh>load</vh></v>
<v t="zhanglei.20100830144432.1261"><vh>_delegate</vh></v>
<v t="zhanglei.20100830144432.1262"><vh>_match</vh></v>
<v t="zhanglei.20100830144432.1263"><vh>_delegate_sub_application</vh></v>
<v t="zhanglei.20100830144432.1264"><vh>get_parent_app</vh></v>
<v t="zhanglei.20100830144432.1265"><vh>notfound</vh></v>
<v t="zhanglei.20100830144432.1266"><vh>internalerror</vh></v>
</v>
<v t="zhanglei.20100830144432.1267"><vh>class auto_application</vh>
<v t="zhanglei.20100830144432.1268"><vh>__init__</vh></v>
</v>
<v t="zhanglei.20100830144432.1269"><vh>class subdomain_application</vh>
<v t="zhanglei.20100830144432.1270"><vh>handle</vh></v>
<v t="zhanglei.20100830144432.1271"><vh>_match</vh></v>
</v>
<v t="zhanglei.20100830144432.1272"><vh>loadhook</vh></v>
<v t="zhanglei.20100830144432.1273"><vh>unloadhook</vh></v>
<v t="zhanglei.20100830144432.1274"><vh>autodelegate</vh></v>
<v t="zhanglei.20100830144432.1275"><vh>class Reloader</vh>
<v t="zhanglei.20100830144432.1276"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1277"><vh>__call__</vh></v>
<v t="zhanglei.20100830144432.1278"><vh>check</vh></v>
</v>
<v t="zhanglei.20100830144432.1279"><vh>@file /home/zhanglei/web.py-0.33/web/browser.py</vh>
<v t="zhanglei.20100830144432.1280"><vh>browser declarations</vh></v>
<v t="zhanglei.20100830144432.1281"><vh>class BrowserError</vh></v>
<v t="zhanglei.20100830144432.1282"><vh>class Browser</vh>
<v t="zhanglei.20100830144432.1283"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1284"><vh>reset</vh></v>
<v t="zhanglei.20100830144432.1285"><vh>build_opener</vh></v>
<v t="zhanglei.20100830144432.1286"><vh>do_request</vh></v>
<v t="zhanglei.20100830144432.1287"><vh>open</vh></v>
<v t="zhanglei.20100830144432.1288"><vh>show</vh></v>
<v t="zhanglei.20100830144432.1289"><vh>get_response</vh></v>
<v t="zhanglei.20100830144432.1290"><vh>get_soup</vh></v>
<v t="zhanglei.20100830144432.1291"><vh>get_text</vh></v>
<v t="zhanglei.20100830144432.1292"><vh>_get_links</vh></v>
<v t="zhanglei.20100830144432.1293"><vh>get_links</vh></v>
<v t="zhanglei.20100830144432.1294"><vh>follow_link</vh></v>
<v t="zhanglei.20100830144432.1295"><vh>find_link</vh></v>
<v t="zhanglei.20100830144432.1296"><vh>_filter_links</vh></v>
<v t="zhanglei.20100830144432.1297"><vh>get_forms</vh></v>
<v t="zhanglei.20100830144432.1298"><vh>select_form</vh></v>
<v t="zhanglei.20100830144432.1299"><vh>submit</vh></v>
<v t="zhanglei.20100830144432.1300"><vh>__getitem__</vh></v>
<v t="zhanglei.20100830144432.1301"><vh>__setitem__</vh></v>
</v>
<v t="zhanglei.20100830144432.1302"><vh>class AppBrowser</vh>
<v t="zhanglei.20100830144432.1303"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1304"><vh>build_opener</vh></v>
</v>
<v t="zhanglei.20100830144432.1305"><vh>class AppHandler</vh>
<v t="zhanglei.20100830144432.1306"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1307"><vh>http_open</vh></v>
<v t="zhanglei.20100830144432.1308"><vh>https_open</vh></v>
<v t="zhanglei.20100830144432.1309"><vh>_make_response</vh></v>
</v>
</v>
</v>
<v t="zhanglei.20100830144432.1310"><vh>@file /home/zhanglei/web.py-0.33/web/db.py</vh>
<v t="zhanglei.20100830144432.1311"><vh>db declarations</vh></v>
<v t="zhanglei.20100830144432.1312"><vh>class UnknownDB</vh></v>
<v t="zhanglei.20100830144432.1313"><vh>class _ItplError</vh>
<v t="zhanglei.20100830144432.1314"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1315"><vh>__str__</vh></v>
</v>
<v t="zhanglei.20100830144432.1316"><vh>class TransactionError</vh></v>
<v t="zhanglei.20100830144432.1317"><vh>class UnknownParamstyle</vh></v>
<v t="zhanglei.20100830144432.1318"><vh>class SQLParam</vh>
<v t="zhanglei.20100830144432.1319"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1320"><vh>get_marker</vh></v>
<v t="zhanglei.20100830144432.1321"><vh>sqlquery</vh></v>
<v t="zhanglei.20100830144432.1322"><vh>__add__</vh></v>
<v t="zhanglei.20100830144432.1323"><vh>__radd__</vh></v>
<v t="zhanglei.20100830144432.1324"><vh>__str__</vh></v>
<v t="zhanglei.20100830144432.1325"><vh>__repr__</vh></v>
</v>
<v t="zhanglei.20100830144432.1326"><vh>class SQLQuery</vh>
<v t="zhanglei.20100830144432.1327"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1328"><vh>__add__</vh></v>
<v t="zhanglei.20100830144432.1329"><vh>__radd__</vh></v>
<v t="zhanglei.20100830144432.1330"><vh>__iadd__</vh></v>
<v t="zhanglei.20100830144432.1331"><vh>__len__</vh></v>
<v t="zhanglei.20100830144432.1332"><vh>query</vh></v>
<v t="zhanglei.20100830144432.1333"><vh>values</vh></v>
<v t="zhanglei.20100830144432.1334"><vh>join</vh></v>
<v t="zhanglei.20100830144432.1335"><vh>_str</vh></v>
<v t="zhanglei.20100830144432.1336"><vh>__str__</vh></v>
<v t="zhanglei.20100830144432.1337"><vh>__unicode__</vh></v>
<v t="zhanglei.20100830144432.1338"><vh>__repr__</vh></v>
</v>
<v t="zhanglei.20100830144432.1339"><vh>class SQLLiteral</vh>
<v t="zhanglei.20100830144432.1340"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1341"><vh>__repr__</vh></v>
</v>
<v t="zhanglei.20100830144432.1342"><vh>_sqllist</vh></v>
<v t="zhanglei.20100830144432.1343"><vh>reparam</vh></v>
<v t="zhanglei.20100830144432.1344"><vh>sqlify</vh></v>
<v t="zhanglei.20100830144432.1345"><vh>sqllist</vh></v>
<v t="zhanglei.20100830144432.1346"><vh>sqlors</vh></v>
<v t="zhanglei.20100830144432.1347"><vh>sqlwhere</vh></v>
<v t="zhanglei.20100830144432.1348"><vh>sqlquote</vh></v>
<v t="zhanglei.20100830144432.1349"><vh>class Transaction</vh>
<v t="zhanglei.20100830144432.1350"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1351"><vh>__enter__</vh></v>
<v t="zhanglei.20100830144432.1352"><vh>__exit__</vh></v>
<v t="zhanglei.20100830144432.1353"><vh>commit</vh></v>
<v t="zhanglei.20100830144432.1354"><vh>rollback</vh></v>
</v>
<v t="zhanglei.20100830144432.1355"><vh>class DB</vh>
<v t="zhanglei.20100830144432.1356"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1357"><vh>_getctx</vh></v>
<v t="zhanglei.20100830144432.1358"><vh>_load_context</vh></v>
<v t="zhanglei.20100830144432.1359"><vh>_unload_context</vh></v>
<v t="zhanglei.20100830144432.1360"><vh>_connect</vh></v>
<v t="zhanglei.20100830144432.1361"><vh>_connect_with_pooling</vh></v>
<v t="zhanglei.20100830144432.1362"><vh>_db_cursor</vh></v>
<v t="zhanglei.20100830144432.1363"><vh>_param_marker</vh></v>
<v t="zhanglei.20100830144432.1364"><vh>_db_execute</vh></v>
<v t="zhanglei.20100830144432.1365"><vh>_where</vh></v>
<v t="zhanglei.20100830144432.1366"><vh>query</vh></v>
<v t="zhanglei.20100830144432.1367"><vh>select</vh></v>
<v t="zhanglei.20100830144432.1368"><vh>where</vh></v>
<v t="zhanglei.20100830144432.1369"><vh>sql_clauses</vh></v>
<v t="zhanglei.20100830144432.1370"><vh>gen_clause</vh></v>
<v t="zhanglei.20100830144432.1371"><vh>insert</vh></v>
<v t="zhanglei.20100830144432.1372"><vh>multiple_insert</vh></v>
<v t="zhanglei.20100830144432.1373"><vh>update</vh></v>
<v t="zhanglei.20100830144432.1374"><vh>delete</vh></v>
<v t="zhanglei.20100830144432.1375"><vh>_process_insert_query</vh></v>
<v t="zhanglei.20100830144432.1376"><vh>transaction</vh></v>
</v>
<v t="zhanglei.20100830144432.1377"><vh>class PostgresDB</vh>
<v t="zhanglei.20100830144432.1378"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1379"><vh>_process_insert_query</vh></v>
<v t="zhanglei.20100830144432.1380"><vh>_get_all_sequences</vh></v>
<v t="zhanglei.20100830144432.1381"><vh>_connect</vh></v>
<v t="zhanglei.20100830144432.1382"><vh>_connect_with_pooling</vh></v>
</v>
<v t="zhanglei.20100830144432.1383"><vh>class MySQLDB</vh>
<v t="zhanglei.20100830144432.1384"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1385"><vh>_process_insert_query</vh></v>
</v>
<v t="zhanglei.20100830144432.1386"><vh>import_driver</vh></v>
<v t="zhanglei.20100830144432.1387"><vh>class SqliteDB</vh>
<v t="zhanglei.20100830144432.1388"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1389"><vh>_process_insert_query</vh></v>
<v t="zhanglei.20100830144432.1390"><vh>query</vh></v>
</v>
<v t="zhanglei.20100830144432.1391"><vh>class FirebirdDB</vh>
<v t="zhanglei.20100830144432.1392"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1393"><vh>delete</vh></v>
<v t="zhanglei.20100830144432.1394"><vh>sql_clauses</vh></v>
</v>
<v t="zhanglei.20100830144432.1395"><vh>class MSSQLDB</vh>
<v t="zhanglei.20100830144432.1396"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1397"><vh>sql_clauses</vh></v>
<v t="zhanglei.20100830144432.1398"><vh>_test</vh></v>
</v>
<v t="zhanglei.20100830144432.1399"><vh>class OracleDB</vh>
<v t="zhanglei.20100830144432.1400"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1401"><vh>_process_insert_query</vh></v>
</v>
<v t="zhanglei.20100830144432.1402"><vh>database</vh></v>
<v t="zhanglei.20100830144432.1403"><vh>register_database</vh></v>
<v t="zhanglei.20100830144432.1404"><vh>_interpolate</vh></v>
</v>
<v t="zhanglei.20100830144432.1405"><vh>@file /home/zhanglei/web.py-0.33/web/debugerror.py</vh>
<v t="zhanglei.20100830144432.1406"><vh>debugerror declarations</vh></v>
<v t="zhanglei.20100830144432.1407"><vh>djangoerror</vh></v>
<v t="zhanglei.20100830144432.1408"><vh>debugerror</vh></v>
<v t="zhanglei.20100830144432.1409"><vh>emailerrors</vh></v>
</v>
<v t="zhanglei.20100830144432.1410"><vh>@file /home/zhanglei/web.py-0.33/web/form.py</vh>
<v t="zhanglei.20100830144432.1411"><vh>form declarations</vh></v>
<v t="zhanglei.20100830144432.1412"><vh>attrget</vh></v>
<v t="zhanglei.20100830144432.1413"><vh>class Form</vh>
<v t="zhanglei.20100830144432.1414"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1415"><vh>__call__</vh></v>
<v t="zhanglei.20100830144432.1416"><vh>render</vh></v>
<v t="zhanglei.20100830144432.1417"><vh>render_css</vh></v>
<v t="zhanglei.20100830144432.1418"><vh>rendernote</vh></v>
<v t="zhanglei.20100830144432.1419"><vh>validates</vh></v>
<v t="zhanglei.20100830144432.1420"><vh>_validate</vh></v>
<v t="zhanglei.20100830144432.1421"><vh>fill</vh></v>
<v t="zhanglei.20100830144432.1422"><vh>__getitem__</vh></v>
<v t="zhanglei.20100830144432.1423"><vh>__getattr__</vh></v>
<v t="zhanglei.20100830144432.1424"><vh>get</vh></v>
<v t="zhanglei.20100830144432.1425"><vh>_get_d</vh></v>
</v>
<v t="zhanglei.20100830144432.1426"><vh>class Input</vh>
<v t="zhanglei.20100830144432.1427"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1428"><vh>is_hidden</vh></v>
<v t="zhanglei.20100830144432.1429"><vh>get_type</vh></v>
<v t="zhanglei.20100830144432.1430"><vh>get_default_id</vh></v>
<v t="zhanglei.20100830144432.1431"><vh>validate</vh></v>
<v t="zhanglei.20100830144432.1432"><vh>set_value</vh></v>
<v t="zhanglei.20100830144432.1433"><vh>get_value</vh></v>
<v t="zhanglei.20100830144432.1434"><vh>render</vh></v>
<v t="zhanglei.20100830144432.1435"><vh>rendernote</vh></v>
<v t="zhanglei.20100830144432.1436"><vh>addatts</vh></v>
</v>
<v t="zhanglei.20100830144432.1437"><vh>class AttributeList</vh>
<v t="zhanglei.20100830144432.1438"><vh>copy</vh></v>
<v t="zhanglei.20100830144432.1439"><vh>__str__</vh></v>
<v t="zhanglei.20100830144432.1440"><vh>__repr__</vh></v>
</v>
<v t="zhanglei.20100830144432.1441"><vh>class Textbox</vh>
<v t="zhanglei.20100830144432.1442"><vh>get_type</vh></v>
</v>
<v t="zhanglei.20100830144432.1443"><vh>class Password</vh>
<v t="zhanglei.20100830144432.1444"><vh>get_type</vh></v>
</v>
<v t="zhanglei.20100830144432.1445"><vh>class Textarea</vh>
<v t="zhanglei.20100830144432.1446"><vh>render</vh></v>
</v>
<v t="zhanglei.20100830144432.1447"><vh>class Dropdown</vh>
<v t="zhanglei.20100830144432.1448"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1449"><vh>render</vh></v>
</v>
<v t="zhanglei.20100830144432.1450"><vh>class Radio</vh>
<v t="zhanglei.20100830144432.1451"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1452"><vh>render</vh></v>
</v>
<v t="zhanglei.20100830144432.1453"><vh>class Checkbox</vh>
<v t="zhanglei.20100830144432.1454"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1455"><vh>get_default_id</vh></v>
<v t="zhanglei.20100830144432.1456"><vh>render</vh></v>
<v t="zhanglei.20100830144432.1457"><vh>set_value</vh></v>
<v t="zhanglei.20100830144432.1458"><vh>get_value</vh></v>
</v>
<v t="zhanglei.20100830144432.1459"><vh>class Button</vh>
<v t="zhanglei.20100830144432.1460"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1461"><vh>render</vh></v>
</v>
<v t="zhanglei.20100830144432.1462"><vh>class Hidden</vh>
<v t="zhanglei.20100830144432.1463"><vh>is_hidden</vh></v>
<v t="zhanglei.20100830144432.1464"><vh>get_type</vh></v>
</v>
<v t="zhanglei.20100830144432.1465"><vh>class File</vh>
<v t="zhanglei.20100830144432.1466"><vh>get_type</vh></v>
</v>
<v t="zhanglei.20100830144432.1467"><vh>class Validator</vh>
<v t="zhanglei.20100830144432.1468"><vh>__deepcopy__</vh></v>
<v t="zhanglei.20100830144432.1469"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1470"><vh>valid</vh></v>
</v>
<v t="zhanglei.20100830144432.1471"><vh>class regexp</vh>
<v t="zhanglei.20100830144432.1472"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1473"><vh>valid</vh></v>
</v>
</v>
<v t="zhanglei.20100830144432.1474"><vh>@file /home/zhanglei/web.py-0.33/web/http.py</vh>
<v t="zhanglei.20100830144432.1475"><vh>http declarations</vh></v>
<v t="zhanglei.20100830144432.1476"><vh>prefixurl</vh></v>
<v t="zhanglei.20100830144432.1477"><vh>expires</vh></v>
<v t="zhanglei.20100830144432.1478"><vh>lastmodified</vh></v>
<v t="zhanglei.20100830144432.1479"><vh>modified</vh></v>
<v t="zhanglei.20100830144432.1480"><vh>urlencode</vh></v>
<v t="zhanglei.20100830144432.1481"><vh>changequery</vh></v>
<v t="zhanglei.20100830144432.1482"><vh>url</vh></v>
<v t="zhanglei.20100830144432.1483"><vh>profiler</vh></v>
</v>
<v t="zhanglei.20100830144432.1484"><vh>@file /home/zhanglei/web.py-0.33/web/httpserver.py</vh>
<v t="zhanglei.20100830144432.1485"><vh>httpserver declarations</vh></v>
<v t="zhanglei.20100830144432.1486"><vh>runbasic</vh></v>
<v t="zhanglei.20100830144432.1487"><vh>runsimple</vh></v>
<v t="zhanglei.20100830144432.1488"><vh>WSGIServer</vh></v>
<v t="zhanglei.20100830144432.1489"><vh>class StaticApp</vh>
<v t="zhanglei.20100830144432.1490"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1491"><vh>send_response</vh></v>
<v t="zhanglei.20100830144432.1492"><vh>send_header</vh></v>
<v t="zhanglei.20100830144432.1493"><vh>end_headers</vh></v>
<v t="zhanglei.20100830144432.1494"><vh>log_message</vh></v>
<v t="zhanglei.20100830144432.1495"><vh>__iter__</vh></v>
</v>
<v t="zhanglei.20100830144432.1496"><vh>class StaticMiddleware</vh>
<v t="zhanglei.20100830144432.1497"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1498"><vh>__call__</vh></v>
</v>
<v t="zhanglei.20100830144432.1499"><vh>class LogMiddleware</vh>
<v t="zhanglei.20100830144432.1500"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1501"><vh>__call__</vh></v>
<v t="zhanglei.20100830144432.1502"><vh>log</vh></v>
</v>
</v>
<v t="zhanglei.20100830144432.1503"><vh>@file /home/zhanglei/web.py-0.33/web/__init__.py</vh>
<v t="zhanglei.20100830144432.1504"><vh>__init__ declarations</vh></v>
</v>
<v t="zhanglei.20100830144432.1505" a="O"><vh>@file /home/zhanglei/web.py-0.33/web/net.py</vh>
<v t="zhanglei.20100830144432.1506"><vh>net declarations</vh></v>
<v t="zhanglei.20100830144432.1507"><vh>validipaddr</vh></v>
<v t="zhanglei.20100830144432.1508"><vh>validipport</vh></v>
<v t="zhanglei.20100830144432.1509"><vh>validip</vh></v>
<v t="zhanglei.20100830144432.1510"><vh>validaddr</vh></v>
<v t="zhanglei.20100830144432.1511"><vh>urlquote</vh></v>
<v t="zhanglei.20100830144432.1512"><vh>httpdate</vh></v>
<v t="zhanglei.20100830144432.1513"><vh>parsehttpdate</vh></v>
<v t="zhanglei.20100830144432.1514"><vh>htmlquote</vh></v>
<v t="zhanglei.20100830144432.1515"><vh>htmlunquote</vh></v>
<v t="zhanglei.20100830144432.1516"><vh>websafe</vh></v>
<v t="zhanglei.20100830144432.1517"><vh>@file /home/zhanglei/web.py-0.33/web/_project</vh></v>
</v>
<v t="zhanglei.20100830144432.1518"><vh>@file /home/zhanglei/web.py-0.33/web/session.py</vh>
<v t="zhanglei.20100830144432.1519"><vh>session declarations</vh></v>
<v t="zhanglei.20100830144432.1520"><vh>class SessionExpired</vh>
<v t="zhanglei.20100830144432.1521"><vh>__init__</vh></v>
</v>
<v t="zhanglei.20100830144432.1522"><vh>class Session</vh>
<v t="zhanglei.20100830144432.1523"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1524"><vh>_processor</vh></v>
<v t="zhanglei.20100830144432.1525"><vh>_load</vh></v>
<v t="zhanglei.20100830144432.1526"><vh>_check_expiry</vh></v>
<v t="zhanglei.20100830144432.1527"><vh>_validate_ip</vh></v>
<v t="zhanglei.20100830144432.1528"><vh>_save</vh></v>
<v t="zhanglei.20100830144432.1529"><vh>_generate_session_id</vh></v>
<v t="zhanglei.20100830144432.1530"><vh>_valid_session_id</vh></v>
<v t="zhanglei.20100830144432.1531"><vh>_cleanup</vh></v>
<v t="zhanglei.20100830144432.1532"><vh>expired</vh></v>
<v t="zhanglei.20100830144432.1533"><vh>kill</vh></v>
</v>
<v t="zhanglei.20100830144432.1534"><vh>class Store</vh>
<v t="zhanglei.20100830144432.1535"><vh>__contains__</vh></v>
<v t="zhanglei.20100830144432.1536"><vh>__getitem__</vh></v>
<v t="zhanglei.20100830144432.1537"><vh>__setitem__</vh></v>
<v t="zhanglei.20100830144432.1538"><vh>cleanup</vh></v>
<v t="zhanglei.20100830144432.1539"><vh>encode</vh></v>
<v t="zhanglei.20100830144432.1540"><vh>decode</vh></v>
</v>
<v t="zhanglei.20100830144432.1541"><vh>class DiskStore</vh>
<v t="zhanglei.20100830144432.1542"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1543"><vh>_get_path</vh></v>
<v t="zhanglei.20100830144432.1544"><vh>__contains__</vh></v>
<v t="zhanglei.20100830144432.1545"><vh>__getitem__</vh></v>
<v t="zhanglei.20100830144432.1546"><vh>__setitem__</vh></v>
<v t="zhanglei.20100830144432.1547"><vh>__delitem__</vh></v>
<v t="zhanglei.20100830144432.1548"><vh>cleanup</vh></v>
</v>
<v t="zhanglei.20100830144432.1549"><vh>class DBStore</vh>
<v t="zhanglei.20100830144432.1550"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1551"><vh>__contains__</vh></v>
<v t="zhanglei.20100830144432.1552"><vh>__getitem__</vh></v>
<v t="zhanglei.20100830144432.1553"><vh>__setitem__</vh></v>
<v t="zhanglei.20100830144432.1554"><vh>__delitem__</vh></v>
<v t="zhanglei.20100830144432.1555"><vh>cleanup</vh></v>
</v>
<v t="zhanglei.20100830144432.1556"><vh>class ShelfStore</vh>
<v t="zhanglei.20100830144432.1557"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1558"><vh>__contains__</vh></v>
<v t="zhanglei.20100830144432.1559"><vh>__getitem__</vh></v>
<v t="zhanglei.20100830144432.1560"><vh>__setitem__</vh></v>
<v t="zhanglei.20100830144432.1561"><vh>__delitem__</vh></v>
<v t="zhanglei.20100830144432.1562"><vh>cleanup</vh></v>
</v>
</v>
<v t="zhanglei.20100830144432.1563"><vh>@file /home/zhanglei/web.py-0.33/web/template.py</vh>
<v t="zhanglei.20100830144432.1564"><vh>template declarations</vh></v>
<v t="zhanglei.20100830144432.1565"><vh>splitline</vh></v>
<v t="zhanglei.20100830144432.1566"><vh>class Parser</vh>
<v t="zhanglei.20100830144432.1567"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1568"><vh>parse</vh></v>
<v t="zhanglei.20100830144432.1569"><vh>read_defwith</vh></v>
<v t="zhanglei.20100830144432.1570"><vh>read_section</vh></v>
<v t="zhanglei.20100830144432.1571"><vh>read_var</vh></v>
<v t="zhanglei.20100830144432.1572"><vh>read_suite</vh></v>
<v t="zhanglei.20100830144432.1573"><vh>readline</vh></v>
<v t="zhanglei.20100830144432.1574"><vh>read_node</vh></v>
<v t="zhanglei.20100830144432.1575"><vh>read_text</vh></v>
<v t="zhanglei.20100830144432.1576"><vh>read_keyword</vh></v>
<v t="zhanglei.20100830144432.1577"><vh>read_expr</vh></v>
<v t="zhanglei.20100830144432.1578"><vh>read_assignment</vh></v>
<v t="zhanglei.20100830144432.1579"><vh>python_lookahead</vh></v>
<v t="zhanglei.20100830144432.1580"><vh>python_tokens</vh></v>
<v t="zhanglei.20100830144432.1581"><vh>read_indented_block</vh></v>
<v t="zhanglei.20100830144432.1582"><vh>read_statement</vh></v>
<v t="zhanglei.20100830144432.1583"><vh>read_block_section</vh></v>
<v t="zhanglei.20100830144432.1584"><vh>create_block_node</vh></v>
</v>
<v t="zhanglei.20100830144432.1585"><vh>class PythonTokenizer</vh>
<v t="zhanglei.20100830144432.1586"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1587"><vh>consume_till</vh></v>
<v t="zhanglei.20100830144432.1588"><vh>next</vh></v>
</v>
<v t="zhanglei.20100830144432.1589"><vh>class DefwithNode</vh>
<v t="zhanglei.20100830144432.1590"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1591"><vh>emit</vh></v>
<v t="zhanglei.20100830144432.1592"><vh>__repr__</vh></v>
</v>
<v t="zhanglei.20100830144432.1593"><vh>class TextNode</vh>
<v t="zhanglei.20100830144432.1594"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1595"><vh>emit</vh></v>
<v t="zhanglei.20100830144432.1596"><vh>__repr__</vh></v>
</v>
<v t="zhanglei.20100830144432.1597"><vh>class ExpressionNode</vh>
<v t="zhanglei.20100830144432.1598"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1599"><vh>emit</vh></v>
<v t="zhanglei.20100830144432.1600"><vh>__repr__</vh></v>
</v>
<v t="zhanglei.20100830144432.1601"><vh>class AssignmentNode</vh>
<v t="zhanglei.20100830144432.1602"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1603"><vh>emit</vh></v>
<v t="zhanglei.20100830144432.1604"><vh>__repr__</vh></v>
</v>
<v t="zhanglei.20100830144432.1605"><vh>class LineNode</vh>
<v t="zhanglei.20100830144432.1606"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1607"><vh>emit</vh></v>
<v t="zhanglei.20100830144432.1608"><vh>__repr__</vh></v>
</v>
<v t="zhanglei.20100830144432.1609"><vh>class BlockNode</vh>
<v t="zhanglei.20100830144432.1610"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1611"><vh>emit</vh></v>
<v t="zhanglei.20100830144432.1612"><vh>text</vh></v>
<v t="zhanglei.20100830144432.1613"><vh>__repr__</vh></v>
</v>
<v t="zhanglei.20100830144432.1614"><vh>class ForNode</vh>
<v t="zhanglei.20100830144432.1615"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1616"><vh>__repr__</vh></v>
</v>
<v t="zhanglei.20100830144432.1617"><vh>class CodeNode</vh>
<v t="zhanglei.20100830144432.1618"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1619"><vh>emit</vh></v>
<v t="zhanglei.20100830144432.1620"><vh>__repr__</vh></v>
</v>
<v t="zhanglei.20100830144432.1621"><vh>class IfNode</vh></v>
<v t="zhanglei.20100830144432.1622"><vh>class ElseNode</vh></v>
<v t="zhanglei.20100830144432.1623"><vh>class ElifNode</vh></v>
<v t="zhanglei.20100830144432.1624"><vh>class DefNode</vh></v>
<v t="zhanglei.20100830144432.1625"><vh>class VarNode</vh>
<v t="zhanglei.20100830144432.1626"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1627"><vh>emit</vh></v>
<v t="zhanglei.20100830144432.1628"><vh>__repr__</vh></v>
</v>
<v t="zhanglei.20100830144432.1629"><vh>class SuiteNode</vh>
<v t="zhanglei.20100830144432.1630"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1631"><vh>emit</vh></v>
<v t="zhanglei.20100830144432.1632"><vh>__repr__</vh></v>
</v>
<v t="zhanglei.20100830144432.1633"><vh>class ForLoop</vh>
<v t="zhanglei.20100830144432.1634"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1635"><vh>__getattr__</vh></v>
<v t="zhanglei.20100830144432.1636"><vh>setup</vh></v>
<v t="zhanglei.20100830144432.1637"><vh>_push</vh></v>
<v t="zhanglei.20100830144432.1638"><vh>_pop</vh></v>
</v>
<v t="zhanglei.20100830144432.1639"><vh>class ForLoopContext</vh>
<v t="zhanglei.20100830144432.1640"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1641"><vh>setup</vh></v>
<v t="zhanglei.20100830144432.1642"><vh>_next</vh></v>
</v>
<v t="zhanglei.20100830144432.1643"><vh>class BaseTemplate</vh>
<v t="zhanglei.20100830144432.1644"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1645"><vh>_compile</vh></v>
<v t="zhanglei.20100830144432.1646"><vh>__call__</vh></v>
<v t="zhanglei.20100830144432.1647"><vh>_join_output</vh></v>
<v t="zhanglei.20100830144432.1648"><vh>make_env</vh></v>
<v t="zhanglei.20100830144432.1649"><vh>_join</vh></v>
<v t="zhanglei.20100830144432.1650"><vh>_escape</vh></v>
</v>
<v t="zhanglei.20100830144432.1651"><vh>class Template</vh>
<v t="zhanglei.20100830144432.1652"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1653"><vh>normalize_text</vh></v>
<v t="zhanglei.20100830144432.1654"><vh>__call__</vh></v>
<v t="zhanglei.20100830144432.1655"><vh>generate_code</vh></v>
<v t="zhanglei.20100830144432.1656"><vh>compile_template</vh></v>
</v>
<v t="zhanglei.20100830144432.1657"><vh>class CompiledTemplate</vh>
<v t="zhanglei.20100830144432.1658"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1659"><vh>compile_template</vh></v>
<v t="zhanglei.20100830144432.1660"><vh>_compile</vh></v>
</v>
<v t="zhanglei.20100830144432.1661"><vh>class Render</vh>
<v t="zhanglei.20100830144432.1662"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1663"><vh>_lookup</vh></v>
<v t="zhanglei.20100830144432.1664"><vh>_load_template</vh></v>
<v t="zhanglei.20100830144432.1665"><vh>_findfile</vh></v>
<v t="zhanglei.20100830144432.1666"><vh>_template</vh></v>
<v t="zhanglei.20100830144432.1667"><vh>__getattr__</vh></v>
</v>
<v t="zhanglei.20100830144432.1668"><vh>class GAE_Render</vh>
<v t="zhanglei.20100830144432.1669"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1670"><vh>_load_template</vh></v>
</v>
<v t="zhanglei.20100830144432.1671"><vh>frender</vh></v>
<v t="zhanglei.20100830144432.1672"><vh>compile_templates</vh></v>
<v t="zhanglei.20100830144432.1673"><vh>class ParseError</vh></v>
<v t="zhanglei.20100830144432.1674"><vh>class SecurityError</vh></v>
<v t="zhanglei.20100830144432.1675"><vh>class SafeVisitor</vh>
<v t="zhanglei.20100830144432.1676"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1677"><vh>walk</vh></v>
<v t="zhanglei.20100830144432.1678"><vh>visit</vh></v>
<v t="zhanglei.20100830144432.1679"><vh>visitName</vh></v>
<v t="zhanglei.20100830144432.1680"><vh>visitGetattr</vh></v>
<v t="zhanglei.20100830144432.1681"><vh>assert_attr</vh></v>
<v t="zhanglei.20100830144432.1682"><vh>is_unallowed_attr</vh></v>
<v t="zhanglei.20100830144432.1683"><vh>get_node_lineno</vh></v>
<v t="zhanglei.20100830144432.1684"><vh>fail</vh></v>
</v>
<v t="zhanglei.20100830144432.1685"><vh>class TemplateResult</vh>
<v t="zhanglei.20100830144432.1686"><vh>__unicode__</vh></v>
<v t="zhanglei.20100830144432.1687"><vh>__str__</vh></v>
<v t="zhanglei.20100830144432.1688"><vh>__repr__</vh></v>
</v>
<v t="zhanglei.20100830144432.1689"><vh>test</vh></v>
</v>
<v t="zhanglei.20100830144432.1690" a="O"><vh>@file /home/zhanglei/web.py-0.33/web/test.py</vh>
<v t="zhanglei.20100830144432.1691"><vh>test declarations</vh></v>
<v t="zhanglei.20100830144432.1692"><vh>load_modules</vh></v>
<v t="zhanglei.20100830144432.1693"><vh>module_suite</vh></v>
<v t="zhanglei.20100830144432.1694"><vh>doctest_suite</vh></v>
<v t="zhanglei.20100830144432.1695"><vh>suite</vh></v>
<v t="zhanglei.20100830144432.1696"><vh>runTests</vh></v>
<v t="zhanglei.20100830144432.1697"><vh>main</vh>
<v t="zhanglei.20100830144432.1698"><vh>@file /home/zhanglei/web.py-0.33/web/utils.py</vh>
<v t="zhanglei.20100830144432.1699"><vh>utils declarations</vh></v>
<v t="zhanglei.20100830144432.1700"><vh>class Storage</vh>
<v t="zhanglei.20100830144432.1701"><vh>__getattr__</vh></v>
<v t="zhanglei.20100830144432.1702"><vh>__setattr__</vh></v>
<v t="zhanglei.20100830144432.1703"><vh>__delattr__</vh></v>
<v t="zhanglei.20100830144432.1704"><vh>__repr__</vh></v>
</v>
<v t="zhanglei.20100830144432.1705"><vh>storify</vh></v>
<v t="zhanglei.20100830144432.1706"><vh>class _hack</vh></v>
<v t="zhanglei.20100830144432.1707"><vh>_strips</vh></v>
<v t="zhanglei.20100830144432.1708"><vh>rstrips</vh></v>
<v t="zhanglei.20100830144432.1709"><vh>lstrips</vh></v>
<v t="zhanglei.20100830144432.1710"><vh>strips</vh></v>
<v t="zhanglei.20100830144432.1711"><vh>safeunicode</vh></v>
<v t="zhanglei.20100830144432.1712"><vh>safestr</vh></v>
<v t="zhanglei.20100830144432.1713"><vh>class TimeoutError</vh></v>
<v t="zhanglei.20100830144432.1714"><vh>timelimit</vh></v>
<v t="zhanglei.20100830144432.1715"><vh>class Memoize</vh>
<v t="zhanglei.20100830144432.1716"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1717"><vh>__call__</vh></v>
</v>
<v t="zhanglei.20100830144432.1718"><vh>class _re_subm_proxy</vh>
<v t="zhanglei.20100830144432.1719"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1720"><vh>__call__</vh></v>
</v>
<v t="zhanglei.20100830144432.1721"><vh>re_subm</vh></v>
<v t="zhanglei.20100830144432.1722"><vh>group</vh></v>
<v t="zhanglei.20100830144432.1723"><vh>uniq</vh></v>
<v t="zhanglei.20100830144432.1724"><vh>iterview</vh></v>
<v t="zhanglei.20100830144432.1725"><vh>class IterBetter</vh>
<v t="zhanglei.20100830144432.1726"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1727"><vh>__iter__</vh></v>
<v t="zhanglei.20100830144432.1728"><vh>__getitem__</vh></v>
<v t="zhanglei.20100830144432.1729"><vh>__nonzero__</vh></v>
</v>
<v t="zhanglei.20100830144432.1730"><vh>dictreverse</vh></v>
<v t="zhanglei.20100830144432.1731"><vh>dictfind</vh></v>
<v t="zhanglei.20100830144432.1732"><vh>dictfindall</vh></v>
<v t="zhanglei.20100830144432.1733"><vh>dictincr</vh></v>
<v t="zhanglei.20100830144432.1734"><vh>dictadd</vh></v>
<v t="zhanglei.20100830144432.1735"><vh>listget</vh></v>
<v t="zhanglei.20100830144432.1736"><vh>intget</vh></v>
<v t="zhanglei.20100830144432.1737"><vh>datestr</vh></v>
<v t="zhanglei.20100830144432.1738"><vh>numify</vh></v>
<v t="zhanglei.20100830144432.1739"><vh>denumify</vh></v>
<v t="zhanglei.20100830144432.1740"><vh>commify</vh></v>
<v t="zhanglei.20100830144432.1741"><vh>dateify</vh></v>
<v t="zhanglei.20100830144432.1742"><vh>nthstr</vh></v>
<v t="zhanglei.20100830144432.1743"><vh>cond</vh></v>
<v t="zhanglei.20100830144432.1744"><vh>class CaptureStdout</vh>
<v t="zhanglei.20100830144432.1745"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1746"><vh>__call__</vh></v>
</v>
<v t="zhanglei.20100830144432.1747"><vh>class Profile</vh>
<v t="zhanglei.20100830144432.1748"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1749"><vh>__call__</vh></v>
</v>
<v t="zhanglei.20100830144432.1750"><vh>tryall</vh></v>
<v t="zhanglei.20100830144432.1751"><vh>class ThreadedDict</vh>
<v t="zhanglei.20100830144432.1752"><vh>__getattr__</vh></v>
<v t="zhanglei.20100830144432.1753"><vh>__setattr__</vh></v>
<v t="zhanglei.20100830144432.1754"><vh>__delattr__</vh></v>
<v t="zhanglei.20100830144432.1755"><vh>__hash__</vh></v>
<v t="zhanglei.20100830144432.1756"><vh>_getd</vh></v>
</v>
<v t="zhanglei.20100830144432.1757"><vh>autoassign</vh></v>
<v t="zhanglei.20100830144432.1758"><vh>to36</vh></v>
<v t="zhanglei.20100830144432.1759"><vh>safemarkdown</vh></v>
<v t="zhanglei.20100830144432.1760"><vh>sendmail</vh></v>
</v>
</v>
</v>
<v t="zhanglei.20100830144432.1761"><vh>@file /home/zhanglei/web.py-0.33/web/webapi.py</vh>
<v t="zhanglei.20100830144432.1762"><vh>webapi declarations</vh></v>
<v t="zhanglei.20100830144432.1763"><vh>class HTTPError</vh>
<v t="zhanglei.20100830144432.1764"><vh>__init__</vh></v>
</v>
<v t="zhanglei.20100830144432.1765"><vh>_status_code</vh></v>
<v t="zhanglei.20100830144432.1766"><vh>class Redirect</vh>
<v t="zhanglei.20100830144432.1767"><vh>__init__</vh></v>
</v>
<v t="zhanglei.20100830144432.1768"><vh>class Found</vh>
<v t="zhanglei.20100830144432.1769"><vh>__init__</vh></v>
</v>
<v t="zhanglei.20100830144432.1770"><vh>class SeeOther</vh>
<v t="zhanglei.20100830144432.1771"><vh>__init__</vh></v>
</v>
<v t="zhanglei.20100830144432.1772"><vh>class NotModified</vh>
<v t="zhanglei.20100830144432.1773"><vh>__init__</vh></v>
</v>
<v t="zhanglei.20100830144432.1774"><vh>class TempRedirect</vh>
<v t="zhanglei.20100830144432.1775"><vh>__init__</vh></v>
</v>
<v t="zhanglei.20100830144432.1776"><vh>class BadRequest</vh>
<v t="zhanglei.20100830144432.1777"><vh>__init__</vh></v>
</v>
<v t="zhanglei.20100830144432.1778"><vh>class _NotFound</vh>
<v t="zhanglei.20100830144432.1779"><vh>__init__</vh></v>
</v>
<v t="zhanglei.20100830144432.1780"><vh>NotFound</vh></v>
<v t="zhanglei.20100830144432.1781"><vh>class NoMethod</vh>
<v t="zhanglei.20100830144432.1782"><vh>__init__</vh></v>
</v>
<v t="zhanglei.20100830144432.1783"><vh>class Gone</vh>
<v t="zhanglei.20100830144432.1784"><vh>__init__</vh></v>
</v>
<v t="zhanglei.20100830144432.1785"><vh>class _InternalError</vh>
<v t="zhanglei.20100830144432.1786"><vh>__init__</vh></v>
</v>
<v t="zhanglei.20100830144432.1787"><vh>InternalError</vh></v>
<v t="zhanglei.20100830144432.1788"><vh>header</vh></v>
<v t="zhanglei.20100830144432.1789"><vh>rawinput</vh></v>
<v t="zhanglei.20100830144432.1790"><vh>input</vh></v>
<v t="zhanglei.20100830144432.1791"><vh>data</vh></v>
<v t="zhanglei.20100830144432.1792"><vh>setcookie</vh></v>
<v t="zhanglei.20100830144432.1793"><vh>cookies</vh></v>
<v t="zhanglei.20100830144432.1794"><vh>debug</vh></v>
<v t="zhanglei.20100830144432.1795"><vh>_debugwrite</vh></v>
</v>
<v t="zhanglei.20100830144432.1796"><vh>@file /home/zhanglei/web.py-0.33/web/webopenid.py</vh>
<v t="zhanglei.20100830144432.1797"><vh>webopenid declarations</vh></v>
<v t="zhanglei.20100830144432.1798"><vh>_secret</vh></v>
<v t="zhanglei.20100830144432.1799"><vh>_hmac</vh></v>
<v t="zhanglei.20100830144432.1800"><vh>_random_session</vh></v>
<v t="zhanglei.20100830144432.1801"><vh>status</vh></v>
<v t="zhanglei.20100830144432.1802"><vh>form</vh></v>
<v t="zhanglei.20100830144432.1803"><vh>logout</vh></v>
<v t="zhanglei.20100830144432.1804"><vh>class host</vh>
<v t="zhanglei.20100830144432.1805"><vh>POST</vh></v>
<v t="zhanglei.20100830144432.1806"><vh>GET</vh></v>
</v>
</v>
<v t="zhanglei.20100830144432.1807"><vh>@file /home/zhanglei/web.py-0.33/web/wsgi.py</vh>
<v t="zhanglei.20100830144432.1808"><vh>wsgi declarations</vh></v>
<v t="zhanglei.20100830144432.1809"><vh>runfcgi</vh></v>
<v t="zhanglei.20100830144432.1810"><vh>runscgi</vh></v>
<v t="zhanglei.20100830144432.1811"><vh>runwsgi</vh></v>
<v t="zhanglei.20100830144432.1812"><vh>_is_dev_mode</vh></v>
</v>
</v>
<v t="zhanglei.20100830144432.1814" a="E"><vh>wsgi</vh>
<v t="zhanglei.20100830144432.1815"><vh>@file /home/zhanglei/web.py-0.33/web/wsgiserver/__init__.py</vh>
<v t="zhanglei.20100830144432.1816"><vh>__init__ declarations</vh>
<v t="zhanglei.20100830144432.1832"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1833"><vh>parse_request</vh></v>
<v t="zhanglei.20100830144432.1834"><vh>_parse_request</vh></v>
<v t="zhanglei.20100830144432.1835"><vh>read_headers</vh></v>
<v t="zhanglei.20100830144432.1836"><vh>decode_chunked</vh></v>
<v t="zhanglei.20100830144432.1837"><vh>respond</vh></v>
<v t="zhanglei.20100830144432.1838"><vh>_respond</vh></v>
<v t="zhanglei.20100830144432.1839"><vh>simple_response</vh></v>
<v t="zhanglei.20100830144432.1840"><vh>start_response</vh></v>
<v t="zhanglei.20100830144432.1841"><vh>write</vh></v>
<v t="zhanglei.20100830144432.1842"><vh>send_headers</vh></v>
</v>
<v t="zhanglei.20100830144432.1843"><vh>class NoSSLError</vh></v>
<v t="zhanglei.20100830144432.1844"><vh>class FatalSSLAlert</vh></v>
<v t="zhanglei.20100830144432.1845"><vh>class SSL_fileobject</vh>
<v t="zhanglei.20100830144432.1846"><vh>_safe_call</vh></v>
<v t="zhanglei.20100830144432.1847"><vh>recv</vh></v>
<v t="zhanglei.20100830144432.1848"><vh>sendall</vh></v>
<v t="zhanglei.20100830144432.1849"><vh>send</vh></v>
</v>
<v t="zhanglei.20100830144432.1850"><vh>class HTTPConnection</vh>
<v t="zhanglei.20100830144432.1851"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1852"><vh>communicate</vh></v>
<v t="zhanglei.20100830144432.1853"><vh>close</vh></v>
</v>
<v t="zhanglei.20100830144432.1854"><vh>format_exc</vh></v>
<v t="zhanglei.20100830144432.1855"><vh>class WorkerThread</vh>
<v t="zhanglei.20100830144432.1856"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1857"><vh>run</vh></v>
</v>
<v t="zhanglei.20100830144432.1858"><vh>class ThreadPool</vh>
<v t="zhanglei.20100830144432.1859"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1860"><vh>start</vh></v>
<v t="zhanglei.20100830144432.1861"><vh>_get_idle</vh></v>
<v t="zhanglei.20100830144432.1862"><vh>put</vh></v>
<v t="zhanglei.20100830144432.1863"><vh>grow</vh></v>
<v t="zhanglei.20100830144432.1864"><vh>shrink</vh></v>
<v t="zhanglei.20100830144432.1865"><vh>stop</vh></v>
</v>
<v t="zhanglei.20100830144432.1866"><vh>class SSLConnection</vh>
<v t="zhanglei.20100830144432.1867"><vh>__init__</vh></v>
</v>
<v t="zhanglei.20100830144432.1868"><vh>class CherryPyWSGIServer</vh>
<v t="zhanglei.20100830144432.1869"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1870"><vh>_get_numthreads</vh></v>
<v t="zhanglei.20100830144432.1871"><vh>_set_numthreads</vh></v>
<v t="zhanglei.20100830144432.1872"><vh>__str__</vh></v>
<v t="zhanglei.20100830144432.1873"><vh>_get_bind_addr</vh></v>
<v t="zhanglei.20100830144432.1874"><vh>_set_bind_addr</vh></v>
<v t="zhanglei.20100830144432.1875"><vh>start</vh></v>
<v t="zhanglei.20100830144432.1876"><vh>bind</vh></v>
<v t="zhanglei.20100830144432.1877"><vh>tick</vh></v>
<v t="zhanglei.20100830144432.1878"><vh>_get_interrupt</vh></v>
<v t="zhanglei.20100830144432.1879"><vh>_set_interrupt</vh></v>
<v t="zhanglei.20100830144432.1880"><vh>stop</vh></v>
<v t="zhanglei.20100830144432.1881"><vh>populate_ssl_environ</vh></v>
</v>
</v>
</v>
<v t="zhanglei.20100830144432.1882" a="E"><vh>contribu</vh>
<v t="zhanglei.20100830144432.1883"><vh>@file /home/zhanglei/web.py-0.33/web/contrib/template.py</vh>
<v t="zhanglei.20100830144432.1884"><vh>template declarations</vh></v>
<v t="zhanglei.20100830144432.1885"><vh>class render_cheetah</vh>
<v t="zhanglei.20100830144432.1886"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1887"><vh>__getattr__</vh></v>
</v>
<v t="zhanglei.20100830144432.1888"><vh>class render_genshi</vh>
<v t="zhanglei.20100830144432.1889"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1890"><vh>__getattr__</vh></v>
</v>
<v t="zhanglei.20100830144432.1891"><vh>class render_jinja</vh>
<v t="zhanglei.20100830144432.1892"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1893"><vh>__getattr__</vh></v>
</v>
<v t="zhanglei.20100830144432.1894"><vh>class render_mako</vh>
<v t="zhanglei.20100830144432.1895"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1896"><vh>__getattr__</vh></v>
</v>
<v t="zhanglei.20100830144432.1897"><vh>class cache</vh>
<v t="zhanglei.20100830144432.1898"><vh>__init__</vh></v>
<v t="zhanglei.20100830144432.1899"><vh>__getattr__</vh></v>
</v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="zhanglei.20100830103303.1243"></t>
<t tx="zhanglei.20100830144432.1243"></t>
<t tx="zhanglei.20100830144432.1244">@language python
@tabwidth -4
@others
@ignore
if __name__ == "__main__":
    import doctest
    doctest.testmod()
</t>
<t tx="zhanglei.20100830144432.1245">#!/usr/bin/python
"""
Web application
(from web.py)
"""
import webapi as web
import webapi, wsgi, utils
import debugerror
from utils import lstrips, safeunicode
import sys

import urllib
import traceback
import itertools
import os
import re
import types
from exceptions import SystemExit

try:
    import wsgiref.handlers
except ImportError:
    pass # don't break people with old Pythons

__all__ = [
    "application", "auto_application",
    "subdir_application", "subdomain_application", 
    "loadhook", "unloadhook",
    "autodelegate"
]

</t>
<t tx="zhanglei.20100830144432.1246">class application:
    """
    Application to delegate requests based on path.

        &gt;&gt;&gt; urls = ("/hello", "hello")
        &gt;&gt;&gt; app = application(urls, globals())
        &gt;&gt;&gt; class hello:
        ...     def GET(self): return "hello"
        &gt;&gt;&gt;
        &gt;&gt;&gt; app.request("/hello").data
        'hello'
    """
    @others
</t>
<t tx="zhanglei.20100830144432.1247">def __init__(self, mapping=(), fvars={}, autoreload=None):
    if autoreload is None:
        autoreload = web.config.get('debug', False)
    self.mapping = mapping
    self.fvars = fvars
    self.processors = []

    self.add_processor(loadhook(self._load))
    self.add_processor(unloadhook(self._unload))

    if autoreload:
        def main_module_name():
            mod = sys.modules['__main__']
            file = getattr(mod, '__file__', None) # make sure this works even from python interpreter
            return file and os.path.splitext(os.path.basename(file))[0]

        def modname(fvars):
            """find name of the module name from fvars."""
            file, name = fvars.get('__file__'), fvars.get('__name__')
            if file is None or name is None:
                return None

            if name == '__main__':
                # Since the __main__ module can't be reloaded, the module has 
                # to be imported using its file name.                    
                name = main_module_name()
            return name

        mapping_name = utils.dictfind(fvars, mapping)
        module_name = modname(fvars)

        def reload_mapping():
            """loadhook to reload mapping and fvars."""
            mod = __import__(module_name)
            mapping = getattr(mod, mapping_name, None)
            if mapping:
                self.fvars = mod.__dict__
                self.mapping = mapping

        self.add_processor(loadhook(Reloader()))
        if mapping_name and module_name:
            self.add_processor(loadhook(reload_mapping))

        # load __main__ module usings its filename, so that it can be reloaded.
        if main_module_name() and '__main__' in sys.argv:
            try:
                __import__(main_module_name())
            except ImportError:
                pass

</t>
<t tx="zhanglei.20100830144432.1248">def _load(self):
    web.ctx.app_stack.append(self)

</t>
<t tx="zhanglei.20100830144432.1249">def _unload(self):
    web.ctx.app_stack = web.ctx.app_stack[:-1]

    if web.ctx.app_stack:
        # this is a sub-application, revert ctx to earlier state.
        oldctx = web.ctx.get('_oldctx')
        if oldctx:
            web.ctx.home = oldctx.home
            web.ctx.homepath = oldctx.homepath
            web.ctx.path = oldctx.path
            web.ctx.fullpath = oldctx.fullpath

</t>
<t tx="zhanglei.20100830144432.1250">def _cleanup(self):
    #@@@
    # Since the CherryPy Webserver uses thread pool, the thread-local state is never cleared.
    # This interferes with the other requests. 
    # clearing the thread-local storage to avoid that.
    # see utils.ThreadedDict for details
    import threading
    t = threading.currentThread()
    if hasattr(t, '_d'):
        del t._d

</t>
<t tx="zhanglei.20100830144432.1251">def add_mapping(self, pattern, classname):
    self.mapping += (pattern, classname)

</t>
<t tx="zhanglei.20100830144432.1252">def add_processor(self, processor):
    """
    Adds a processor to the application. 

        &gt;&gt;&gt; urls = ("/(.*)", "echo")
        &gt;&gt;&gt; app = application(urls, globals())
        &gt;&gt;&gt; class echo:
        ...     def GET(self, name): return name
        ...
        &gt;&gt;&gt;
        &gt;&gt;&gt; def hello(handler): return "hello, " +  handler()
        ...
        &gt;&gt;&gt; app.add_processor(hello)
        &gt;&gt;&gt; app.request("/web.py").data
        'hello, web.py'
    """
    self.processors.append(processor)

</t>
<t tx="zhanglei.20100830144432.1253">def request(self, localpart='/', method='GET', data=None,
            host="0.0.0.0:8080", headers=None, https=False, **kw):
    """Makes request to this application for the specified path and method.
    Response will be a storage object with data, status and headers.

        &gt;&gt;&gt; urls = ("/hello", "hello")
        &gt;&gt;&gt; app = application(urls, globals())
        &gt;&gt;&gt; class hello:
        ...     def GET(self): 
        ...         web.header('Content-Type', 'text/plain')
        ...         return "hello"
        ...
        &gt;&gt;&gt; response = app.request("/hello")
        &gt;&gt;&gt; response.data
        'hello'
        &gt;&gt;&gt; response.status
        '200 OK'
        &gt;&gt;&gt; response.headers['Content-Type']
        'text/plain'

    To use https, use https=True.

        &gt;&gt;&gt; urls = ("/redirect", "redirect")
        &gt;&gt;&gt; app = application(urls, globals())
        &gt;&gt;&gt; class redirect:
        ...     def GET(self): raise web.seeother("/foo")
        ...
        &gt;&gt;&gt; response = app.request("/redirect")
        &gt;&gt;&gt; response.headers['Location']
        'http://0.0.0.0:8080/foo'
        &gt;&gt;&gt; response = app.request("/redirect", https=True)
        &gt;&gt;&gt; response.headers['Location']
        'https://0.0.0.0:8080/foo'

    The headers argument specifies HTTP headers as a mapping object
    such as a dict.

        &gt;&gt;&gt; urls = ('/ua', 'uaprinter')
        &gt;&gt;&gt; class uaprinter:
        ...     def GET(self):
        ...         return 'your user-agent is ' + web.ctx.env['HTTP_USER_AGENT']
        ... 
        &gt;&gt;&gt; app = application(urls, globals())
        &gt;&gt;&gt; app.request('/ua', headers = {
        ...      'User-Agent': 'a small jumping bean/1.0 (compatible)'
        ... }).data
        'your user-agent is a small jumping bean/1.0 (compatible)'

    """
    path, maybe_query = urllib.splitquery(localpart)
    query = maybe_query or ""

    if 'env' in kw:
        env = kw['env']
    else:
        env = {}
    env = dict(env, HTTP_HOST=host, REQUEST_METHOD=method, PATH_INFO=path, QUERY_STRING=query, HTTPS=str(https))
    headers = headers or {}

    for k, v in headers.items():
        env['HTTP_' + k.upper().replace('-', '_')] = v

    if 'HTTP_CONTENT_LENGTH' in env:
        env['CONTENT_LENGTH'] = env.pop('HTTP_CONTENT_LENGTH')

    if 'HTTP_CONTENT_TYPE' in env:
        env['CONTENT_TYPE'] = env.pop('HTTP_CONTENT_TYPE')

    if method in ["POST", "PUT"]:
        data = data or ''
        import StringIO
        if isinstance(data, dict):
            q = urllib.urlencode(data)
        else:
            q = data
        env['wsgi.input'] = StringIO.StringIO(q)
        if not env.get('CONTENT_TYPE', '').lower().startswith('multipart/') and 'CONTENT_LENGTH' not in env:
            env['CONTENT_LENGTH'] = len(q)
    response = web.storage()
    def start_response(status, headers):
        response.status = status
        response.headers = dict(headers)
        response.header_items = headers
    response.data = "".join(self.wsgifunc()(env, start_response))
    return response

</t>
<t tx="zhanglei.20100830144432.1254">def browser(self):
    import browser
    return browser.AppBrowser(self)

</t>
<t tx="zhanglei.20100830144432.1255">def handle(self):
    fn, args = self._match(self.mapping, web.ctx.path)
    return self._delegate(fn, self.fvars, args)

</t>
<t tx="zhanglei.20100830144432.1256">def handle_with_processors(self):
    def process(processors):
        try:
            if processors:
                p, processors = processors[0], processors[1:]
                return p(lambda: process(processors))
            else:
                return self.handle()
        except web.HTTPError:
            raise
        except (KeyboardInterrupt, SystemExit):
            raise
        except:
            print &gt;&gt; web.debug, traceback.format_exc()
            raise self.internalerror()

    # processors must be applied in the resvere order. (??)
    return process(self.processors)

</t>
<t tx="zhanglei.20100830144432.1257">def wsgifunc(self, *middleware):
    """Returns a WSGI-compatible function for this application."""
    def peep(iterator):
        """Peeps into an iterator by doing an iteration
        and returns an equivalent iterator.
        """
        # wsgi requires the headers first
        # so we need to do an iteration
        # and save the result for later
        try:
            firstchunk = iterator.next()
        except StopIteration:
            firstchunk = ''

        return itertools.chain([firstchunk], iterator)    

    def is_generator(x): return x and hasattr(x, 'next')

    def wsgi(env, start_resp):
        self.load(env)
        try:
            # allow uppercase methods only
            if web.ctx.method.upper() != web.ctx.method:
                raise web.nomethod()

            result = self.handle_with_processors()
            if is_generator(result):
                result = peep(result)
            else:
                result = [result]
        except web.HTTPError, e:
            result = [e.data]

        result = web.utf8(iter(result))

        status, headers = web.ctx.status, web.ctx.headers
        start_resp(status, headers)

        def cleanup():
            self._cleanup()
            yield '' # force this function to be a generator

        return itertools.chain(result, cleanup())

    for m in middleware: 
        wsgi = m(wsgi)

    return wsgi

</t>
<t tx="zhanglei.20100830144432.1258">def run(self, *middleware):
    """
    Starts handling requests. If called in a CGI or FastCGI context, it will follow
    that protocol. If called from the command line, it will start an HTTP
    server on the port named in the first command line argument, or, if there
    is no argument, on port 8080.

    `middleware` is a list of WSGI middleware which is applied to the resulting WSGI
    function.
    """
    return wsgi.runwsgi(self.wsgifunc(*middleware))

</t>
<t tx="zhanglei.20100830144432.1259">def cgirun(self, *middleware):
    """
    Return a CGI handler. This is mostly useful with Google App Engine.
    There you can just do:

        main = app.cgirun()
    """
    wsgiapp = self.wsgifunc(*middleware)

    try:
        from google.appengine.ext.webapp.util import run_wsgi_app
        return run_wsgi_app(wsgiapp)
    except ImportError:
        # we're not running from within Google App Engine
        return wsgiref.handlers.CGIHandler().run(wsgiapp)

</t>
<t tx="zhanglei.20100830144432.1260">def load(self, env):
    """Initializes ctx using env."""
    ctx = web.ctx
    ctx.clear()
    ctx.status = '200 OK'
    ctx.headers = []
    ctx.output = ''
    ctx.environ = ctx.env = env
    ctx.host = env.get('HTTP_HOST')

    if env.get('wsgi.url_scheme') in ['http', 'https']:
        ctx.protocol = env['wsgi.url_scheme']
    elif env.get('HTTPS', '').lower() in ['on', 'true', '1']:
        ctx.protocol = 'https'
    else:
        ctx.protocol = 'http'
    ctx.homedomain = ctx.protocol + '://' + env.get('HTTP_HOST', '[unknown]')
    ctx.homepath = os.environ.get('REAL_SCRIPT_NAME', env.get('SCRIPT_NAME', ''))
    ctx.home = ctx.homedomain + ctx.homepath
    #@@ home is changed when the request is handled to a sub-application.
    #@@ but the real home is required for doing absolute redirects.
    ctx.realhome = ctx.home
    ctx.ip = env.get('REMOTE_ADDR')
    ctx.method = env.get('REQUEST_METHOD')
    ctx.path = env.get('PATH_INFO')
    # http://trac.lighttpd.net/trac/ticket/406 requires:
    if env.get('SERVER_SOFTWARE', '').startswith('lighttpd/'):
        ctx.path = lstrips(env.get('REQUEST_URI').split('?')[0], ctx.homepath)
        # Apache and CherryPy webservers unquote the url but lighttpd doesn't. 
        # unquote explicitly for lighttpd to make ctx.path uniform across all servers.
        ctx.path = urllib.unquote(ctx.path)

    if env.get('QUERY_STRING'):
        ctx.query = '?' + env.get('QUERY_STRING', '')
    else:
        ctx.query = ''

    ctx.fullpath = ctx.path + ctx.query

    for k, v in ctx.iteritems():
        if isinstance(v, str):
            ctx[k] = safeunicode(v)

    # status must always be str
    ctx.status = '200 OK'

    ctx.app_stack = []

</t>
<t tx="zhanglei.20100830144432.1261">def _delegate(self, f, fvars, args=[]):
    def handle_class(cls):
        meth = web.ctx.method
        if meth == 'HEAD' and not hasattr(cls, meth):
            meth = 'GET'
        if not hasattr(cls, meth):
            raise web.nomethod(cls)
        tocall = getattr(cls(), meth)
        return tocall(*args)

    def is_class(o): return isinstance(o, (types.ClassType, type))

    if f is None:
        raise web.notfound()
    elif isinstance(f, application):
        return f.handle_with_processors()
    elif is_class(f):
        return handle_class(f)
    elif isinstance(f, basestring):
        if f.startswith('redirect '):
            url = f.split(' ', 1)[1]
            if web.ctx.method == "GET":
                x = web.ctx.env.get('QUERY_STRING', '')
                if x:
                    url += '?' + x
            raise web.redirect(url)
        elif '.' in f:
            x = f.split('.')
            mod, cls = '.'.join(x[:-1]), x[-1]
            mod = __import__(mod, globals(), locals(), [""])
            cls = getattr(mod, cls)
        else:
            cls = fvars[f]
        return handle_class(cls)
    elif hasattr(f, '__call__'):
        return f()
    else:
        return web.notfound()

</t>
<t tx="zhanglei.20100830144432.1262">def _match(self, mapping, value):
    for pat, what in utils.group(mapping, 2):
        if isinstance(what, application):
            if value.startswith(pat):
                f = lambda: self._delegate_sub_application(pat, what)
                return f, None
            else:
                continue
        elif isinstance(what, basestring):
            what, result = utils.re_subm('^' + pat + '$', what, value)
        else:
            result = utils.re_compile('^' + pat + '$').match(value)

        if result: # it's a match
            return what, [x for x in result.groups()]
    return None, None

</t>
<t tx="zhanglei.20100830144432.1263">def _delegate_sub_application(self, dir, app):
    """Deletes request to sub application `app` rooted at the directory `dir`.
    The home, homepath, path and fullpath values in web.ctx are updated to mimic request
    to the subapp and are restored after it is handled. 

    @@Any issues with when used with yield?
    """
    web.ctx._oldctx = web.storage(web.ctx)
    web.ctx.home += dir
    web.ctx.homepath += dir
    web.ctx.path = web.ctx.path[len(dir):]
    web.ctx.fullpath = web.ctx.fullpath[len(dir):]
    return app.handle_with_processors()

</t>
<t tx="zhanglei.20100830144432.1264">def get_parent_app(self):
    if self in web.ctx.app_stack:
        index = web.ctx.app_stack.index(self)
        if index &gt; 0:
            return web.ctx.app_stack[index-1]

</t>
<t tx="zhanglei.20100830144432.1265">def notfound(self):
    """Returns HTTPError with '404 not found' message"""
    parent = self.get_parent_app()
    if parent:
        return parent.notfound()
    else:
        return web._NotFound()

</t>
<t tx="zhanglei.20100830144432.1266">def internalerror(self):
    """Returns HTTPError with '500 internal error' message"""
    parent = self.get_parent_app()
    if parent:
        return parent.internalerror()
    elif web.config.get('debug'):
        import debugerror
        return debugerror.debugerror()
    else:
        return web._InternalError()

</t>
<t tx="zhanglei.20100830144432.1267">class auto_application(application):
    """Application similar to `application` but urls are constructed 
    automatiacally using metaclass.

        &gt;&gt;&gt; app = auto_application()
        &gt;&gt;&gt; class hello(app.page):
        ...     def GET(self): return "hello, world"
        ...
        &gt;&gt;&gt; class foo(app.page):
        ...     path = '/foo/.*'
        ...     def GET(self): return "foo"
        &gt;&gt;&gt; app.request("/hello").data
        'hello, world'
        &gt;&gt;&gt; app.request('/foo/bar').data
        'foo'
    """
    @others
</t>
<t tx="zhanglei.20100830144432.1268">def __init__(self):
    application.__init__(self)

    class metapage(type):
        def __init__(klass, name, bases, attrs):
            type.__init__(klass, name, bases, attrs)
            path = attrs.get('path', '/' + name)

            # path can be specified as None to ignore that class
            # typically required to create a abstract base class.
            if path is not None:
                self.add_mapping(path, klass)

    class page:
        path = None
        __metaclass__ = metapage

    self.page = page

</t>
<t tx="zhanglei.20100830144432.1269"># The application class already has the required functionality of subdir_application
subdir_application = application

class subdomain_application(application):
    """
    Application to delegate requests based on the host.

        &gt;&gt;&gt; urls = ("/hello", "hello")
        &gt;&gt;&gt; app = application(urls, globals())
        &gt;&gt;&gt; class hello:
        ...     def GET(self): return "hello"
        &gt;&gt;&gt;
        &gt;&gt;&gt; mapping = (r"hello\.example\.com", app)
        &gt;&gt;&gt; app2 = subdomain_application(mapping)
        &gt;&gt;&gt; app2.request("/hello", host="hello.example.com").data
        'hello'
        &gt;&gt;&gt; response = app2.request("/hello", host="something.example.com")
        &gt;&gt;&gt; response.status
        '404 Not Found'
        &gt;&gt;&gt; response.data
        'not found'
    """
    @others
</t>
<t tx="zhanglei.20100830144432.1270">def handle(self):
    host = web.ctx.host.split(':')[0] #strip port
    fn, args = self._match(self.mapping, host)
    return self._delegate(fn, self.fvars, args)

</t>
<t tx="zhanglei.20100830144432.1271">def _match(self, mapping, value):
    for pat, what in utils.group(mapping, 2):
        if isinstance(what, basestring):
            what, result = utils.re_subm('^' + pat + '$', what, value)
        else:
            result = utils.re_compile('^' + pat + '$').match(value)

        if result: # it's a match
            return what, [x for x in result.groups()]
    return None, None

</t>
<t tx="zhanglei.20100830144432.1272">def loadhook(h):
    """
    Converts a load hook into an application processor.

        &gt;&gt;&gt; app = auto_application()
        &gt;&gt;&gt; def f(): "something done before handling request"
        ...
        &gt;&gt;&gt; app.add_processor(loadhook(f))
    """
    def processor(handler):
        h()
        return handler()

    return processor

</t>
<t tx="zhanglei.20100830144432.1273">def unloadhook(h):
    """
    Converts an unload hook into an application processor.

        &gt;&gt;&gt; app = auto_application()
        &gt;&gt;&gt; def f(): "something done after handling request"
        ...
        &gt;&gt;&gt; app.add_processor(unloadhook(f))    
    """
    def processor(handler):
        try:
            result = handler()
            is_generator = result and hasattr(result, 'next')
        except:
            # run the hook even when handler raises some exception
            h()
            raise

        if is_generator:
            return wrap(result)
        else:
            h()
            return result

    def wrap(result):
        def next():
            try:
                return result.next()
            except:
                # call the hook at the and of iterator
                h()
                raise

        result = iter(result)
        while True:
            yield next()

    return processor

</t>
<t tx="zhanglei.20100830144432.1274">def autodelegate(prefix=''):
    """
    Returns a method that takes one argument and calls the method named prefix+arg,
    calling `notfound()` if there isn't one. Example:

        urls = ('/prefs/(.*)', 'prefs')

        class prefs:
            GET = autodelegate('GET_')
            def GET_password(self): pass
            def GET_privacy(self): pass

    `GET_password` would get called for `/prefs/password` while `GET_privacy` for 
    `GET_privacy` gets called for `/prefs/privacy`.

    If a user visits `/prefs/password/change` then `GET_password(self, '/change')`
    is called.
    """
    def internal(self, arg):
        if '/' in arg:
            first, rest = arg.split('/', 1)
            func = prefix + first
            args = ['/' + rest]
        else:
            func = prefix + arg
            args = []

        if hasattr(self, func):
            try:
                return getattr(self, func)(*args)
            except TypeError:
                raise web.notfound()
        else:
            raise web.notfound()
    return internal

</t>
<t tx="zhanglei.20100830144432.1275">class Reloader:
    """Checks to see if any loaded modules have changed on disk and, 
    if so, reloads them.
    """
    @others
</t>
<t tx="zhanglei.20100830144432.1276">def __init__(self):
    self.mtimes = {}

</t>
<t tx="zhanglei.20100830144432.1277">def __call__(self):
    for mod in sys.modules.values():
        self.check(mod)

</t>
<t tx="zhanglei.20100830144432.1278">def check(self, mod):
    try: 
        mtime = os.stat(mod.__file__).st_mtime
    except (AttributeError, OSError, IOError):
        return
    if mod.__file__.endswith('.pyc') and os.path.exists(mod.__file__[:-1]):
        mtime = max(os.stat(mod.__file__[:-1]).st_mtime, mtime)

    if mod not in self.mtimes:
        self.mtimes[mod] = mtime
    elif self.mtimes[mod] &lt; mtime:
        try: 
            reload(mod)
            self.mtimes[mod] = mtime
        except ImportError: 
            pass

</t>
<t tx="zhanglei.20100830144432.1279">@language python
@tabwidth -4
@others
</t>
<t tx="zhanglei.20100830144432.1280">"""Browser to test web applications.
(from web.py)
"""
from utils import re_compile
from net import htmlunquote

import httplib, urllib, urllib2
import copy
from StringIO import StringIO

DEBUG = False

__all__ = [
    "BrowserError",
    "Browser", "AppBrowser",
    "AppHandler"
]

</t>
<t tx="zhanglei.20100830144432.1281">class BrowserError(Exception):
    pass

</t>
<t tx="zhanglei.20100830144432.1282">class Browser:
    @others
</t>
<t tx="zhanglei.20100830144432.1283">def __init__(self):
    import cookielib
    self.cookiejar = cookielib.CookieJar()
    self._cookie_processor = urllib2.HTTPCookieProcessor(self.cookiejar)
    self.form = None

    self.url = "http://0.0.0.0:8080/"
    self.path = "/"

    self.status = None
    self.data = None
    self._response = None
    self._forms = None

</t>
<t tx="zhanglei.20100830144432.1284">def reset(self):
    """Clears all cookies and history."""
    self.cookiejar.clear()

</t>
<t tx="zhanglei.20100830144432.1285">def build_opener(self):
    """Builds the opener using urllib2.build_opener. 
    Subclasses can override this function to prodive custom openers.
    """
    return urllib2.build_opener()

</t>
<t tx="zhanglei.20100830144432.1286">def do_request(self, req):
    if DEBUG:
        print 'requesting', req.get_method(), req.get_full_url()
    opener = self.build_opener()
    opener.add_handler(self._cookie_processor)
    try:
        self._response = opener.open(req)
    except urllib2.HTTPError, e:
        self._response = e

    self.url = self._response.geturl()
    self.path = urllib2.Request(self.url).get_selector()
    self.data = self._response.read()
    self.status = self._response.code
    self._forms = None
    self.form = None
    return self.get_response()

</t>
<t tx="zhanglei.20100830144432.1287">def open(self, url, data=None, headers={}):
    """Opens the specified url."""
    url = urllib.basejoin(self.url, url)
    req = urllib2.Request(url, data, headers)
    return self.do_request(req)

</t>
<t tx="zhanglei.20100830144432.1288">def show(self):
    """Opens the current page in real web browser."""
    f = open('page.html', 'w')
    f.write(self.data)
    f.close()

    import webbrowser, os
    url = 'file://' + os.path.abspath('page.html')
    webbrowser.open(url)

</t>
<t tx="zhanglei.20100830144432.1289">def get_response(self):
    """Returns a copy of the current response."""
    return urllib.addinfourl(StringIO(self.data), self._response.info(), self._response.geturl())

</t>
<t tx="zhanglei.20100830144432.1290">def get_soup(self):
    """Returns beautiful soup of the current document."""
    import BeautifulSoup
    return BeautifulSoup.BeautifulSoup(self.data)

</t>
<t tx="zhanglei.20100830144432.1291">def get_text(self, e=None):
    """Returns content of e or the current document as plain text."""
    e = e or self.get_soup()
    return ''.join([htmlunquote(c) for c in e.recursiveChildGenerator() if isinstance(c, unicode)])

</t>
<t tx="zhanglei.20100830144432.1292">def _get_links(self):
    soup = self.get_soup()
    return [a for a in soup.findAll(name='a')]

</t>
<t tx="zhanglei.20100830144432.1293">def get_links(self, text=None, text_regex=None, url=None, url_regex=None, predicate=None):
    """Returns all links in the document."""
    return self._filter_links(self._get_links(),
        text=text, text_regex=text_regex, url=url, url_regex=url_regex, predicate=predicate)

</t>
<t tx="zhanglei.20100830144432.1294">def follow_link(self, link=None, text=None, text_regex=None, url=None, url_regex=None, predicate=None):
    if link is None:
        links = self._filter_links(self.get_links(),
            text=text, text_regex=text_regex, url=url, url_regex=url_regex, predicate=predicate)
        link = links and links[0]

    if link:
        return self.open(link['href'])
    else:
        raise BrowserError("No link found")

</t>
<t tx="zhanglei.20100830144432.1295">def find_link(self, text=None, text_regex=None, url=None, url_regex=None, predicate=None):
    links = self._filter_links(self.get_links(), 
        text=text, text_regex=text_regex, url=url, url_regex=url_regex, predicate=predicate)
    return links and links[0] or None

</t>
<t tx="zhanglei.20100830144432.1296">def _filter_links(self, links, 
        text=None, text_regex=None,
        url=None, url_regex=None,
        predicate=None):
    predicates = []
    if text is not None:
        predicates.append(lambda link: link.string == text)
    if text_regex is not None:
        predicates.append(lambda link: re_compile(text_regex).search(link.string or ''))
    if url is not None:
        predicates.append(lambda link: link.get('href') == url)
    if url_regex is not None:
        predicates.append(lambda link: re_compile(url_regex).search(link.get('href', '')))
    if predicate:
        predicate.append(predicate)

    def f(link):
        for p in predicates:
            if not p(link):
                return False
        return True

    return [link for link in links if f(link)]

</t>
<t tx="zhanglei.20100830144432.1297">def get_forms(self):
    """Returns all forms in the current document.
    The returned form objects implement the ClientForm.HTMLForm interface.
    """
    if self._forms is None:
        import ClientForm
        self._forms = ClientForm.ParseResponse(self.get_response(), backwards_compat=False)
    return self._forms

</t>
<t tx="zhanglei.20100830144432.1298">def select_form(self, name=None, predicate=None, index=0):
    """Selects the specified form."""
    forms = self.get_forms()

    if name is not None:
        forms = [f for f in forms if f.name == name]
    if predicate:
        forms = [f for f in forms if predicate(f)]

    if forms:
        self.form = forms[index]
        return self.form
    else:
        raise BrowserError("No form selected.")

</t>
<t tx="zhanglei.20100830144432.1299">def submit(self, **kw):
    """submits the currently selected form."""
    if self.form is None:
        raise BrowserError("No form selected.")
    req = self.form.click(**kw)
    return self.do_request(req)

</t>
<t tx="zhanglei.20100830144432.1300">def __getitem__(self, key):
    return self.form[key]

</t>
<t tx="zhanglei.20100830144432.1301">def __setitem__(self, key, value):
    self.form[key] = value

</t>
<t tx="zhanglei.20100830144432.1302">class AppBrowser(Browser):
    """Browser interface to test web.py apps.

        b = AppBrowser(app)
        b.open('/')
        b.follow_link(text='Login')

        b.select_form(name='login')
        b['username'] = 'joe'
        b['password'] = 'secret'
        b.submit()

        assert b.path == '/'
        assert 'Welcome joe' in b.get_text()
    """
    @others
</t>
<t tx="zhanglei.20100830144432.1303">def __init__(self, app):
    Browser.__init__(self)
    self.app = app

</t>
<t tx="zhanglei.20100830144432.1304">def build_opener(self):
    return urllib2.build_opener(AppHandler(self.app))

</t>
<t tx="zhanglei.20100830144432.1305">class AppHandler(urllib2.HTTPHandler):
    """urllib2 handler to handle requests using web.py application."""
    handler_order = 100

    @others
</t>
<t tx="zhanglei.20100830144432.1306">def __init__(self, app):
    self.app = app

</t>
<t tx="zhanglei.20100830144432.1307">def http_open(self, req):
    result = self.app.request(
        localpart=req.get_selector(),
        method=req.get_method(),
        host=req.get_host(),
        data=req.get_data(),
        headers=dict(req.header_items()),
        https=req.get_type() == "https"
    )
    return self._make_response(result, req.get_full_url())

</t>
<t tx="zhanglei.20100830144432.1308">def https_open(self, req):
    return self.http_open(req)

</t>
<t tx="zhanglei.20100830144432.1309">try:
    https_request = urllib2.HTTPHandler.do_request_
except AttributeError:
    # for python 2.3
    pass

def _make_response(self, result, url):
    data = "\r\n".join(["%s: %s" % (k, v) for k, v in result.header_items])
    headers = httplib.HTTPMessage(StringIO(data))
    response = urllib.addinfourl(StringIO(result.data), headers, url)
    code, msg = result.status.split(None, 1)
    response.code, response.msg = int(code), msg
    return response
</t>
<t tx="zhanglei.20100830144432.1310">@language python
@tabwidth -4
@ignore
@others
if __name__ == "__main__":
    import doctest
    doctest.testmod()
</t>
<t tx="zhanglei.20100830144432.1311">"""
Database API
(part of web.py)
"""

__all__ = [
  "UnknownParamstyle", "UnknownDB", "TransactionError", 
  "sqllist", "sqlors", "reparam", "sqlquote",
  "SQLQuery", "SQLParam", "sqlparam",
  "SQLLiteral", "sqlliteral",
  "database", 'DB',
]

import time
try:
    import datetime
except ImportError:
    datetime = None

try: set
except NameError:
    from sets import Set as set

from utils import threadeddict, storage, iters, iterbetter, safestr, safeunicode

try:
    # db module can work independent of web.py
    from webapi import debug, config
except:
    import sys
    debug = sys.stderr
    config = storage()

</t>
<t tx="zhanglei.20100830144432.1312">class UnknownDB(Exception):
    """raised for unsupported dbms"""
    pass

</t>
<t tx="zhanglei.20100830144432.1313">class _ItplError(ValueError): 
    @others
</t>
<t tx="zhanglei.20100830144432.1314">def __init__(self, text, pos):
    ValueError.__init__(self)
    self.text = text
    self.pos = pos
</t>
<t tx="zhanglei.20100830144432.1315">def __str__(self):
    return "unfinished expression in %s at char %d" % (
        repr(self.text), self.pos)

</t>
<t tx="zhanglei.20100830144432.1316">class TransactionError(Exception): pass

</t>
<t tx="zhanglei.20100830144432.1317">class UnknownParamstyle(Exception): 
    """
    raised for unsupported db paramstyles

    (currently supported: qmark, numeric, format, pyformat)
    """
    pass

</t>
<t tx="zhanglei.20100830144432.1318">class SQLParam:
    """
    Parameter in SQLQuery.

        &gt;&gt;&gt; q = SQLQuery(["SELECT * FROM test WHERE name=", SQLParam("joe")])
        &gt;&gt;&gt; q
        &lt;sql: "SELECT * FROM test WHERE name='joe'"&gt;
        &gt;&gt;&gt; q.query()
        'SELECT * FROM test WHERE name=%s'
        &gt;&gt;&gt; q.values()
        ['joe']
    """
    @others
</t>
<t tx="zhanglei.20100830144432.1319">def __init__(self, value):
    self.value = value

</t>
<t tx="zhanglei.20100830144432.1320">def get_marker(self, paramstyle='pyformat'):
    if paramstyle == 'qmark':
        return '?'
    elif paramstyle == 'numeric':
        return ':1'
    elif paramstyle is None or paramstyle in ['format', 'pyformat']:
        return '%s'
    raise UnknownParamstyle, paramstyle

</t>
<t tx="zhanglei.20100830144432.1321">def sqlquery(self): 
    return SQLQuery([self])

</t>
<t tx="zhanglei.20100830144432.1322">def __add__(self, other):
    return self.sqlquery() + other

</t>
<t tx="zhanglei.20100830144432.1323">def __radd__(self, other):
    return other + self.sqlquery() 

</t>
<t tx="zhanglei.20100830144432.1324">def __str__(self): 
    return str(self.value)

</t>
<t tx="zhanglei.20100830144432.1325">def __repr__(self):
    return '&lt;param: %s&gt;' % repr(self.value)

</t>
<t tx="zhanglei.20100830144432.1326">sqlparam =  SQLParam

class SQLQuery:
    """
    You can pass this sort of thing as a clause in any db function.
    Otherwise, you can pass a dictionary to the keyword argument `vars`
    and the function will call reparam for you.

    Internally, consists of `items`, which is a list of strings and
    SQLParams, which get concatenated to produce the actual query.
    """
    @others
</t>
<t tx="zhanglei.20100830144432.1327"># tested in sqlquote's docstring
def __init__(self, items=[]):
    r"""Creates a new SQLQuery.

        &gt;&gt;&gt; SQLQuery("x")
        &lt;sql: 'x'&gt;
        &gt;&gt;&gt; q = SQLQuery(['SELECT * FROM ', 'test', ' WHERE x=', SQLParam(1)])
        &gt;&gt;&gt; q
        &lt;sql: 'SELECT * FROM test WHERE x=1'&gt;
        &gt;&gt;&gt; q.query(), q.values()
        ('SELECT * FROM test WHERE x=%s', [1])
        &gt;&gt;&gt; SQLQuery(SQLParam(1))
        &lt;sql: '1'&gt;
    """
    if isinstance(items, list):
        self.items = items
    elif isinstance(items, SQLParam):
        self.items = [items]
    elif isinstance(items, SQLQuery):
        self.items = list(items.items)
    else:
        self.items = [items]

    # Take care of SQLLiterals
    for i, item in enumerate(self.items):
        if isinstance(item, SQLParam) and isinstance(item.value, SQLLiteral):
            self.items[i] = item.value.v

</t>
<t tx="zhanglei.20100830144432.1328">def __add__(self, other):
    if isinstance(other, basestring):
        items = [other]
    elif isinstance(other, SQLQuery):
        items = other.items
    else:
        return NotImplemented
    return SQLQuery(self.items + items)

</t>
<t tx="zhanglei.20100830144432.1329">def __radd__(self, other):
    if isinstance(other, basestring):
        items = [other]
    else:
        return NotImplemented

    return SQLQuery(items + self.items)

</t>
<t tx="zhanglei.20100830144432.1330">def __iadd__(self, other):
    if isinstance(other, basestring):
        items = [other]
    elif isinstance(other, SQLQuery):
        items = other.items
    else:
        return NotImplemented
    self.items.extend(items)
    return self

</t>
<t tx="zhanglei.20100830144432.1331">def __len__(self):
    return len(self.query())

</t>
<t tx="zhanglei.20100830144432.1332">def query(self, paramstyle=None):
    """
    Returns the query part of the sql query.
        &gt;&gt;&gt; q = SQLQuery(["SELECT * FROM test WHERE name=", SQLParam('joe')])
        &gt;&gt;&gt; q.query()
        'SELECT * FROM test WHERE name=%s'
        &gt;&gt;&gt; q.query(paramstyle='qmark')
        'SELECT * FROM test WHERE name=?'
    """
    s = ''
    for x in self.items:
        if isinstance(x, SQLParam):
            x = x.get_marker(paramstyle)
        s += safestr(x)
    return s

</t>
<t tx="zhanglei.20100830144432.1333">def values(self):
    """
    Returns the values of the parameters used in the sql query.
        &gt;&gt;&gt; q = SQLQuery(["SELECT * FROM test WHERE name=", SQLParam('joe')])
        &gt;&gt;&gt; q.values()
        ['joe']
    """
    return [i.value for i in self.items if isinstance(i, SQLParam)]

</t>
<t tx="zhanglei.20100830144432.1334">def join(items, sep=' '):
    """
    Joins multiple queries.

    &gt;&gt;&gt; SQLQuery.join(['a', 'b'], ', ')
    &lt;sql: 'a, b'&gt;
    """
    if len(items) == 0:
        return SQLQuery("")

    q = SQLQuery(items[0])
    for item in items[1:]:
        q += sep
        q += item
    return q

</t>
<t tx="zhanglei.20100830144432.1335">join = staticmethod(join)

def _str(self):
    try:
        return self.query() % tuple([sqlify(x) for x in self.values()])            
    except (ValueError, TypeError):
        return self.query()

</t>
<t tx="zhanglei.20100830144432.1336">def __str__(self):
    return safestr(self._str())

</t>
<t tx="zhanglei.20100830144432.1337">def __unicode__(self):
    return safeunicode(self._str())

</t>
<t tx="zhanglei.20100830144432.1338">def __repr__(self):
    return '&lt;sql: %s&gt;' % repr(str(self))

</t>
<t tx="zhanglei.20100830144432.1339">class SQLLiteral: 
    """
    Protects a string from `sqlquote`.

        &gt;&gt;&gt; sqlquote('NOW()')
        &lt;sql: "'NOW()'"&gt;
        &gt;&gt;&gt; sqlquote(SQLLiteral('NOW()'))
        &lt;sql: 'NOW()'&gt;
    """
    @others
</t>
<t tx="zhanglei.20100830144432.1340">def __init__(self, v): 
    self.v = v

</t>
<t tx="zhanglei.20100830144432.1341">def __repr__(self): 
    return self.v

</t>
<t tx="zhanglei.20100830144432.1342">sqlliteral = SQLLiteral

def _sqllist(values):
    """
        &gt;&gt;&gt; _sqllist([1, 2, 3])
        &lt;sql: '(1, 2, 3)'&gt;
    """
    items = []
    items.append('(')
    for i, v in enumerate(values):
        if i != 0:
            items.append(', ')
        items.append(sqlparam(v))
    items.append(')')
    return SQLQuery(items)

</t>
<t tx="zhanglei.20100830144432.1343">def reparam(string_, dictionary): 
    """
    Takes a string and a dictionary and interpolates the string
    using values from the dictionary. Returns an `SQLQuery` for the result.

        &gt;&gt;&gt; reparam("s = $s", dict(s=True))
        &lt;sql: "s = 't'"&gt;
        &gt;&gt;&gt; reparam("s IN $s", dict(s=[1, 2]))
        &lt;sql: 's IN (1, 2)'&gt;
    """
    dictionary = dictionary.copy() # eval mucks with it
    vals = []
    result = []
    for live, chunk in _interpolate(string_):
        if live:
            v = eval(chunk, dictionary)
            result.append(sqlquote(v))
        else: 
            result.append(chunk)
    return SQLQuery.join(result, '')

</t>
<t tx="zhanglei.20100830144432.1344">def sqlify(obj): 
    """
    converts `obj` to its proper SQL version

        &gt;&gt;&gt; sqlify(None)
        'NULL'
        &gt;&gt;&gt; sqlify(True)
        "'t'"
        &gt;&gt;&gt; sqlify(3)
        '3'
    """
    # because `1 == True and hash(1) == hash(True)`
    # we have to do this the hard way...

    if obj is None:
        return 'NULL'
    elif obj is True:
        return "'t'"
    elif obj is False:
        return "'f'"
    elif datetime and isinstance(obj, datetime.datetime):
        return repr(obj.isoformat())
    else:
        if isinstance(obj, unicode): obj = obj.encode('utf8')
        return repr(obj)

</t>
<t tx="zhanglei.20100830144432.1345">def sqllist(lst): 
    """
    Converts the arguments for use in something like a WHERE clause.

        &gt;&gt;&gt; sqllist(['a', 'b'])
        'a, b'
        &gt;&gt;&gt; sqllist('a')
        'a'
        &gt;&gt;&gt; sqllist(u'abc')
        u'abc'
    """
    if isinstance(lst, basestring): 
        return lst
    else:
        return ', '.join(lst)

</t>
<t tx="zhanglei.20100830144432.1346">def sqlors(left, lst):
    """
    `left is a SQL clause like `tablename.arg = ` 
    and `lst` is a list of values. Returns a reparam-style
    pair featuring the SQL that ORs together the clause
    for each item in the lst.

        &gt;&gt;&gt; sqlors('foo = ', [])
        &lt;sql: '1=2'&gt;
        &gt;&gt;&gt; sqlors('foo = ', [1])
        &lt;sql: 'foo = 1'&gt;
        &gt;&gt;&gt; sqlors('foo = ', 1)
        &lt;sql: 'foo = 1'&gt;
        &gt;&gt;&gt; sqlors('foo = ', [1,2,3])
        &lt;sql: '(foo = 1 OR foo = 2 OR foo = 3 OR 1=2)'&gt;
    """
    if isinstance(lst, iters):
        lst = list(lst)
        ln = len(lst)
        if ln == 0:
            return SQLQuery("1=2")
        if ln == 1:
            lst = lst[0]

    if isinstance(lst, iters):
        return SQLQuery(['('] + 
          sum([[left, sqlparam(x), ' OR '] for x in lst], []) +
          ['1=2)']
        )
    else:
        return left + sqlparam(lst)

</t>
<t tx="zhanglei.20100830144432.1347">def sqlwhere(dictionary, grouping=' AND '): 
    """
    Converts a `dictionary` to an SQL WHERE clause `SQLQuery`.

        &gt;&gt;&gt; sqlwhere({'cust_id': 2, 'order_id':3})
        &lt;sql: 'order_id = 3 AND cust_id = 2'&gt;
        &gt;&gt;&gt; sqlwhere({'cust_id': 2, 'order_id':3}, grouping=', ')
        &lt;sql: 'order_id = 3, cust_id = 2'&gt;
        &gt;&gt;&gt; sqlwhere({'a': 'a', 'b': 'b'}).query()
        'a = %s AND b = %s'
    """
    return SQLQuery.join([k + ' = ' + sqlparam(v) for k, v in dictionary.items()], grouping)

</t>
<t tx="zhanglei.20100830144432.1348">def sqlquote(a): 
    """
    Ensures `a` is quoted properly for use in a SQL query.

        &gt;&gt;&gt; 'WHERE x = ' + sqlquote(True) + ' AND y = ' + sqlquote(3)
        &lt;sql: "WHERE x = 't' AND y = 3"&gt;
        &gt;&gt;&gt; 'WHERE x = ' + sqlquote(True) + ' AND y IN ' + sqlquote([2, 3])
        &lt;sql: "WHERE x = 't' AND y IN (2, 3)"&gt;
    """
    if isinstance(a, list):
        return _sqllist(a)
    else:
        return sqlparam(a).sqlquery()

</t>
<t tx="zhanglei.20100830144432.1349">class Transaction:
    """Database transaction."""
    @others
</t>
<t tx="zhanglei.20100830144432.1350">def __init__(self, ctx):
    self.ctx = ctx
    self.transaction_count = transaction_count = len(ctx.transactions)

    class transaction_engine:
        """Transaction Engine used in top level transactions."""
        def do_transact(self):
            ctx.commit(unload=False)

        def do_commit(self):
            ctx.commit()

        def do_rollback(self):
            ctx.rollback()

    class subtransaction_engine:
        """Transaction Engine used in sub transactions."""
        def query(self, q):
            db_cursor = ctx.db.cursor()
            ctx.db_execute(db_cursor, SQLQuery(q % transaction_count))

        def do_transact(self):
            self.query('SAVEPOINT webpy_sp_%s')

        def do_commit(self):
            self.query('RELEASE SAVEPOINT webpy_sp_%s')

        def do_rollback(self):
            self.query('ROLLBACK TO SAVEPOINT webpy_sp_%s')

    class dummy_engine:
        """Transaction Engine used instead of subtransaction_engine 
        when sub transactions are not supported."""
        do_transact = do_commit = do_rollback = lambda self: None

    if self.transaction_count:
        # nested transactions are not supported in some databases
        if self.ctx.get('ignore_nested_transactions'):
            self.engine = dummy_engine()
        else:
            self.engine = subtransaction_engine()
    else:
        self.engine = transaction_engine()

    self.engine.do_transact()
    self.ctx.transactions.append(self)

</t>
<t tx="zhanglei.20100830144432.1351">def __enter__(self):
    return self

</t>
<t tx="zhanglei.20100830144432.1352">def __exit__(self, exctype, excvalue, traceback):
    if exctype is not None:
        self.rollback()
    else:
        self.commit()

</t>
<t tx="zhanglei.20100830144432.1353">def commit(self):
    if len(self.ctx.transactions) &gt; self.transaction_count:
        self.engine.do_commit()
        self.ctx.transactions = self.ctx.transactions[:self.transaction_count]

</t>
<t tx="zhanglei.20100830144432.1354">def rollback(self):
    if len(self.ctx.transactions) &gt; self.transaction_count:
        self.engine.do_rollback()
        self.ctx.transactions = self.ctx.transactions[:self.transaction_count]

</t>
<t tx="zhanglei.20100830144432.1355">class DB: 
    """Database"""
    @others
</t>
<t tx="zhanglei.20100830144432.1356">def __init__(self, db_module, keywords):
    """Creates a database.
    """
    # some DB implementaions take optional paramater `driver` to use a specific driver modue
    # but it should not be passed to connect
    keywords.pop('driver', None)

    self.db_module = db_module
    self.keywords = keywords


    self._ctx = threadeddict()
    # flag to enable/disable printing queries
    self.printing = config.get('debug', False)
    self.supports_multiple_insert = False

    try:
        import DBUtils
        # enable pooling if DBUtils module is available.
        self.has_pooling = True
    except ImportError:
        self.has_pooling = False

    # Pooling can be disabled by passing pooling=False in the keywords.
    self.has_pooling = self.keywords.pop('pooling', True) and self.has_pooling

</t>
<t tx="zhanglei.20100830144432.1357">def _getctx(self): 
    if not self._ctx.get('db'):
        self._load_context(self._ctx)
    return self._ctx
</t>
<t tx="zhanglei.20100830144432.1358">ctx = property(_getctx)

def _load_context(self, ctx):
    ctx.dbq_count = 0
    ctx.transactions = [] # stack of transactions

    if self.has_pooling:
        ctx.db = self._connect_with_pooling(self.keywords)
    else:
        ctx.db = self._connect(self.keywords)
    ctx.db_execute = self._db_execute

    if not hasattr(ctx.db, 'commit'):
        ctx.db.commit = lambda: None

    if not hasattr(ctx.db, 'rollback'):
        ctx.db.rollback = lambda: None

    def commit(unload=True):
        # do db commit and release the connection if pooling is enabled.            
        ctx.db.commit()
        if unload and self.has_pooling:
            self._unload_context(self._ctx)

    def rollback():
        # do db rollback and release the connection if pooling is enabled.
        ctx.db.rollback()
        if self.has_pooling:
            self._unload_context(self._ctx)

    ctx.commit = commit
    ctx.rollback = rollback

</t>
<t tx="zhanglei.20100830144432.1359">def _unload_context(self, ctx):
    del ctx.db

</t>
<t tx="zhanglei.20100830144432.1360">def _connect(self, keywords):
    return self.db_module.connect(**keywords)

</t>
<t tx="zhanglei.20100830144432.1361">def _connect_with_pooling(self, keywords):
    def get_pooled_db():
        from DBUtils import PooledDB

        # In DBUtils 0.9.3, `dbapi` argument is renamed as `creator`
        # see Bug#122112

        if PooledDB.__version__.split('.') &lt; '0.9.3'.split('.'):
            return PooledDB.PooledDB(dbapi=self.db_module, **keywords)
        else:
            return PooledDB.PooledDB(creator=self.db_module, **keywords)

    if getattr(self, '_pooleddb', None) is None:
        self._pooleddb = get_pooled_db()

    return self._pooleddb.connection()

</t>
<t tx="zhanglei.20100830144432.1362">def _db_cursor(self):
    return self.ctx.db.cursor()

</t>
<t tx="zhanglei.20100830144432.1363">def _param_marker(self):
    """Returns parameter marker based on paramstyle attribute if this database."""
    style = getattr(self, 'paramstyle', 'pyformat')

    if style == 'qmark':
        return '?'
    elif style == 'numeric':
        return ':1'
    elif style in ['format', 'pyformat']:
        return '%s'
    raise UnknownParamstyle, style

</t>
<t tx="zhanglei.20100830144432.1364">def _db_execute(self, cur, sql_query): 
    """executes an sql query"""
    self.ctx.dbq_count += 1

    try:
        a = time.time()
        paramstyle = getattr(self, 'paramstyle', 'pyformat')
        out = cur.execute(sql_query.query(paramstyle), sql_query.values())
        b = time.time()
    except:
        if self.printing:
            print &gt;&gt; debug, 'ERR:', str(sql_query)
        if self.ctx.transactions:
            self.ctx.transactions[-1].rollback()
        else:
            self.ctx.rollback()
        raise

    if self.printing:
        print &gt;&gt; debug, '%s (%s): %s' % (round(b-a, 2), self.ctx.dbq_count, str(sql_query))
    return out

</t>
<t tx="zhanglei.20100830144432.1365">def _where(self, where, vars): 
    if isinstance(where, (int, long)):
        where = "id = " + sqlparam(where)
    #@@@ for backward-compatibility
    elif isinstance(where, (list, tuple)) and len(where) == 2:
        where = SQLQuery(where[0], where[1])
    elif isinstance(where, SQLQuery):
        pass
    else:
        where = reparam(where, vars)        
    return where

</t>
<t tx="zhanglei.20100830144432.1366">def query(self, sql_query, vars=None, processed=False, _test=False): 
    """
    Execute SQL query `sql_query` using dictionary `vars` to interpolate it.
    If `processed=True`, `vars` is a `reparam`-style list to use 
    instead of interpolating.

        &gt;&gt;&gt; db = DB(None, {})
        &gt;&gt;&gt; db.query("SELECT * FROM foo", _test=True)
        &lt;sql: 'SELECT * FROM foo'&gt;
        &gt;&gt;&gt; db.query("SELECT * FROM foo WHERE x = $x", vars=dict(x='f'), _test=True)
        &lt;sql: "SELECT * FROM foo WHERE x = 'f'"&gt;
        &gt;&gt;&gt; db.query("SELECT * FROM foo WHERE x = " + sqlquote('f'), _test=True)
        &lt;sql: "SELECT * FROM foo WHERE x = 'f'"&gt;
    """
    if vars is None: vars = {}

    if not processed and not isinstance(sql_query, SQLQuery):
        sql_query = reparam(sql_query, vars)

    if _test: return sql_query

    db_cursor = self._db_cursor()
    self._db_execute(db_cursor, sql_query)

    if db_cursor.description:
        names = [x[0] for x in db_cursor.description]
        def iterwrapper():
            row = db_cursor.fetchone()
            while row:
                yield storage(dict(zip(names, row)))
                row = db_cursor.fetchone()
        out = iterbetter(iterwrapper())
        out.__len__ = lambda: int(db_cursor.rowcount)
        out.list = lambda: [storage(dict(zip(names, x))) \
                           for x in db_cursor.fetchall()]
    else:
        out = db_cursor.rowcount

    if not self.ctx.transactions: 
        self.ctx.commit()
    return out

</t>
<t tx="zhanglei.20100830144432.1367">def select(self, tables, vars=None, what='*', where=None, order=None, group=None, 
           limit=None, offset=None, _test=False): 
    """
    Selects `what` from `tables` with clauses `where`, `order`, 
    `group`, `limit`, and `offset`. Uses vars to interpolate. 
    Otherwise, each clause can be a SQLQuery.

        &gt;&gt;&gt; db = DB(None, {})
        &gt;&gt;&gt; db.select('foo', _test=True)
        &lt;sql: 'SELECT * FROM foo'&gt;
        &gt;&gt;&gt; db.select(['foo', 'bar'], where="foo.bar_id = bar.id", limit=5, _test=True)
        &lt;sql: 'SELECT * FROM foo, bar WHERE foo.bar_id = bar.id LIMIT 5'&gt;
    """
    if vars is None: vars = {}
    sql_clauses = self.sql_clauses(what, tables, where, group, order, limit, offset)
    clauses = [self.gen_clause(sql, val, vars) for sql, val in sql_clauses if val is not None]
    qout = SQLQuery.join(clauses)
    if _test: return qout
    return self.query(qout, processed=True)

</t>
<t tx="zhanglei.20100830144432.1368">def where(self, table, what='*', order=None, group=None, limit=None, 
          offset=None, _test=False, **kwargs):
    """
    Selects from `table` where keys are equal to values in `kwargs`.

        &gt;&gt;&gt; db = DB(None, {})
        &gt;&gt;&gt; db.where('foo', bar_id=3, _test=True)
        &lt;sql: 'SELECT * FROM foo WHERE bar_id = 3'&gt;
        &gt;&gt;&gt; db.where('foo', source=2, crust='dewey', _test=True)
        &lt;sql: "SELECT * FROM foo WHERE source = 2 AND crust = 'dewey'"&gt;
    """
    where = []
    for k, v in kwargs.iteritems():
        where.append(k + ' = ' + sqlquote(v))
    return self.select(table, what=what, order=order, 
           group=group, limit=limit, offset=offset, _test=_test, 
           where=SQLQuery.join(where, ' AND '))

</t>
<t tx="zhanglei.20100830144432.1369">def sql_clauses(self, what, tables, where, group, order, limit, offset): 
    return (
        ('SELECT', what),
        ('FROM', sqllist(tables)),
        ('WHERE', where),
        ('GROUP BY', group),
        ('ORDER BY', order),
        ('LIMIT', limit),
        ('OFFSET', offset))

</t>
<t tx="zhanglei.20100830144432.1370">def gen_clause(self, sql, val, vars): 
    if isinstance(val, (int, long)):
        if sql == 'WHERE':
            nout = 'id = ' + sqlquote(val)
        else:
            nout = SQLQuery(val)
    #@@@
    elif isinstance(val, (list, tuple)) and len(val) == 2:
        nout = SQLQuery(val[0], val[1]) # backwards-compatibility
    elif isinstance(val, SQLQuery):
        nout = val
    else:
        nout = reparam(val, vars)

    def xjoin(a, b):
        if a and b: return a + ' ' + b
        else: return a or b

    return xjoin(sql, nout)

</t>
<t tx="zhanglei.20100830144432.1371">def insert(self, tablename, seqname=None, _test=False, **values): 
    """
    Inserts `values` into `tablename`. Returns current sequence ID.
    Set `seqname` to the ID if it's not the default, or to `False`
    if there isn't one.

        &gt;&gt;&gt; db = DB(None, {})
        &gt;&gt;&gt; q = db.insert('foo', name='bob', age=2, created=SQLLiteral('NOW()'), _test=True)
        &gt;&gt;&gt; q
        &lt;sql: "INSERT INTO foo (age, name, created) VALUES (2, 'bob', NOW())"&gt;
        &gt;&gt;&gt; q.query()
        'INSERT INTO foo (age, name, created) VALUES (%s, %s, NOW())'
        &gt;&gt;&gt; q.values()
        [2, 'bob']
    """
    def q(x): return "(" + x + ")"

    if values:
        _keys = SQLQuery.join(values.keys(), ', ')
        _values = SQLQuery.join([sqlparam(v) for v in values.values()], ', ')
        sql_query = "INSERT INTO %s " % tablename + q(_keys) + ' VALUES ' + q(_values)
    else:
        sql_query = SQLQuery("INSERT INTO %s DEFAULT VALUES" % tablename)

    if _test: return sql_query

    db_cursor = self._db_cursor()
    if seqname is not False: 
        sql_query = self._process_insert_query(sql_query, tablename, seqname)

    if isinstance(sql_query, tuple):
        # for some databases, a separate query has to be made to find 
        # the id of the inserted row.
        q1, q2 = sql_query
        self._db_execute(db_cursor, q1)
        self._db_execute(db_cursor, q2)
    else:
        self._db_execute(db_cursor, sql_query)

    try: 
        out = db_cursor.fetchone()[0]
    except Exception: 
        out = None

    if not self.ctx.transactions: 
        self.ctx.commit()
    return out

</t>
<t tx="zhanglei.20100830144432.1372">def multiple_insert(self, tablename, values, seqname=None, _test=False):
    """
    Inserts multiple rows into `tablename`. The `values` must be a list of dictioanries, 
    one for each row to be inserted, each with the same set of keys.
    Returns the list of ids of the inserted rows.        
    Set `seqname` to the ID if it's not the default, or to `False`
    if there isn't one.

        &gt;&gt;&gt; db = DB(None, {})
        &gt;&gt;&gt; db.supports_multiple_insert = True
        &gt;&gt;&gt; values = [{"name": "foo", "email": "foo@example.com"}, {"name": "bar", "email": "bar@example.com"}]
        &gt;&gt;&gt; db.multiple_insert('person', values=values, _test=True)
        &lt;sql: "INSERT INTO person (name, email) VALUES ('foo', 'foo@example.com'), ('bar', 'bar@example.com')"&gt;
    """        
    if not values:
        return []

    if not self.supports_multiple_insert:
        out = [self.insert(tablename, seqname=seqname, _test=_test, **v) for v in values]
        if seqname is False:
            return None
        else:
            return out

    keys = values[0].keys()
    #@@ make sure all keys are valid

    # make sure all rows have same keys.
    for v in values:
        if v.keys() != keys:
            raise ValueError, 'Bad data'

    sql_query = SQLQuery('INSERT INTO %s (%s) VALUES ' % (tablename, ', '.join(keys))) 

    data = []
    for row in values:
        d = SQLQuery.join([SQLParam(row[k]) for k in keys], ', ')
        data.append('(' + d + ')')
    sql_query += SQLQuery.join(data, ', ')

    if _test: return sql_query

    db_cursor = self._db_cursor()
    if seqname is not False: 
        sql_query = self._process_insert_query(sql_query, tablename, seqname)

    if isinstance(sql_query, tuple):
        # for some databases, a separate query has to be made to find 
        # the id of the inserted row.
        q1, q2 = sql_query
        self._db_execute(db_cursor, q1)
        self._db_execute(db_cursor, q2)
    else:
        self._db_execute(db_cursor, sql_query)

    try: 
        out = db_cursor.fetchone()[0]
        out = range(out-len(values)+1, out+1)        
    except Exception: 
        out = None

    if not self.ctx.transactions: 
        self.ctx.commit()
    return out


</t>
<t tx="zhanglei.20100830144432.1373">def update(self, tables, where, vars=None, _test=False, **values): 
    """
    Update `tables` with clause `where` (interpolated using `vars`)
    and setting `values`.

        &gt;&gt;&gt; db = DB(None, {})
        &gt;&gt;&gt; name = 'Joseph'
        &gt;&gt;&gt; q = db.update('foo', where='name = $name', name='bob', age=2,
        ...     created=SQLLiteral('NOW()'), vars=locals(), _test=True)
        &gt;&gt;&gt; q
        &lt;sql: "UPDATE foo SET age = 2, name = 'bob', created = NOW() WHERE name = 'Joseph'"&gt;
        &gt;&gt;&gt; q.query()
        'UPDATE foo SET age = %s, name = %s, created = NOW() WHERE name = %s'
        &gt;&gt;&gt; q.values()
        [2, 'bob', 'Joseph']
    """
    if vars is None: vars = {}
    where = self._where(where, vars)

    query = (
      "UPDATE " + sqllist(tables) + 
      " SET " + sqlwhere(values, ', ') + 
      " WHERE " + where)

    if _test: return query

    db_cursor = self._db_cursor()
    self._db_execute(db_cursor, query)
    if not self.ctx.transactions: 
        self.ctx.commit()
    return db_cursor.rowcount

</t>
<t tx="zhanglei.20100830144432.1374">def delete(self, table, where, using=None, vars=None, _test=False): 
    """
    Deletes from `table` with clauses `where` and `using`.

        &gt;&gt;&gt; db = DB(None, {})
        &gt;&gt;&gt; name = 'Joe'
        &gt;&gt;&gt; db.delete('foo', where='name = $name', vars=locals(), _test=True)
        &lt;sql: "DELETE FROM foo WHERE name = 'Joe'"&gt;
    """
    if vars is None: vars = {}
    where = self._where(where, vars)

    q = 'DELETE FROM ' + table
    if where: q += ' WHERE ' + where
    if using: q += ' USING ' + sqllist(using)

    if _test: return q

    db_cursor = self._db_cursor()
    self._db_execute(db_cursor, q)
    if not self.ctx.transactions: 
        self.ctx.commit()
    return db_cursor.rowcount

</t>
<t tx="zhanglei.20100830144432.1375">def _process_insert_query(self, query, tablename, seqname):
    return query

</t>
<t tx="zhanglei.20100830144432.1376">def transaction(self): 
    """Start a transaction."""
    return Transaction(self.ctx)

</t>
<t tx="zhanglei.20100830144432.1377">class PostgresDB(DB): 
    """Postgres driver."""
    @others
</t>
<t tx="zhanglei.20100830144432.1378">def __init__(self, **keywords):
    if 'pw' in keywords:
        keywords['password'] = keywords.pop('pw')

    db_module = import_driver(["psycopg2", "psycopg", "pgdb"], preferred=keywords.pop('driver', None))
    if db_module.__name__ == "psycopg2":
        import psycopg2.extensions
        psycopg2.extensions.register_type(psycopg2.extensions.UNICODE)

    # if db is not provided postgres driver will take it from PGDATABASE environment variable
    if 'db' in keywords:
        keywords['database'] = keywords.pop('db')

    self.dbname = "postgres"
    self.paramstyle = db_module.paramstyle
    DB.__init__(self, db_module, keywords)
    self.supports_multiple_insert = True
    self._sequences = None

</t>
<t tx="zhanglei.20100830144432.1379">def _process_insert_query(self, query, tablename, seqname):
    if seqname is None:
        # when seqname is not provided guess the seqname and make sure it exists
        seqname = tablename + "_id_seq"
        if seqname not in self._get_all_sequences():
            seqname = None

    if seqname:
        query += "; SELECT currval('%s')" % seqname

    return query

</t>
<t tx="zhanglei.20100830144432.1380">def _get_all_sequences(self):
    """Query postgres to find names of all sequences used in this database."""
    if self._sequences is None:
        q = "SELECT c.relname FROM pg_class c WHERE c.relkind = 'S'"
        self._sequences = set([c.relname for c in self.query(q)])
    return self._sequences

</t>
<t tx="zhanglei.20100830144432.1381">def _connect(self, keywords):
    conn = DB._connect(self, keywords)
    conn.set_client_encoding('UTF8')
    return conn

</t>
<t tx="zhanglei.20100830144432.1382">def _connect_with_pooling(self, keywords):
    conn = DB._connect_with_pooling(self, keywords)
    conn._con._con.set_client_encoding('UTF8')
    return conn

</t>
<t tx="zhanglei.20100830144432.1383">class MySQLDB(DB): 
    @others
</t>
<t tx="zhanglei.20100830144432.1384">def __init__(self, **keywords):
    import MySQLdb as db
    if 'pw' in keywords:
        keywords['passwd'] = keywords['pw']
        del keywords['pw']

    if 'charset' not in keywords:
        keywords['charset'] = 'utf8'
    elif keywords['charset'] is None:
        del keywords['charset']

    self.paramstyle = db.paramstyle = 'pyformat' # it's both, like psycopg
    self.dbname = "mysql"
    DB.__init__(self, db, keywords)
    self.supports_multiple_insert = True

</t>
<t tx="zhanglei.20100830144432.1385">def _process_insert_query(self, query, tablename, seqname):
    return query, SQLQuery('SELECT last_insert_id();')

</t>
<t tx="zhanglei.20100830144432.1386">def import_driver(drivers, preferred=None):
    """Import the first available driver or preferred driver.
    """
    if preferred:
        drivers = [preferred]

    for d in drivers:
        try:
            return __import__(d, None, None, ['x'])
        except ImportError:
            pass
    raise ImportError("Unable to import " + " or ".join(drivers))

</t>
<t tx="zhanglei.20100830144432.1387">class SqliteDB(DB): 
    @others
</t>
<t tx="zhanglei.20100830144432.1388">def __init__(self, **keywords):
    db = import_driver(["sqlite3", "pysqlite2.dbapi2", "sqlite"], preferred=keywords.pop('driver', None))

    if db.__name__ in ["sqlite3", "pysqlite2.dbapi2"]:
        db.paramstyle = 'qmark'

    self.paramstyle = db.paramstyle
    keywords['database'] = keywords.pop('db')
    self.dbname = "sqlite"        
    DB.__init__(self, db, keywords)

</t>
<t tx="zhanglei.20100830144432.1389">def _process_insert_query(self, query, tablename, seqname):
    return query, SQLQuery('SELECT last_insert_rowid();')

</t>
<t tx="zhanglei.20100830144432.1390">def query(self, *a, **kw):
    out = DB.query(self, *a, **kw)
    if isinstance(out, iterbetter):
        # rowcount is not provided by sqlite
        def _nonzero(): 
            raise self.db_module.NotSupportedError("rowcount is not supported by sqlite")
        del out.__len__
        out.__nonzero__ = _nonzero
    return out

</t>
<t tx="zhanglei.20100830144432.1391">class FirebirdDB(DB):
    """Firebird Database.
    """
    @others
</t>
<t tx="zhanglei.20100830144432.1392">def __init__(self, **keywords):
    try:
        import kinterbasdb as db
    except Exception:
        db = None
        pass
    if 'pw' in keywords:
        keywords['passwd'] = keywords['pw']
        del keywords['pw']
    keywords['database'] = keywords['db']
    del keywords['db']
    DB.__init__(self, db, keywords)

</t>
<t tx="zhanglei.20100830144432.1393">def delete(self, table, where=None, using=None, vars=None, _test=False):
    # firebird doesn't support using clause
    using=None
    return DB.delete(self, table, where, using, vars, _test)

</t>
<t tx="zhanglei.20100830144432.1394">def sql_clauses(self, what, tables, where, group, order, limit, offset):
    return (
        ('SELECT', ''),
        ('FIRST', limit),
        ('SKIP', offset),
        ('', what),
        ('FROM', sqllist(tables)),
        ('WHERE', where),
        ('GROUP BY', group),
        ('ORDER BY', order)
    )

</t>
<t tx="zhanglei.20100830144432.1395">class MSSQLDB(DB):
    @others
</t>
<t tx="zhanglei.20100830144432.1396">def __init__(self, **keywords):
    import pymssql as db    
    if 'pw' in keywords:
        keywords['password'] = keywords.pop('pw')
    keywords['database'] = keywords.pop('db')
    self.dbname = "mssql"
    DB.__init__(self, db, keywords)

</t>
<t tx="zhanglei.20100830144432.1397">def sql_clauses(self, what, tables, where, group, order, limit, offset): 
    return (
        ('SELECT', what),
        ('TOP', limit),
        ('FROM', sqllist(tables)),
        ('WHERE', where),
        ('GROUP BY', group),
        ('ORDER BY', order),
        ('OFFSET', offset))

</t>
<t tx="zhanglei.20100830144432.1398">def _test(self):
    """Test LIMIT.

        Fake presence of pymssql module for running tests.
        &gt;&gt;&gt; import sys
        &gt;&gt;&gt; sys.modules['pymssql'] = sys.modules['sys']

        MSSQL has TOP clause instead of LIMIT clause.
        &gt;&gt;&gt; db = MSSQLDB(db='test', user='joe', pw='secret')
        &gt;&gt;&gt; db.select('foo', limit=4, _test=True)
        &lt;sql: 'SELECT * TOP 4 FROM foo'&gt;
    """
    pass

</t>
<t tx="zhanglei.20100830144432.1399">class OracleDB(DB): 
    @others
</t>
<t tx="zhanglei.20100830144432.1400">def __init__(self, **keywords): 
    import cx_Oracle as db 
    if 'pw' in keywords: 
        keywords['password'] = keywords.pop('pw') 

    #@@ TODO: use db.makedsn if host, port is specified 
    keywords['dsn'] = keywords.pop('db') 
    self.dbname = 'oracle' 
    db.paramstyle = 'numeric' 
    self.paramstyle = db.paramstyle

    # oracle doesn't support pooling 
    keywords.pop('pooling', None) 
    DB.__init__(self, db, keywords) 

</t>
<t tx="zhanglei.20100830144432.1401">def _process_insert_query(self, query, tablename, seqname): 
    if seqname is None: 
        # It is not possible to get seq name from table name in Oracle
        return query
    else:
        return query + "; SELECT %s.currval FROM dual" % seqname 

</t>
<t tx="zhanglei.20100830144432.1402">_databases = {}
def database(dburl=None, **params):
    """Creates appropriate database using params.

    Pooling will be enabled if DBUtils module is available. 
    Pooling can be disabled by passing pooling=False in params.
    """
    dbn = params.pop('dbn')
    if dbn in _databases:
        return _databases[dbn](**params)
    else:
        raise UnknownDB, dbn

</t>
<t tx="zhanglei.20100830144432.1403">def register_database(name, clazz):
    """
    Register a database.

        &gt;&gt;&gt; class LegacyDB(DB): 
        ...     def __init__(self, **params): 
        ...        pass 
        ...
        &gt;&gt;&gt; register_database('legacy', LegacyDB)
        &gt;&gt;&gt; db = database(dbn='legacy', db='test', user='joe', passwd='secret') 
    """
    _databases[name] = clazz

</t>
<t tx="zhanglei.20100830144432.1404">register_database('mysql', MySQLDB)
register_database('postgres', PostgresDB)
register_database('sqlite', SqliteDB)
register_database('firebird', FirebirdDB)
register_database('mssql', MSSQLDB)
register_database('oracle', OracleDB)

def _interpolate(format): 
    """
    Takes a format string and returns a list of 2-tuples of the form
    (boolean, string) where boolean says whether string should be evaled
    or not.

    from &lt;http://lfw.org/python/Itpl.py&gt; (public domain, Ka-Ping Yee)
    """
    from tokenize import tokenprog

    def matchorfail(text, pos):
        match = tokenprog.match(text, pos)
        if match is None:
            raise _ItplError(text, pos)
        return match, match.end()

    namechars = "abcdefghijklmnopqrstuvwxyz" \
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_";
    chunks = []
    pos = 0

    while 1:
        dollar = format.find("$", pos)
        if dollar &lt; 0: 
            break
        nextchar = format[dollar + 1]

        if nextchar == "{":
            chunks.append((0, format[pos:dollar]))
            pos, level = dollar + 2, 1
            while level:
                match, pos = matchorfail(format, pos)
                tstart, tend = match.regs[3]
                token = format[tstart:tend]
                if token == "{": 
                    level = level + 1
                elif token == "}":  
                    level = level - 1
            chunks.append((1, format[dollar + 2:pos - 1]))

        elif nextchar in namechars:
            chunks.append((0, format[pos:dollar]))
            match, pos = matchorfail(format, dollar + 1)
            while pos &lt; len(format):
                if format[pos] == "." and \
                    pos + 1 &lt; len(format) and format[pos + 1] in namechars:
                    match, pos = matchorfail(format, pos + 1)
                elif format[pos] in "([":
                    pos, level = pos + 1, 1
                    while level:
                        match, pos = matchorfail(format, pos)
                        tstart, tend = match.regs[3]
                        token = format[tstart:tend]
                        if token[0] in "([": 
                            level = level + 1
                        elif token[0] in ")]":  
                            level = level - 1
                else: 
                    break
            chunks.append((1, format[dollar + 1:pos]))
        else:
            chunks.append((0, format[pos:dollar + 1]))
            pos = dollar + 1 + (nextchar == "$")

    if pos &lt; len(format): 
        chunks.append((0, format[pos:]))
    return chunks

</t>
<t tx="zhanglei.20100830144432.1405">@language python
@tabwidth -4
@others
@ignore
if __name__ == "__main__":
    urls = (
        '/', 'index'
    )
    from application import application
    app = application(urls, globals())
    app.internalerror = debugerror

    class index:
        def GET(self):
            thisdoesnotexist

    app.run()
</t>
<t tx="zhanglei.20100830144432.1406">"""
pretty debug errors
(part of web.py)

portions adapted from Django &lt;djangoproject.com&gt; 
Copyright (c) 2005, the Lawrence Journal-World
Used under the modified BSD license:
http://www.xfree86.org/3.3.6/COPYRIGHT2.html#5
"""

__all__ = ["debugerror", "djangoerror", "emailerrors"]

import sys, urlparse, pprint, traceback
from net import websafe
from template import Template
from utils import sendmail
import webapi as web

import os, os.path
whereami = os.path.join(os.getcwd(), __file__)
whereami = os.path.sep.join(whereami.split(os.path.sep)[:-1])
djangoerror_t = """\
$def with (exception_type, exception_value, frames)
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta http-equiv="content-type" content="text/html; charset=utf-8" /&gt;
  &lt;meta name="robots" content="NONE,NOARCHIVE" /&gt;
  &lt;title&gt;$exception_type at $ctx.path&lt;/title&gt;
  &lt;style type="text/css"&gt;
    html * { padding:0; margin:0; }
    body * { padding:10px 20px; }
    body * * { padding:0; }
    body { font:small sans-serif; }
    body&gt;div { border-bottom:1px solid #ddd; }
    h1 { font-weight:normal; }
    h2 { margin-bottom:.8em; }
    h2 span { font-size:80%; color:#666; font-weight:normal; }
    h3 { margin:1em 0 .5em 0; }
    h4 { margin:0 0 .5em 0; font-weight: normal; }
    table { 
        border:1px solid #ccc; border-collapse: collapse; background:white; }
    tbody td, tbody th { vertical-align:top; padding:2px 3px; }
    thead th { 
        padding:1px 6px 1px 3px; background:#fefefe; text-align:left; 
        font-weight:normal; font-size:11px; border:1px solid #ddd; }
    tbody th { text-align:right; color:#666; padding-right:.5em; }
    table.vars { margin:5px 0 2px 40px; }
    table.vars td, table.req td { font-family:monospace; }
    table td.code { width:100%;}
    table td.code div { overflow:hidden; }
    table.source th { color:#666; }
    table.source td { 
        font-family:monospace; white-space:pre; border-bottom:1px solid #eee; }
    ul.traceback { list-style-type:none; }
    ul.traceback li.frame { margin-bottom:1em; }
    div.context { margin: 10px 0; }
    div.context ol { 
        padding-left:30px; margin:0 10px; list-style-position: inside; }
    div.context ol li { 
        font-family:monospace; white-space:pre; color:#666; cursor:pointer; }
    div.context ol.context-line li { color:black; background-color:#ccc; }
    div.context ol.context-line li span { float: right; }
    div.commands { margin-left: 40px; }
    div.commands a { color:black; text-decoration:none; }
    #summary { background: #ffc; }
    #summary h2 { font-weight: normal; color: #666; }
    #explanation { background:#eee; }
    #template, #template-not-exist { background:#f6f6f6; }
    #template-not-exist ul { margin: 0 0 0 20px; }
    #traceback { background:#eee; }
    #requestinfo { background:#f6f6f6; padding-left:120px; }
    #summary table { border:none; background:transparent; }
    #requestinfo h2, #requestinfo h3 { position:relative; margin-left:-100px; }
    #requestinfo h3 { margin-bottom:-1em; }
    .error { background: #ffc; }
    .specific { color:#cc3300; font-weight:bold; }
  &lt;/style&gt;
  &lt;script type="text/javascript"&gt;
  //&lt;!--
    function getElementsByClassName(oElm, strTagName, strClassName){
        // Written by Jonathan Snook, http://www.snook.ca/jon; 
        // Add-ons by Robert Nyman, http://www.robertnyman.com
        var arrElements = (strTagName == "*" &amp;&amp; document.all)? document.all :
        oElm.getElementsByTagName(strTagName);
        var arrReturnElements = new Array();
        strClassName = strClassName.replace(/\-/g, "\\-");
        var oRegExp = new RegExp("(^|\\s)" + strClassName + "(\\s|$$)");
        var oElement;
        for(var i=0; i&lt;arrElements.length; i++){
            oElement = arrElements[i];
            if(oRegExp.test(oElement.className)){
                arrReturnElements.push(oElement);
            }
        }
        return (arrReturnElements)
    }
    function hideAll(elems) {
      for (var e = 0; e &lt; elems.length; e++) {
        elems[e].style.display = 'none';
      }
    }
    window.onload = function() {
      hideAll(getElementsByClassName(document, 'table', 'vars'));
      hideAll(getElementsByClassName(document, 'ol', 'pre-context'));
      hideAll(getElementsByClassName(document, 'ol', 'post-context'));
    }
    function toggle() {
      for (var i = 0; i &lt; arguments.length; i++) {
        var e = document.getElementById(arguments[i]);
        if (e) {
          e.style.display = e.style.display == 'none' ? 'block' : 'none';
        }
      }
      return false;
    }
    function varToggle(link, id) {
      toggle('v' + id);
      var s = link.getElementsByTagName('span')[0];
      var uarr = String.fromCharCode(0x25b6);
      var darr = String.fromCharCode(0x25bc);
      s.innerHTML = s.innerHTML == uarr ? darr : uarr;
      return false;
    }
    //--&gt;
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

$def dicttable (d, kls='req', id=None):
    $ items = d and d.items() or []
    $items.sort()
    $:dicttable_items(items, kls, id)

$def dicttable_items(items, kls='req', id=None):
    $if items:
        &lt;table class="$kls"
        $if id: id="$id"
        &gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Variable&lt;/th&gt;&lt;th&gt;Value&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;
        &lt;tbody&gt;
        $for k, v in items:
            &lt;tr&gt;&lt;td&gt;$k&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;$prettify(v)&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;
        &lt;/tbody&gt;
        &lt;/table&gt;
    $else:
        &lt;p&gt;No data.&lt;/p&gt;

&lt;div id="summary"&gt;
  &lt;h1&gt;$exception_type at $ctx.path&lt;/h1&gt;
  &lt;h2&gt;$exception_value&lt;/h2&gt;
  &lt;table&gt;&lt;tr&gt;
    &lt;th&gt;Python&lt;/th&gt;
    &lt;td&gt;$frames[0].filename in $frames[0].function, line $frames[0].lineno&lt;/td&gt;
  &lt;/tr&gt;&lt;tr&gt;
    &lt;th&gt;Web&lt;/th&gt;
    &lt;td&gt;$ctx.method $ctx.home$ctx.path&lt;/td&gt;
  &lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;div id="traceback"&gt;
&lt;h2&gt;Traceback &lt;span&gt;(innermost first)&lt;/span&gt;&lt;/h2&gt;
&lt;ul class="traceback"&gt;
$for frame in frames:
    &lt;li class="frame"&gt;
    &lt;code&gt;$frame.filename&lt;/code&gt; in &lt;code&gt;$frame.function&lt;/code&gt;
    $if frame.context_line:
        &lt;div class="context" id="c$frame.id"&gt;
        $if frame.pre_context:
            &lt;ol start="$frame.pre_context_lineno" class="pre-context" id="pre$frame.id"&gt;
            $for line in frame.pre_context:
                &lt;li onclick="toggle('pre$frame.id', 'post$frame.id')"&gt;$line&lt;/li&gt;
            &lt;/ol&gt;
            &lt;ol start="$frame.lineno" class="context-line"&gt;&lt;li onclick="toggle('pre$frame.id', 'post$frame.id')"&gt;$frame.context_line &lt;span&gt;...&lt;/span&gt;&lt;/li&gt;&lt;/ol&gt;
        $if frame.post_context:
            &lt;ol start='${frame.lineno + 1}' class="post-context" id="post$frame.id"&gt;
            $for line in frame.post_context:
                &lt;li onclick="toggle('pre$frame.id', 'post$frame.id')"&gt;$line&lt;/li&gt;
            &lt;/ol&gt;
      &lt;/div&gt;

    $if frame.vars:
        &lt;div class="commands"&gt;
        &lt;a href='#' onclick="return varToggle(this, '$frame.id')"&gt;&lt;span&gt;&amp;#x25b6;&lt;/span&gt; Local vars&lt;/a&gt;
        $# $inspect.formatargvalues(*inspect.getargvalues(frame['tb'].tb_frame))
        &lt;/div&gt;
        $:dicttable(frame.vars, kls='vars', id=('v' + str(frame.id)))
      &lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;

&lt;div id="requestinfo"&gt;
$if ctx.output or ctx.headers:
    &lt;h2&gt;Response so far&lt;/h2&gt;
    &lt;h3&gt;HEADERS&lt;/h3&gt;
    $:dicttable_items(ctx.headers)

    &lt;h3&gt;BODY&lt;/h3&gt;
    &lt;p class="req" style="padding-bottom: 2em"&gt;&lt;code&gt;
    $ctx.output
    &lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;Request information&lt;/h2&gt;

&lt;h3&gt;INPUT&lt;/h3&gt;
$:dicttable(web.input(_unicode=False))

&lt;h3 id="cookie-info"&gt;COOKIES&lt;/h3&gt;
$:dicttable(web.cookies())

&lt;h3 id="meta-info"&gt;META&lt;/h3&gt;
$ newctx = [(k, v) for (k, v) in ctx.iteritems() if not k.startswith('_') and not isinstance(v, dict)]
$:dicttable(dict(newctx))

&lt;h3 id="meta-info"&gt;ENVIRONMENT&lt;/h3&gt;
$:dicttable(ctx.env)
&lt;/div&gt;

&lt;div id="explanation"&gt;
  &lt;p&gt;
    You're seeing this error because you have &lt;code&gt;web.config.debug&lt;/code&gt;
    set to &lt;code&gt;True&lt;/code&gt;. Set that to &lt;code&gt;False&lt;/code&gt; if you don't to see this.
  &lt;/p&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
"""

djangoerror_r = None

</t>
<t tx="zhanglei.20100830144432.1407">def djangoerror():
    def _get_lines_from_file(filename, lineno, context_lines):
        """
        Returns context_lines before and after lineno from file.
        Returns (pre_context_lineno, pre_context, context_line, post_context).
        """
        try:
            source = open(filename).readlines()
            lower_bound = max(0, lineno - context_lines)
            upper_bound = lineno + context_lines

            pre_context = \
                [line.strip('\n') for line in source[lower_bound:lineno]]
            context_line = source[lineno].strip('\n')
            post_context = \
                [line.strip('\n') for line in source[lineno + 1:upper_bound]]

            return lower_bound, pre_context, context_line, post_context
        except (OSError, IOError):
            return None, [], None, []    

    exception_type, exception_value, tback = sys.exc_info()
    frames = []
    while tback is not None:
        filename = tback.tb_frame.f_code.co_filename
        function = tback.tb_frame.f_code.co_name
        lineno = tback.tb_lineno - 1
        pre_context_lineno, pre_context, context_line, post_context = \
            _get_lines_from_file(filename, lineno, 7)
        frames.append(web.storage({
            'tback': tback,
            'filename': filename,
            'function': function,
            'lineno': lineno,
            'vars': tback.tb_frame.f_locals,
            'id': id(tback),
            'pre_context': pre_context,
            'context_line': context_line,
            'post_context': post_context,
            'pre_context_lineno': pre_context_lineno,
        }))
        tback = tback.tb_next
    frames.reverse()
    urljoin = urlparse.urljoin
    def prettify(x):
        try: 
            out = pprint.pformat(x)
        except Exception, e: 
            out = '[could not display: &lt;' + e.__class__.__name__ + \
                  ': '+str(e)+'&gt;]'
        return out

    global djangoerror_r
    if djangoerror_r is None:
        djangoerror_r = Template(djangoerror_t, filename=__file__, filter=websafe)

    t = djangoerror_r
    globals = {'ctx': web.ctx, 'web':web, 'dict':dict, 'str':str, 'prettify': prettify}
    t.t.func_globals.update(globals)
    return t(exception_type, exception_value, frames)

</t>
<t tx="zhanglei.20100830144432.1408">def debugerror():
    """
    A replacement for `internalerror` that presents a nice page with lots
    of debug information for the programmer.

    (Based on the beautiful 500 page from [Django](http://djangoproject.com/), 
    designed by [Wilson Miner](http://wilsonminer.com/).)
    """
    return web._InternalError(djangoerror())

</t>
<t tx="zhanglei.20100830144432.1409">def emailerrors(to_address, olderror, from_address=None):
    """
    Wraps the old `internalerror` handler (pass as `olderror`) to 
    additionally email all errors to `to_address`, to aid in
    debugging production websites.

    Emails contain a normal text traceback as well as an
    attachment containing the nice `debugerror` page.
    """
    from_address = from_address or to_address

    def emailerrors_internal():
        error = olderror()
        tb = sys.exc_info()
        error_name = tb[0]
        error_value = tb[1]
        tb_txt = ''.join(traceback.format_exception(*tb))
        path = web.ctx.path
        request = web.ctx.method + ' ' + web.ctx.home + web.ctx.fullpath
        text = ("""\
------here----
Content-Type: text/plain
Content-Disposition: inline

%(request)s

%(tb_txt)s

------here----
Content-Type: text/html; name="bug.html"
Content-Disposition: attachment; filename="bug.html"

""" % locals()) + str(djangoerror())
        sendmail(
          "your buggy site &lt;%s&gt;" % from_address,
          "the bugfixer &lt;%s&gt;" % to_address,
          "bug: %(error_name)s: %(error_value)s (%(path)s)" % locals(),
          text, 
          headers={'Content-Type': 'multipart/mixed; boundary="----here----"'})
        return error

    return emailerrors_internal

</t>
<t tx="zhanglei.20100830144432.1410">@language python
@tabwidth -4
@others
@ignore
if __name__ == "__main__":
    import doctest
    doctest.testmod()
</t>
<t tx="zhanglei.20100830144432.1411">"""
HTML forms
(part of web.py)
"""

import copy, re
import webapi as web
import utils, net

</t>
<t tx="zhanglei.20100830144432.1412">def attrget(obj, attr, value=None):
    if hasattr(obj, 'has_key') and obj.has_key(attr): return obj[attr]
    if hasattr(obj, attr): return getattr(obj, attr)
    return value

</t>
<t tx="zhanglei.20100830144432.1413">class Form:
    r"""
    HTML form.

        &gt;&gt;&gt; f = Form(Textbox("x"))
        &gt;&gt;&gt; f.render()
        '&lt;table&gt;\n    &lt;tr&gt;&lt;th&gt;&lt;label for="x"&gt;x&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input type="text" id="x" name="x"/&gt;&lt;/td&gt;&lt;/tr&gt;\n&lt;/table&gt;'
    """
    @others
    d = property(_get_d)

</t>
<t tx="zhanglei.20100830144432.1414">def __init__(self, *inputs, **kw):
    self.inputs = inputs
    self.valid = True
    self.note = None
    self.validators = kw.pop('validators', [])

</t>
<t tx="zhanglei.20100830144432.1415">def __call__(self, x=None):
    o = copy.deepcopy(self)
    if x: o.validates(x)
    return o

</t>
<t tx="zhanglei.20100830144432.1416">def render(self):
    out = ''
    out += self.rendernote(self.note)
    out += '&lt;table&gt;\n'

    for i in self.inputs:
        html = i.pre + i.render() + self.rendernote(i.note) + i.post
        if i.is_hidden():
            out += '    &lt;tr style="display: none;"&gt;&lt;th&gt;&lt;/th&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;\n' % (html)
        else:
            out += '    &lt;tr&gt;&lt;th&gt;&lt;label for="%s"&gt;%s&lt;/label&gt;&lt;/th&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;\n' % (i.id, net.websafe(i.description), html)
    out += "&lt;/table&gt;"
    return out

</t>
<t tx="zhanglei.20100830144432.1417">def render_css(self): 
    out = [] 
    out.append(self.rendernote(self.note)) 
    for i in self.inputs:
        if not i.is_hidden():
            out.append('&lt;label for="%s"&gt;%s&lt;/label&gt;' % (i.id, net.websafe(i.description))) 
        out.append(i.pre)
        out.append(i.render()) 
        out.append(self.rendernote(i.note))
        out.append(i.post) 
        out.append('\n')
    return ''.join(out) 

</t>
<t tx="zhanglei.20100830144432.1418">def rendernote(self, note):
    if note: return '&lt;strong class="wrong"&gt;%s&lt;/strong&gt;' % net.websafe(note)
    else: return ""

</t>
<t tx="zhanglei.20100830144432.1419">def validates(self, source=None, _validate=True, **kw):
    source = source or kw or web.input()
    out = True
    for i in self.inputs:
        v = attrget(source, i.name)
        if _validate:
            out = i.validate(v) and out
        else:
            i.value = v
    if _validate:
        out = out and self._validate(source)
        self.valid = out
    return out

</t>
<t tx="zhanglei.20100830144432.1420">def _validate(self, value):
    self.value = value
    for v in self.validators:
        if not v.valid(value):
            self.note = v.msg
            return False
    return True

</t>
<t tx="zhanglei.20100830144432.1421">def fill(self, source=None, **kw):
    return self.validates(source, _validate=False, **kw)

</t>
<t tx="zhanglei.20100830144432.1422">def __getitem__(self, i):
    for x in self.inputs:
        if x.name == i: return x
    raise KeyError, i

</t>
<t tx="zhanglei.20100830144432.1423">def __getattr__(self, name):
    # don't interfere with deepcopy
    inputs = self.__dict__.get('inputs') or []
    for x in inputs:
        if x.name == name: return x
    raise AttributeError, name

</t>
<t tx="zhanglei.20100830144432.1424">def get(self, i, default=None):
    try:
        return self[i]
    except KeyError:
        return default

</t>
<t tx="zhanglei.20100830144432.1425">def _get_d(self): #@@ should really be form.attr, no?
    return utils.storage([(i.name, i.get_value()) for i in self.inputs])
</t>
<t tx="zhanglei.20100830144432.1426">class Input(object):
    @others
</t>
<t tx="zhanglei.20100830144432.1427">def __init__(self, name, *validators, **attrs):
    self.name = name
    self.validators = validators
    self.attrs = attrs = AttributeList(attrs)

    self.description = attrs.pop('description', name)
    self.value = attrs.pop('value', None)
    self.pre = attrs.pop('pre', "")
    self.post = attrs.pop('post', "")
    self.note = None

    self.id = attrs.setdefault('id', self.get_default_id())

    if 'class_' in attrs:
        attrs['class'] = attrs['class_']
        del attrs['class_']

</t>
<t tx="zhanglei.20100830144432.1428">def is_hidden(self):
    return False

</t>
<t tx="zhanglei.20100830144432.1429">def get_type(self):
    raise NotImplementedError

</t>
<t tx="zhanglei.20100830144432.1430">def get_default_id(self):
    return self.name

</t>
<t tx="zhanglei.20100830144432.1431">def validate(self, value):
    self.set_value(value)

    for v in self.validators:
        if not v.valid(value):
            self.note = v.msg
            return False
    return True

</t>
<t tx="zhanglei.20100830144432.1432">def set_value(self, value):
    self.value = value

</t>
<t tx="zhanglei.20100830144432.1433">def get_value(self):
    return self.value

</t>
<t tx="zhanglei.20100830144432.1434">def render(self):
    attrs = self.attrs.copy()
    attrs['type'] = self.get_type()
    if self.value:
        attrs['value'] = self.value
    attrs['name'] = self.name
    return '&lt;input %s/&gt;' % attrs

</t>
<t tx="zhanglei.20100830144432.1435">def rendernote(self, note):
    if note: return '&lt;strong class="wrong"&gt;%s&lt;/strong&gt;' % net.websafe(note)
    else: return ""

</t>
<t tx="zhanglei.20100830144432.1436">def addatts(self):
    return str(self.attrs)

</t>
<t tx="zhanglei.20100830144432.1437">class AttributeList(dict):
    """List of atributes of input.

    &gt;&gt;&gt; a = AttributeList(type='text', name='x', value=20)
    &gt;&gt;&gt; a
    &lt;attrs: 'type="text" name="x" value="20"'&gt;
    """
    @others
</t>
<t tx="zhanglei.20100830144432.1438">def copy(self):
    return AttributeList(self)

</t>
<t tx="zhanglei.20100830144432.1439">def __str__(self):
    return " ".join('%s="%s"' % (k, net.websafe(v)) for k, v in self.items())

</t>
<t tx="zhanglei.20100830144432.1440">def __repr__(self):
    return '&lt;attrs: %s&gt;' % repr(str(self))

</t>
<t tx="zhanglei.20100830144432.1441">class Textbox(Input):
    """Textbox input.

        &gt;&gt;&gt; Textbox(name='foo', value='bar').render()
        '&lt;input type="text" id="foo" value="bar" name="foo"/&gt;'
    """        
    @others
</t>
<t tx="zhanglei.20100830144432.1442">def get_type(self):
    return 'text'

</t>
<t tx="zhanglei.20100830144432.1443">class Password(Input):
    """Password input.

        &gt;&gt;&gt; Password(name='password', value='secret').render()
        '&lt;input type="password" id="password" value="secret" name="password"/&gt;'
    """
    @others
</t>
<t tx="zhanglei.20100830144432.1444">
def get_type(self):
    return 'password'

</t>
<t tx="zhanglei.20100830144432.1445">class Textarea(Input):
    """Textarea input.

        &gt;&gt;&gt; Textarea(name='foo', value='bar').render()
        '&lt;textarea id="foo" name="foo"&gt;bar&lt;/textarea&gt;'
    """
    @others
</t>
<t tx="zhanglei.20100830144432.1446">def render(self):
    attrs = self.attrs.copy()
    attrs['name'] = self.name
    value = net.websafe(self.value or '')
    return '&lt;textarea %s&gt;%s&lt;/textarea&gt;' % (attrs, value)

</t>
<t tx="zhanglei.20100830144432.1447">class Dropdown(Input):
    r"""Dropdown/select input.

        &gt;&gt;&gt; Dropdown(name='foo', args=['a', 'b', 'c'], value='b').render()
        '&lt;select id="foo" name="foo"&gt;\n  &lt;option value="a"&gt;a&lt;/option&gt;\n  &lt;option selected="selected" value="b"&gt;b&lt;/option&gt;\n  &lt;option value="c"&gt;c&lt;/option&gt;\n&lt;/select&gt;\n'
        &gt;&gt;&gt; Dropdown(name='foo', args=[('a', 'aa'), ('b', 'bb'), ('c', 'cc')], value='b').render()
        '&lt;select id="foo" name="foo"&gt;\n  &lt;option value="a"&gt;aa&lt;/option&gt;\n  &lt;option selected="selected" value="b"&gt;bb&lt;/option&gt;\n  &lt;option value="c"&gt;cc&lt;/option&gt;\n&lt;/select&gt;\n'
    """
    @others
</t>
<t tx="zhanglei.20100830144432.1448">def __init__(self, name, args, *validators, **attrs):
    self.args = args
    super(Dropdown, self).__init__(name, *validators, **attrs)

</t>
<t tx="zhanglei.20100830144432.1449">def render(self):
    attrs = self.attrs.copy()
    attrs['name'] = self.name

    x = '&lt;select %s&gt;\n' % attrs

    for arg in self.args:
        if isinstance(arg, (tuple, list)):
            value, desc= arg
        else:
            value, desc = arg, arg 

        if self.value == value: select_p = ' selected="selected"'
        else: select_p = ''
        x += '  &lt;option%s value="%s"&gt;%s&lt;/option&gt;\n' % (select_p, net.websafe(value), net.websafe(desc))

    x += '&lt;/select&gt;\n'
    return x

</t>
<t tx="zhanglei.20100830144432.1450">class Radio(Input):
    @others
</t>
<t tx="zhanglei.20100830144432.1451">def __init__(self, name, args, *validators, **attrs):
    self.args = args
    super(Radio, self).__init__(name, *validators, **attrs)

</t>
<t tx="zhanglei.20100830144432.1452">def render(self):
    x = '&lt;span&gt;'
    for arg in self.args:
        if isinstance(arg, (tuple, list)):
            value, desc= arg
        else:
            value, desc = arg, arg 
        attrs = self.attrs.copy()
        attrs['name'] = self.name
        attrs['type'] = 'radio'
        attrs['value'] = arg
        if self.value == arg:
            attrs['checked'] = 'checked'
        x += '&lt;input %s/&gt; %s' % (attrs, net.websafe(desc))
    x += '&lt;/span&gt;'
    return x

</t>
<t tx="zhanglei.20100830144432.1453">class Checkbox(Input):
    """Checkbox input.

    &gt;&gt;&gt; Checkbox('foo', value='bar', checked=True).render()
    '&lt;input checked="checked" type="checkbox" id="foo_bar" value="bar" name="foo"/&gt;'
    &gt;&gt;&gt; Checkbox('foo', value='bar').render()
    '&lt;input type="checkbox" id="foo_bar" value="bar" name="foo"/&gt;'
    &gt;&gt;&gt; c = Checkbox('foo', value='bar')
    &gt;&gt;&gt; c.validate('on')
    True
    &gt;&gt;&gt; c.render()
    '&lt;input checked="checked" type="checkbox" id="foo_bar" value="bar" name="foo"/&gt;'
    """
    @others
</t>
<t tx="zhanglei.20100830144432.1454">def __init__(self, name, *validators, **attrs):
    self.checked = attrs.pop('checked', False)
    Input.__init__(self, name, *validators, **attrs)

</t>
<t tx="zhanglei.20100830144432.1455">def get_default_id(self):
    value = self.value or ""
    return self.name + '_' + value.replace(' ', '_')

</t>
<t tx="zhanglei.20100830144432.1456">def render(self):
    attrs = self.attrs.copy()
    attrs['type'] = 'checkbox'
    attrs['name'] = self.name
    attrs['value'] = self.value

    if self.checked:
        attrs['checked'] = 'checked'            
    return '&lt;input %s/&gt;' % attrs

</t>
<t tx="zhanglei.20100830144432.1457">def set_value(self, value):
    if value:
        self.checked = True

</t>
<t tx="zhanglei.20100830144432.1458">def get_value(self):
    return self.checked

</t>
<t tx="zhanglei.20100830144432.1459">class Button(Input):
    """HTML Button.

    &gt;&gt;&gt; Button("save").render()
    '&lt;button id="save" name="save"&gt;save&lt;/button&gt;'
    &gt;&gt;&gt; Button("action", value="save", html="&lt;b&gt;Save Changes&lt;/b&gt;").render()
    '&lt;button id="action" value="save" name="action"&gt;&lt;b&gt;Save Changes&lt;/b&gt;&lt;/button&gt;'
    """
    @others
</t>
<t tx="zhanglei.20100830144432.1460">def __init__(self, name, *validators, **attrs):
    super(Button, self).__init__(name, *validators, **attrs)
    self.description = ""

</t>
<t tx="zhanglei.20100830144432.1461">def render(self):
    attrs = self.attrs.copy()
    attrs['name'] = self.name
    if self.value is not None:
        attrs['value'] = self.value
    html = attrs.pop('html', None) or net.websafe(self.name)
    return '&lt;button %s&gt;%s&lt;/button&gt;' % (attrs, html)

</t>
<t tx="zhanglei.20100830144432.1462">class Hidden(Input):
    """Hidden Input.

        &gt;&gt;&gt; Hidden(name='foo', value='bar').render()
        '&lt;input type="hidden" id="foo" value="bar" name="foo"/&gt;'
    """
    @others
</t>
<t tx="zhanglei.20100830144432.1463">def is_hidden(self):
    return True

</t>
<t tx="zhanglei.20100830144432.1464">def get_type(self):
    return 'hidden'

</t>
<t tx="zhanglei.20100830144432.1465">class File(Input):
    """File input.

        &gt;&gt;&gt; File(name='f').render()
        '&lt;input type="file" id="f" name="f"/&gt;'
    """
    @others
</t>
<t tx="zhanglei.20100830144432.1466">def get_type(self):
    return 'file'

</t>
<t tx="zhanglei.20100830144432.1467">class Validator:
    @others
</t>
<t tx="zhanglei.20100830144432.1468">def __deepcopy__(self, memo): return copy.copy(self)
</t>
<t tx="zhanglei.20100830144432.1469">def __init__(self, msg, test, jstest=None): utils.autoassign(self, locals())
</t>
<t tx="zhanglei.20100830144432.1470">def valid(self, value): 
    try: return self.test(value)
    except: return False

</t>
<t tx="zhanglei.20100830144432.1471">notnull = Validator("Required", bool)

class regexp(Validator):
    @others
</t>
<t tx="zhanglei.20100830144432.1472">def __init__(self, rexp, msg):
    self.rexp = re.compile(rexp)
    self.msg = msg

</t>
<t tx="zhanglei.20100830144432.1473">def valid(self, value):
    return bool(self.rexp.match(value))

</t>
<t tx="zhanglei.20100830144432.1474">@language python
@tabwidth -4
@others
@ignore
if __name__ == "__main__":
    import doctest
    doctest.testmod()
</t>
<t tx="zhanglei.20100830144432.1475">"""
HTTP Utilities
(from web.py)
"""

__all__ = [
  "expires", "lastmodified", 
  "prefixurl", "modified", 
  "changequery", "url",
  "profiler",
]

import sys, os, threading, urllib, urlparse
try: import datetime
except ImportError: pass
import net, utils, webapi as web

</t>
<t tx="zhanglei.20100830144432.1476">def prefixurl(base=''):
    """
    Sorry, this function is really difficult to explain.
    Maybe some other time.
    """
    url = web.ctx.path.lstrip('/')
    for i in xrange(url.count('/')): 
        base += '../'
    if not base: 
        base = './'
    return base

</t>
<t tx="zhanglei.20100830144432.1477">def expires(delta):
    """
    Outputs an `Expires` header for `delta` from now. 
    `delta` is a `timedelta` object or a number of seconds.
    """
    if isinstance(delta, (int, long)):
        delta = datetime.timedelta(seconds=delta)
    date_obj = datetime.datetime.utcnow() + delta
    web.header('Expires', net.httpdate(date_obj))

</t>
<t tx="zhanglei.20100830144432.1478">def lastmodified(date_obj):
    """Outputs a `Last-Modified` header for `datetime`."""
    web.header('Last-Modified', net.httpdate(date_obj))

</t>
<t tx="zhanglei.20100830144432.1479">def modified(date=None, etag=None):
    """
    Checks to see if the page has been modified since the version in the
    requester's cache.

    When you publish pages, you can include `Last-Modified` and `ETag`
    with the date the page was last modified and an opaque token for
    the particular version, respectively. When readers reload the page, 
    the browser sends along the modification date and etag value for
    the version it has in its cache. If the page hasn't changed, 
    the server can just return `304 Not Modified` and not have to 
    send the whole page again.

    This function takes the last-modified date `date` and the ETag `etag`
    and checks the headers to see if they match. If they do, it returns 
    `True` and sets the response status to `304 Not Modified`. It also
    sets `Last-Modified and `ETag` output headers.
    """
    try:
        from __builtin__ import set
    except ImportError:
        # for python 2.3
        from sets import Set as set

    n = set([x.strip('" ') for x in web.ctx.env.get('HTTP_IF_NONE_MATCH', '').split(',')])
    m = net.parsehttpdate(web.ctx.env.get('HTTP_IF_MODIFIED_SINCE', '').split(';')[0])
    validate = False
    if etag:
        if '*' in n or etag in n:
            validate = True
    if date and m:
        # we subtract a second because 
        # HTTP dates don't have sub-second precision
        if date-datetime.timedelta(seconds=1) &lt;= m:
            validate = True

    if validate: web.ctx.status = '304 Not Modified'
    if date: lastmodified(date)
    if etag: web.header('ETag', '"' + etag + '"')
    return not validate

</t>
<t tx="zhanglei.20100830144432.1480">def urlencode(query, doseq=0):
    """
    Same as urllib.urlencode, but supports unicode strings.

        &gt;&gt;&gt; urlencode({'text':'foo bar'})
        'text=foo+bar'
        &gt;&gt;&gt; urlencode({'x': [1, 2]}, doseq=True)
        'x=1&amp;x=2'
    """
    def convert(value, doseq=False):
        if doseq and isinstance(value, list):
            return [convert(v) for v in value]
        else:
            return utils.utf8(value)

    query = dict([(k, convert(v, doseq)) for k, v in query.items()])
    return urllib.urlencode(query, doseq=doseq)

</t>
<t tx="zhanglei.20100830144432.1481">def changequery(query=None, **kw):
    """
    Imagine you're at `/foo?a=1&amp;b=2`. Then `changequery(a=3)` will return
    `/foo?a=3&amp;b=2` -- the same URL but with the arguments you requested
    changed.
    """
    if query is None:
        query = web.rawinput(method='get')
    for k, v in kw.iteritems():
        if v is None:
            query.pop(k, None)
        else:
            query[k] = v
    out = web.ctx.path
    if query:
        out += '?' + urlencode(query, doseq=True)
    return out

</t>
<t tx="zhanglei.20100830144432.1482">def url(path=None, **kw):
    """
    Makes url by concatinating web.ctx.homepath and path and the 
    query string created using the arguments.
    """
    if path is None:
        path = web.ctx.path
    if path.startswith("/"):
        out = web.ctx.homepath + path
    else:
        out = path

    if kw:
        out += '?' + urlencode(kw)

    return out

</t>
<t tx="zhanglei.20100830144432.1483">def profiler(app):
    """Outputs basic profiling information at the bottom of each response."""
    from utils import profile
    def profile_internal(e, o):
        out, result = profile(app)(e, o)
        return list(out) + ['&lt;pre&gt;' + net.websafe(result) + '&lt;/pre&gt;']
    return profile_internal

</t>
<t tx="zhanglei.20100830144432.1484">@language python
@tabwidth -4
@ignore
@others
</t>
<t tx="zhanglei.20100830144432.1485">__all__ = ["runsimple"]

import sys, os
from SimpleHTTPServer import SimpleHTTPRequestHandler

import webapi as web
import net
import utils

</t>
<t tx="zhanglei.20100830144432.1486">def runbasic(func, server_address=("0.0.0.0", 8080)):
    """
    Runs a simple HTTP server hosting WSGI app `func`. The directory `static/` 
    is hosted statically.

    Based on [WsgiServer][ws] from [Colin Stewart][cs].

  [ws]: http://www.owlfish.com/software/wsgiutils/documentation/wsgi-server-api.html
  [cs]: http://www.owlfish.com/
    """
    # Copyright (c) 2004 Colin Stewart (http://www.owlfish.com/)
    # Modified somewhat for simplicity
    # Used under the modified BSD license:
    # http://www.xfree86.org/3.3.6/COPYRIGHT2.html#5

    import SimpleHTTPServer, SocketServer, BaseHTTPServer, urlparse
    import socket, errno
    import traceback

    class WSGIHandler(SimpleHTTPServer.SimpleHTTPRequestHandler):
        def run_wsgi_app(self):
            protocol, host, path, parameters, query, fragment = \
                urlparse.urlparse('http://dummyhost%s' % self.path)

            # we only use path, query
            env = {'wsgi.version': (1, 0)
                   ,'wsgi.url_scheme': 'http'
                   ,'wsgi.input': self.rfile
                   ,'wsgi.errors': sys.stderr
                   ,'wsgi.multithread': 1
                   ,'wsgi.multiprocess': 0
                   ,'wsgi.run_once': 0
                   ,'REQUEST_METHOD': self.command
                   ,'REQUEST_URI': self.path
                   ,'PATH_INFO': path
                   ,'QUERY_STRING': query
                   ,'CONTENT_TYPE': self.headers.get('Content-Type', '')
                   ,'CONTENT_LENGTH': self.headers.get('Content-Length', '')
                   ,'REMOTE_ADDR': self.client_address[0]
                   ,'SERVER_NAME': self.server.server_address[0]
                   ,'SERVER_PORT': str(self.server.server_address[1])
                   ,'SERVER_PROTOCOL': self.request_version
                   }

            for http_header, http_value in self.headers.items():
                env ['HTTP_%s' % http_header.replace('-', '_').upper()] = \
                    http_value

            # Setup the state
            self.wsgi_sent_headers = 0
            self.wsgi_headers = []

            try:
                # We have there environment, now invoke the application
                result = self.server.app(env, self.wsgi_start_response)
                try:
                    try:
                        for data in result:
                            if data: 
                                self.wsgi_write_data(data)
                    finally:
                        if hasattr(result, 'close'): 
                            result.close()
                except socket.error, socket_err:
                    # Catch common network errors and suppress them
                    if (socket_err.args[0] in \
                       (errno.ECONNABORTED, errno.EPIPE)): 
                        return
                except socket.timeout, socket_timeout: 
                    return
            except:
                print &gt;&gt; web.debug, traceback.format_exc(),

            if (not self.wsgi_sent_headers):
                # We must write out something!
                self.wsgi_write_data(" ")
            return

        do_POST = run_wsgi_app
        do_PUT = run_wsgi_app
        do_DELETE = run_wsgi_app

        def do_GET(self):
            if self.path.startswith('/static/'):
                SimpleHTTPServer.SimpleHTTPRequestHandler.do_GET(self)
            else:
                self.run_wsgi_app()

        def wsgi_start_response(self, response_status, response_headers, 
                              exc_info=None):
            if (self.wsgi_sent_headers):
                raise Exception \
                      ("Headers already sent and start_response called again!")
            # Should really take a copy to avoid changes in the application....
            self.wsgi_headers = (response_status, response_headers)
            return self.wsgi_write_data

        def wsgi_write_data(self, data):
            if (not self.wsgi_sent_headers):
                status, headers = self.wsgi_headers
                # Need to send header prior to data
                status_code = status[:status.find(' ')]
                status_msg = status[status.find(' ') + 1:]
                self.send_response(int(status_code), status_msg)
                for header, value in headers:
                    self.send_header(header, value)
                self.end_headers()
                self.wsgi_sent_headers = 1
            # Send the data
            self.wfile.write(data)

    class WSGIServer(SocketServer.ThreadingMixIn, BaseHTTPServer.HTTPServer):
        def __init__(self, func, server_address):
            BaseHTTPServer.HTTPServer.__init__(self, 
                                               server_address, 
                                               WSGIHandler)
            self.app = func
            self.serverShuttingDown = 0
            """这个是测试ignore的作用"""

    print "http://%s:%d/" % server_address
    WSGIServer(func, server_address).serve_forever()

</t>
<t tx="zhanglei.20100830144432.1487">def runsimple(func, server_address=("0.0.0.0", 8080)):
    """
    Runs [CherryPy][cp] WSGI server hosting WSGI app `func`. 
    The directory `static/` is hosted statically.

    [cp]: http://www.cherrypy.org
    """
    func = StaticMiddleware(func)
    func = LogMiddleware(func)

    server = WSGIServer(server_address, func)

    print "http://%s:%d/" % server_address
    try:
        server.start()
    except KeyboardInterrupt:
        server.stop()

</t>
<t tx="zhanglei.20100830144432.1488">def WSGIServer(server_address, wsgi_app):
    """Creates CherryPy WSGI server listening at `server_address` to serve `wsgi_app`.
    This function can be overwritten to customize the webserver or use a different webserver.
    """
    from wsgiserver import CherryPyWSGIServer
    return CherryPyWSGIServer(server_address, wsgi_app, server_name="localhost")

</t>
<t tx="zhanglei.20100830144432.1489">class StaticApp(SimpleHTTPRequestHandler):
    """WSGI application for serving static files."""
    @others
</t>
<t tx="zhanglei.20100830144432.1490">def __init__(self, environ, start_response):
    self.headers = []
    self.environ = environ
    self.start_response = start_response

</t>
<t tx="zhanglei.20100830144432.1491">def send_response(self, status, msg=""):
    self.status = str(status) + " " + msg

</t>
<t tx="zhanglei.20100830144432.1492">def send_header(self, name, value):
    self.headers.append((name, value))

</t>
<t tx="zhanglei.20100830144432.1493">def end_headers(self):
    pass

</t>
<t tx="zhanglei.20100830144432.1494">def log_message(*a): pass

</t>
<t tx="zhanglei.20100830144432.1495">def __iter__(self):
    environ = self.environ

    self.path = environ.get('PATH_INFO', '')
    self.client_address = environ.get('REMOTE_ADDR','-'), \
                          environ.get('REMOTE_PORT','-')
    self.command = environ.get('REQUEST_METHOD', '-')

    from cStringIO import StringIO
    self.wfile = StringIO() # for capturing error

    f = self.send_head()
    self.start_response(self.status, self.headers)

    if f:
        block_size = 16 * 1024
        while True:
            buf = f.read(block_size)
            if not buf:
                break
            yield buf
        f.close()
    else:
        value = self.wfile.getvalue()
        yield value

</t>
<t tx="zhanglei.20100830144432.1496">class StaticMiddleware:
    """WSGI middleware for serving static files."""
    @others
</t>
<t tx="zhanglei.20100830144432.1497">def __init__(self, app, prefix='/static/'):
    self.app = app
    self.prefix = prefix

</t>
<t tx="zhanglei.20100830144432.1498">def __call__(self, environ, start_response):
    path = environ.get('PATH_INFO', '')
    if path.startswith(self.prefix):
        return StaticApp(environ, start_response)
    else:
        return self.app(environ, start_response)

</t>
<t tx="zhanglei.20100830144432.1499">class LogMiddleware:
    """WSGI middleware for logging the status."""
    @others
</t>
<t tx="zhanglei.20100830144432.1500">def __init__(self, app):
    self.app = app
    self.format = '%s - - [%s] "%s %s %s" - %s'

    from BaseHTTPServer import BaseHTTPRequestHandler
    import StringIO
    f = StringIO.StringIO()

    class FakeSocket:
        def makefile(self, *a):
            return f

    # take log_date_time_string method from BaseHTTPRequestHandler
    self.log_date_time_string = BaseHTTPRequestHandler(FakeSocket(), None, None).log_date_time_string

</t>
<t tx="zhanglei.20100830144432.1501">def __call__(self, environ, start_response):
    def xstart_response(status, response_headers, *args):
        out = start_response(status, response_headers, *args)
        self.log(status, environ)
        return out

    return self.app(environ, xstart_response)

</t>
<t tx="zhanglei.20100830144432.1502">def log(self, status, environ):
    outfile = environ.get('wsgi.errors', web.debug)
    req = environ.get('PATH_INFO', '_')
    protocol = environ.get('ACTUAL_SERVER_PROTOCOL', '-')
    method = environ.get('REQUEST_METHOD', '-')
    host = "%s:%s" % (environ.get('REMOTE_ADDR','-'), 
                      environ.get('REMOTE_PORT','-'))

    time = self.log_date_time_string()

    msg = self.format % (host, time, protocol, method, req, status)
    print &gt;&gt; outfile, utils.safestr(msg)
</t>
<t tx="zhanglei.20100830144432.1503">@language python
@tabwidth -4
@others
@ignore
</t>
<t tx="zhanglei.20100830144432.1504">#!/usr/bin/env python
"""web.py: makes web apps (http://webpy.org)"""

from __future__ import generators

__version__ = "0.33"
__author__ = [
    "Aaron Swartz &lt;me@aaronsw.com&gt;",
    "Anand Chitipothu &lt;anandology@gmail.com&gt;"
]
__license__ = "public domain"
__contributors__ = "see http://webpy.org/changes"

import utils, db, net, wsgi, http, webapi, httpserver, debugerror
import template, form

import session

from utils import *
from db import *
from net import *
from wsgi import *
from http import *
from webapi import *
from httpserver import *
from debugerror import *
from application import *
from browser import *
import test
try:
    import webopenid as openid
except ImportError:
    pass # requires openid module

</t>
<t tx="zhanglei.20100830144432.1505">@language python
@tabwidth -4
@others
@ignore
if __name__ == "__main__":
    import doctest
    doctest.testmod()
</t>
<t tx="zhanglei.20100830144432.1506">"""
Network Utilities
(from web.py)
"""

__all__ = [
  "validipaddr", "validipport", "validip", "validaddr", 
  "urlquote",
  "httpdate", "parsehttpdate", 
  "htmlquote", "htmlunquote", "websafe",
]

import urllib, time
try: import datetime
except ImportError: pass

</t>
<t tx="zhanglei.20100830144432.1507">def validipaddr(address):
    """
    Returns True if `address` is a valid IPv4 address.

        &gt;&gt;&gt; validipaddr('192.168.1.1')
        True
        &gt;&gt;&gt; validipaddr('192.168.1.800')
        False
        &gt;&gt;&gt; validipaddr('192.168.1')
        False
    """
    try:
        octets = address.split('.')
        if len(octets) != 4:
            return False
        for x in octets:
            if not (0 &lt;= int(x) &lt;= 255):
                return False
    except ValueError:
        return False
    return True

</t>
<t tx="zhanglei.20100830144432.1508">def validipport(port):
    """
    Returns True if `port` is a valid IPv4 port.

        &gt;&gt;&gt; validipport('9000')
        True
        &gt;&gt;&gt; validipport('foo')
        False
        &gt;&gt;&gt; validipport('1000000')
        False
    """
    try:
        if not (0 &lt;= int(port) &lt;= 65535):
            return False
    except ValueError:
        return False
    return True

</t>
<t tx="zhanglei.20100830144432.1509">def validip(ip, defaultaddr="0.0.0.0", defaultport=8080):
    """Returns `(ip_address, port)` from string `ip_addr_port`"""
    addr = defaultaddr
    port = defaultport

    ip = ip.split(":", 1)
    if len(ip) == 1:
        if not ip[0]:
            pass
        elif validipaddr(ip[0]):
            addr = ip[0]
        elif validipport(ip[0]):
            port = int(ip[0])
        else:
            raise ValueError, ':'.join(ip) + ' is not a valid IP address/port'
    elif len(ip) == 2:
        addr, port = ip
        if not validipaddr(addr) and validipport(port):
            raise ValueError, ':'.join(ip) + ' is not a valid IP address/port'
        port = int(port)
    else:
        raise ValueError, ':'.join(ip) + ' is not a valid IP address/port'
    return (addr, port)

</t>
<t tx="zhanglei.20100830144432.1510">def validaddr(string_):
    """
    Returns either (ip_address, port) or "/path/to/socket" from string_

        &gt;&gt;&gt; validaddr('/path/to/socket')
        '/path/to/socket'
        &gt;&gt;&gt; validaddr('8000')
        ('0.0.0.0', 8000)
        &gt;&gt;&gt; validaddr('127.0.0.1')
        ('127.0.0.1', 8080)
        &gt;&gt;&gt; validaddr('127.0.0.1:8000')
        ('127.0.0.1', 8000)
        &gt;&gt;&gt; validaddr('fff')
        Traceback (most recent call last):
            ...
        ValueError: fff is not a valid IP address/port
    """
    if '/' in string_:
        return string_
    else:
        return validip(string_)

</t>
<t tx="zhanglei.20100830144432.1511">def urlquote(val):
    """
    Quotes a string for use in a URL.

        &gt;&gt;&gt; urlquote('://?f=1&amp;j=1')
        '%3A//%3Ff%3D1%26j%3D1'
        &gt;&gt;&gt; urlquote(None)
        ''
        &gt;&gt;&gt; urlquote(u'\u203d')
        '%E2%80%BD'
    """
    if val is None: return ''
    if not isinstance(val, unicode): val = str(val)
    else: val = val.encode('utf-8')
    return urllib.quote(val)

</t>
<t tx="zhanglei.20100830144432.1512">def httpdate(date_obj):
    """
    Formats a datetime object for use in HTTP headers.

        &gt;&gt;&gt; import datetime
        &gt;&gt;&gt; httpdate(datetime.datetime(1970, 1, 1, 1, 1, 1))
        'Thu, 01 Jan 1970 01:01:01 GMT'
    """
    return date_obj.strftime("%a, %d %b %Y %H:%M:%S GMT")

</t>
<t tx="zhanglei.20100830144432.1513">def parsehttpdate(string_):
    """
    Parses an HTTP date into a datetime object.

        &gt;&gt;&gt; parsehttpdate('Thu, 01 Jan 1970 01:01:01 GMT')
        datetime.datetime(1970, 1, 1, 1, 1, 1)
    """
    try:
        t = time.strptime(string_, "%a, %d %b %Y %H:%M:%S %Z")
    except ValueError:
        return None
    return datetime.datetime(*t[:6])

</t>
<t tx="zhanglei.20100830144432.1514">def htmlquote(text):
    """
    Encodes `text` for raw use in HTML.

        &gt;&gt;&gt; htmlquote("&lt;'&amp;\\"&gt;")
        '&amp;lt;&amp;#39;&amp;amp;&amp;quot;&amp;gt;'
    """
    text = text.replace("&amp;", "&amp;amp;") # Must be done first!
    text = text.replace("&lt;", "&amp;lt;")
    text = text.replace("&gt;", "&amp;gt;")
    text = text.replace("'", "&amp;#39;")
    text = text.replace('"', "&amp;quot;")
    return text

</t>
<t tx="zhanglei.20100830144432.1515">def htmlunquote(text):
    """
    Decodes `text` that's HTML quoted.

        &gt;&gt;&gt; htmlunquote('&amp;lt;&amp;#39;&amp;amp;&amp;quot;&amp;gt;')
        '&lt;\\'&amp;"&gt;'
    """
    text = text.replace("&amp;quot;", '"')
    text = text.replace("&amp;#39;", "'")
    text = text.replace("&amp;gt;", "&gt;")
    text = text.replace("&amp;lt;", "&lt;")
    text = text.replace("&amp;amp;", "&amp;") # Must be done last!
    return text

</t>
<t tx="zhanglei.20100830144432.1516">def websafe(val):
    """
    Converts `val` so that it's safe for use in UTF-8 HTML.

        &gt;&gt;&gt; websafe("&lt;'&amp;\\"&gt;")
        '&amp;lt;&amp;#39;&amp;amp;&amp;quot;&amp;gt;'
        &gt;&gt;&gt; websafe(None)
        ''
        &gt;&gt;&gt; websafe(u'\u203d')
        '\\xe2\\x80\\xbd'
    """
    if val is None:
        return ''
    if isinstance(val, unicode):
        val = val.encode('utf-8')
    val = str(val)
    return htmlquote(val)

</t>
<t tx="zhanglei.20100830144432.1517">@ignore
@language unknown_language
[default]
projectname = python,

</t>
<t tx="zhanglei.20100830144432.1518">@language python
@tabwidth -4
@others
@ignore
if __name__ == '__main__' :
    import doctest
    doctest.testmod()
</t>
<t tx="zhanglei.20100830144432.1519">"""
Session Management
(from web.py)
"""

import os, time, datetime, random, base64
try:
    import cPickle as pickle
except ImportError:
    import pickle
try:
    import hashlib
    sha1 = hashlib.sha1
except ImportError:
    import sha
    sha1 = sha.new

import utils
import webapi as web

__all__ = [
    'Session', 'SessionExpired',
    'Store', 'DiskStore', 'DBStore',
]

web.config.session_parameters = utils.storage({
    'cookie_name': 'webpy_session_id',
    'cookie_domain': None,
    'timeout': 86400, #24 * 60 * 60, # 24 hours in seconds
    'ignore_expiry': True,
    'ignore_change_ip': True,
    'secret_key': 'fLjUfxqXtfNoIldA0A0J',
    'expired_message': 'Session expired',
})

</t>
<t tx="zhanglei.20100830144432.1520">class SessionExpired(web.HTTPError): 
    @others
</t>
<t tx="zhanglei.20100830144432.1521">def __init__(self, message):
    web.HTTPError.__init__(self, '200 OK', {}, data=message)

</t>
<t tx="zhanglei.20100830144432.1522">class Session(utils.ThreadedDict):
    """Session management for web.py
    """
    @others
</t>
<t tx="zhanglei.20100830144432.1523">
def __init__(self, app, store, initializer=None):
    self.__dict__['store'] = store
    self.__dict__['_initializer'] = initializer
    self.__dict__['_last_cleanup_time'] = 0
    self.__dict__['_config'] = utils.storage(web.config.session_parameters)

    if app:
        app.add_processor(self._processor)

</t>
<t tx="zhanglei.20100830144432.1524">def _processor(self, handler):
    """Application processor to setup session for every request"""
    self._cleanup()
    self._load()

    try:
        return handler()
    finally:
        self._save()

</t>
<t tx="zhanglei.20100830144432.1525">def _load(self):
    """Load the session from the store, by the id from cookie"""
    cookie_name = self._config.cookie_name
    cookie_domain = self._config.cookie_domain
    self.session_id = web.cookies().get(cookie_name)

    # protection against session_id tampering
    if self.session_id and not self._valid_session_id(self.session_id):
        self.session_id = None

    self._check_expiry()
    if self.session_id:
        d = self.store[self.session_id]
        self.update(d)
        self._validate_ip()

    if not self.session_id:
        self.session_id = self._generate_session_id()

        if self._initializer:
            if isinstance(self._initializer, dict):
                self.update(self._initializer)
            elif hasattr(self._initializer, '__call__'):
                self._initializer()

    self.ip = web.ctx.ip

</t>
<t tx="zhanglei.20100830144432.1526">def _check_expiry(self):
    # check for expiry
    if self.session_id and self.session_id not in self.store:
        if self._config.ignore_expiry:
            self.session_id = None
        else:
            return self.expired()

</t>
<t tx="zhanglei.20100830144432.1527">def _validate_ip(self):
    # check for change of IP
    if self.session_id and self.get('ip', None) != web.ctx.ip:
        if not self._config.ignore_change_ip:
           return self.expired() 

</t>
<t tx="zhanglei.20100830144432.1528">def _save(self):
    cookie_name = self._config.cookie_name
    cookie_domain = self._config.cookie_domain
    if not self.get('_killed'):
        web.setcookie(cookie_name, self.session_id, domain=cookie_domain)
        self.store[self.session_id] = dict(self)
    else:
        web.setcookie(cookie_name, self.session_id, expires=-1, domain=cookie_domain)

</t>
<t tx="zhanglei.20100830144432.1529">def _generate_session_id(self):
    """Generate a random id for session"""

    while True:
        rand = os.urandom(16)
        now = time.time()
        secret_key = self._config.secret_key
        session_id = sha1("%s%s%s%s" %(rand, now, utils.safestr(web.ctx.ip), secret_key))
        session_id = session_id.hexdigest()
        if session_id not in self.store:
            break
    return session_id

</t>
<t tx="zhanglei.20100830144432.1530">def _valid_session_id(self, session_id):
    rx = utils.re_compile('^[0-9a-fA-F]+$')
    return rx.match(session_id)

</t>
<t tx="zhanglei.20100830144432.1531">def _cleanup(self):
    """Cleanup the stored sessions"""
    current_time = time.time()
    timeout = self._config.timeout
    if current_time - self._last_cleanup_time &gt; timeout:
        self.store.cleanup(timeout)
        self.__dict__['_last_cleanup_time'] = current_time

</t>
<t tx="zhanglei.20100830144432.1532">def expired(self):
    """Called when an expired session is atime"""
    self._killed = True
    self._save()
    raise SessionExpired(self._config.expired_message)

</t>
<t tx="zhanglei.20100830144432.1533">def kill(self):
    """Kill the session, make it no longer available"""
    del self.store[self.session_id]
    self._killed = True

</t>
<t tx="zhanglei.20100830144432.1534">class Store:
    """Base class for session stores"""
    @others
</t>
<t tx="zhanglei.20100830144432.1535">
def __contains__(self, key):
    raise NotImplementedError

</t>
<t tx="zhanglei.20100830144432.1536">def __getitem__(self, key):
    raise NotImplementedError

</t>
<t tx="zhanglei.20100830144432.1537">def __setitem__(self, key, value):
    raise NotImplementedError

</t>
<t tx="zhanglei.20100830144432.1538">def cleanup(self, timeout):
    """removes all the expired sessions"""
    raise NotImplementedError

</t>
<t tx="zhanglei.20100830144432.1539">def encode(self, session_dict):
    """encodes session dict as a string"""
    pickled = pickle.dumps(session_dict)
    return base64.encodestring(pickled)

</t>
<t tx="zhanglei.20100830144432.1540">def decode(self, session_data):
    """decodes the data to get back the session dict """
    pickled = base64.decodestring(session_data)
    return pickle.loads(pickled)

</t>
<t tx="zhanglei.20100830144432.1541">class DiskStore(Store):
    """
    Store for saving a session on disk.

        &gt;&gt;&gt; import tempfile
        &gt;&gt;&gt; root = tempfile.mkdtemp()
        &gt;&gt;&gt; s = DiskStore(root)
        &gt;&gt;&gt; s['a'] = 'foo'
        &gt;&gt;&gt; s['a']
        'foo'
        &gt;&gt;&gt; time.sleep(0.01)
        &gt;&gt;&gt; s.cleanup(0.01)
        &gt;&gt;&gt; s['a']
        Traceback (most recent call last):
            ...
        KeyError: 'a'
    """
    @others
</t>
<t tx="zhanglei.20100830144432.1542">def __init__(self, root):
    # if the storage root doesn't exists, create it.
    if not os.path.exists(root):
        os.mkdir(root)
    self.root = root

</t>
<t tx="zhanglei.20100830144432.1543">def _get_path(self, key):
    if os.path.sep in key: 
        raise ValueError, "Bad key: %s" % repr(key)
    return os.path.join(self.root, key)

</t>
<t tx="zhanglei.20100830144432.1544">def __contains__(self, key):
    path = self._get_path(key)
    return os.path.exists(path)

</t>
<t tx="zhanglei.20100830144432.1545">def __getitem__(self, key):
    path = self._get_path(key)
    if os.path.exists(path): 
        pickled = open(path).read()
        return self.decode(pickled)
    else:
        raise KeyError, key

</t>
<t tx="zhanglei.20100830144432.1546">def __setitem__(self, key, value):
    path = self._get_path(key)
    pickled = self.encode(value)    
    try:
        f = open(path, 'w')
        try:
            f.write(pickled)
        finally: 
            f.close()
    except IOError:
        pass

</t>
<t tx="zhanglei.20100830144432.1547">def __delitem__(self, key):
    path = self._get_path(key)
    if os.path.exists(path):
        os.remove(path)

</t>
<t tx="zhanglei.20100830144432.1548">def cleanup(self, timeout):
    now = time.time()
    for f in os.listdir(self.root):
        path = self._get_path(f)
        atime = os.stat(path).st_atime
        if now - atime &gt; timeout :
            os.remove(path)

</t>
<t tx="zhanglei.20100830144432.1549">class DBStore(Store):
    """Store for saving a session in database
    Needs a table with the following columns:

        session_id CHAR(128) UNIQUE NOT NULL,
        atime DATETIME NOT NULL default current_timestamp,
        data TEXT
    """
    @others
</t>
<t tx="zhanglei.20100830144432.1550">def __init__(self, db, table_name):
    self.db = db
    self.table = table_name

</t>
<t tx="zhanglei.20100830144432.1551">def __contains__(self, key):
    data = self.db.select(self.table, where="session_id=$key", vars=locals())
    return bool(list(data)) 

</t>
<t tx="zhanglei.20100830144432.1552">def __getitem__(self, key):
    now = datetime.datetime.now()
    try:
        s = self.db.select(self.table, where="session_id=$key", vars=locals())[0]
        self.db.update(self.table, where="session_id=$key", atime=now, vars=locals())
    except IndexError:
        raise KeyError
    else:
        return self.decode(s.data)

</t>
<t tx="zhanglei.20100830144432.1553">def __setitem__(self, key, value):
    pickled = self.encode(value)
    now = datetime.datetime.now()
    if key in self:
        self.db.update(self.table, where="session_id=$key", data=pickled, vars=locals())
    else:
        self.db.insert(self.table, False, session_id=key, data=pickled )

</t>
<t tx="zhanglei.20100830144432.1554">def __delitem__(self, key):
    self.db.delete(self.table, where="session_id=$key", vars=locals())

</t>
<t tx="zhanglei.20100830144432.1555">def cleanup(self, timeout):
    timeout = datetime.timedelta(timeout/(24.0*60*60)) #timedelta takes numdays as arg
    last_allowed_time = datetime.datetime.now() - timeout
    self.db.delete(self.table, where="$last_allowed_time &gt; atime", vars=locals())

</t>
<t tx="zhanglei.20100830144432.1556">class ShelfStore:
    """Store for saving session using `shelve` module.

        import shelve
        store = ShelfStore(shelve.open('session.shelf'))

    XXX: is shelve thread-safe?
    """
    @others
</t>
<t tx="zhanglei.20100830144432.1557">def __init__(self, shelf):
    self.shelf = shelf

</t>
<t tx="zhanglei.20100830144432.1558">def __contains__(self, key):
    return key in self.shelf

</t>
<t tx="zhanglei.20100830144432.1559">def __getitem__(self, key):
    atime, v = self.shelf[key]
    self[key] = v # update atime
    return v

</t>
<t tx="zhanglei.20100830144432.1560">def __setitem__(self, key, value):
    self.shelf[key] = time.time(), value

</t>
<t tx="zhanglei.20100830144432.1561">def __delitem__(self, key):
    try:
        del self.shelf[key]
    except KeyError:
        pass

</t>
<t tx="zhanglei.20100830144432.1562">def cleanup(self, timeout):
    now = time.time()
    for k in self.shelf.keys():
        atime, v = self.shelf[k]
        if now - atime &gt; timeout :
            del self[k]

</t>
<t tx="zhanglei.20100830144432.1563">@language python
@tabwidth -4
@others
@ignore
if __name__ == "__main__":
    import sys
    if '--compile' in sys.argv:
        compile_templates(sys.argv[2])
    else:
        import doctest
        doctest.testmod()
</t>
<t tx="zhanglei.20100830144432.1564">"""
simple, elegant templating
(part of web.py)

Template design:

Template string is split into tokens and the tokens are combined into nodes. 
Parse tree is a nodelist. TextNode and ExpressionNode are simple nodes and 
for-loop, if-loop etc are block nodes, which contain multiple child nodes. 

Each node can emit some python string. python string emitted by the 
root node is validated for safeeval and executed using python in the given environment.

Enough care is taken to make sure the generated code and the template has line to line match, 
so that the error messages can point to exact line number in template. (It doesn't work in some cases still.)

Grammar:

    template -&gt; defwith sections 
    defwith -&gt; '$def with (' arguments ')' | ''
    sections -&gt; section*
    section -&gt; block | assignment | line

    assignment -&gt; '$ ' &lt;assignment expression&gt;
    line -&gt; (text|expr)*
    text -&gt; &lt;any characters other than $&gt;
    expr -&gt; '$' pyexpr | '$(' pyexpr ')' | '${' pyexpr '}'
    pyexpr -&gt; &lt;python expression&gt;

"""

__all__ = [
    "Template",
    "Render", "render", "frender",
    "ParseError", "SecurityError",
    "test"
]

import tokenize
import os
import glob
import re

from utils import storage, safeunicode, safestr, re_compile
from webapi import config
from net import websafe

</t>
<t tx="zhanglei.20100830144432.1565">def splitline(text):
    r"""
    Splits the given text at newline.

        &gt;&gt;&gt; splitline('foo\nbar')
        ('foo\n', 'bar')
        &gt;&gt;&gt; splitline('foo')
        ('foo', '')
        &gt;&gt;&gt; splitline('')
        ('', '')
    """
    index = text.find('\n') + 1
    if index:
        return text[:index], text[index:]
    else:
        return text, ''

</t>
<t tx="zhanglei.20100830144432.1566">class Parser:
    """Parser Base.
    """
    @others
</t>
<t tx="zhanglei.20100830144432.1567">def __init__(self, text, name="&lt;template&gt;"):
    self.text = text
    self.name = name

</t>
<t tx="zhanglei.20100830144432.1568">def parse(self):
    text = self.text
    defwith, text = self.read_defwith(text)
    suite = self.read_suite(text)
    return DefwithNode(defwith, suite)

</t>
<t tx="zhanglei.20100830144432.1569">def read_defwith(self, text):
    if text.startswith('$def with'):
        defwith, text = splitline(text)
        defwith = defwith[1:].strip() # strip $ and spaces
        return defwith, text
    else:
        return '', text

</t>
<t tx="zhanglei.20100830144432.1570">def read_section(self, text):
    r"""Reads one section from the given text.

    section -&gt; block | assignment | line

        &gt;&gt;&gt; read_section = Parser('').read_section
        &gt;&gt;&gt; read_section('foo\nbar\n')
        (&lt;line: [t'foo\n']&gt;, 'bar\n')
        &gt;&gt;&gt; read_section('$ a = b + 1\nfoo\n')
        (&lt;assignment: 'a = b + 1'&gt;, 'foo\n')

    read_section('$for in range(10):\n    hello $i\nfoo)
    """
    if text.lstrip(' ').startswith('$'):
        index = text.index('$')
        begin_indent, text2 = text[:index], text[index+1:]
        ahead = self.python_lookahead(text2)

        if ahead == 'var':
            return self.read_var(text2)
        elif ahead in STATEMENT_NODES:
            return self.read_block_section(text2, begin_indent)
        elif ahead in KEYWORDS:
            return self.read_keyword(text2)
        elif ahead.strip() == '':
            # assignments starts with a space after $
            # ex: $ a = b + 2
            return self.read_assignment(text2)
    return self.readline(text)

</t>
<t tx="zhanglei.20100830144432.1571">def read_var(self, text):
    r"""Reads a var statement.

        &gt;&gt;&gt; read_var = Parser('').read_var
        &gt;&gt;&gt; read_var('var x=10\nfoo')
        (&lt;var: x = 10&gt;, 'foo')
        &gt;&gt;&gt; read_var('var x: hello $name\nfoo')
        (&lt;var: x = join_('hello ', escape_(name, True))&gt;, 'foo')
    """
    line, text = splitline(text)
    tokens = self.python_tokens(line)
    if len(tokens) &lt; 4:
        raise SyntaxError('Invalid var statement')

    name = tokens[1]
    sep = tokens[2]
    value = line.split(sep, 1)[1].strip()

    if sep == '=':
        pass # no need to process value
    elif sep == ':': 
        #@@ Hack for backward-compatability
        if tokens[3] == '\n': # multi-line var statement
            block, text = self.read_indented_block(text, '    ')
            lines = [self.readline(x)[0] for x in block.splitlines()]
            nodes = []
            for x in lines:
                nodes.extend(x.nodes)
                nodes.append(TextNode('\n'))         
        else: # single-line var statement
            linenode, _ = self.readline(value)
            nodes = linenode.nodes                
        parts = [node.emit('') for node in nodes]
        value = "join_(%s)" % ", ".join(parts)
    else:
        raise SyntaxError('Invalid var statement')
    return VarNode(name, value), text

</t>
<t tx="zhanglei.20100830144432.1572">def read_suite(self, text):
    r"""Reads section by section till end of text.

        &gt;&gt;&gt; read_suite = Parser('').read_suite
        &gt;&gt;&gt; read_suite('hello $name\nfoo\n')
        [&lt;line: [t'hello ', $name, t'\n']&gt;, &lt;line: [t'foo\n']&gt;]
    """
    sections = []
    while text:
        section, text = self.read_section(text)
        sections.append(section)
    return SuiteNode(sections)

</t>
<t tx="zhanglei.20100830144432.1573">def readline(self, text):
    r"""Reads one line from the text. Newline is supressed if the line ends with \.

        &gt;&gt;&gt; readline = Parser('').readline
        &gt;&gt;&gt; readline('hello $name!\nbye!')
        (&lt;line: [t'hello ', $name, t'!\n']&gt;, 'bye!')
        &gt;&gt;&gt; readline('hello $name!\\\nbye!')
        (&lt;line: [t'hello ', $name, t'!']&gt;, 'bye!')
        &gt;&gt;&gt; readline('$f()\n\n')
        (&lt;line: [$f(), t'\n']&gt;, '\n')
    """
    line, text = splitline(text)

    # supress new line if line ends with \
    if line.endswith('\\\n'):
        line = line[:-2]

    nodes = []
    while line:
        node, line = self.read_node(line)
        nodes.append(node)

    return LineNode(nodes), text

</t>
<t tx="zhanglei.20100830144432.1574">def read_node(self, text):
    r"""Reads a node from the given text and returns the node and remaining text.

        &gt;&gt;&gt; read_node = Parser('').read_node
        &gt;&gt;&gt; read_node('hello $name')
        (t'hello ', '$name')
        &gt;&gt;&gt; read_node('$name')
        ($name, '')
    """
    if text.startswith('$$'):
        return TextNode('$'), text[2:]
    elif text.startswith('$#'): # comment
        line, text = splitline(text)
        return TextNode('\n'), text
    elif text.startswith('$'):
        text = text[1:] # strip $
        if text.startswith(':'):
            escape = False
            text = text[1:] # strip :
        else:
            escape = True
        return self.read_expr(text, escape=escape)
    else:
        return self.read_text(text)

</t>
<t tx="zhanglei.20100830144432.1575">def read_text(self, text):
    r"""Reads a text node from the given text.

        &gt;&gt;&gt; read_text = Parser('').read_text
        &gt;&gt;&gt; read_text('hello $name')
        (t'hello ', '$name')
    """
    index = text.find('$')
    if index &lt; 0:
        return TextNode(text), ''
    else:
        return TextNode(text[:index]), text[index:]

</t>
<t tx="zhanglei.20100830144432.1576">def read_keyword(self, text):
    line, text = splitline(text)
    return CodeNode(None, line.strip() + "\n"), text

</t>
<t tx="zhanglei.20100830144432.1577">def read_expr(self, text, escape=True):
    """Reads a python expression from the text and returns the expression and remaining text.

    expr -&gt; simple_expr | paren_expr
    simple_expr -&gt; id extended_expr
    extended_expr -&gt; attr_access | paren_expr extended_expr | ''
    attr_access -&gt; dot id extended_expr
    paren_expr -&gt; [ tokens ] | ( tokens ) | { tokens }

        &gt;&gt;&gt; read_expr = Parser('').read_expr
        &gt;&gt;&gt; read_expr("name")
        ($name, '')
        &gt;&gt;&gt; read_expr("a.b and c")
        ($a.b, ' and c')
        &gt;&gt;&gt; read_expr("a. b")
        ($a, '. b')
        &gt;&gt;&gt; read_expr("name&lt;/h1&gt;")
        ($name, '&lt;/h1&gt;')
        &gt;&gt;&gt; read_expr("(limit)ing")
        ($(limit), 'ing')
        &gt;&gt;&gt; read_expr('a[1, 2][:3].f(1+2, "weird string[).", 3 + 4) done.')
        ($a[1, 2][:3].f(1+2, "weird string[).", 3 + 4), ' done.')
    """
    def simple_expr():
        identifier()
        extended_expr()

    def identifier():
        tokens.next()

    def extended_expr():
        lookahead = tokens.lookahead()
        if lookahead is None:
            return
        elif lookahead.value == '.':
            attr_access()
        elif lookahead.value in parens:
            paren_expr()
            extended_expr()
        else:
            return

    def attr_access():
        from token import NAME # python token constants
        dot = tokens.lookahead()
        if tokens.lookahead2().type == NAME:
            tokens.next() # consume dot
            identifier()
            extended_expr()

    def paren_expr():
        begin = tokens.next().value
        end = parens[begin]
        while True:
            if tokens.lookahead().value in parens:
                paren_expr()
            else:
                t = tokens.next()
                if t.value == end:
                    break
        return

    parens = {
        "(": ")",
        "[": "]",
        "{": "}"
    }

    def get_tokens(text):
        """tokenize text using python tokenizer.
        Python tokenizer ignores spaces, but they might be important in some cases. 
        This function introduces dummy space tokens when it identifies any ignored space.
        Each token is a storage object containing type, value, begin and end.
        """
        readline = iter([text]).next
        end = None
        for t in tokenize.generate_tokens(readline):
            t = storage(type=t[0], value=t[1], begin=t[2], end=t[3])
            if end is not None and end != t.begin:
                _, x1 = end
                _, x2 = t.begin
                yield storage(type=-1, value=text[x1:x2], begin=end, end=t.begin)
            end = t.end
            yield t

    class BetterIter:
        """Iterator like object with 2 support for 2 look aheads."""
        def __init__(self, items):
            self.iteritems = iter(items)
            self.items = []
            self.position = 0
            self.current_item = None

        def lookahead(self):
            if len(self.items) &lt;= self.position:
                self.items.append(self._next())
            return self.items[self.position]

        def _next(self):
            try:
                return self.iteritems.next()
            except StopIteration:
                return None

        def lookahead2(self):
            if len(self.items) &lt;= self.position+1:
                self.items.append(self._next())
            return self.items[self.position+1]

        def next(self):
            self.current_item = self.lookahead()
            self.position += 1
            return self.current_item

    tokens = BetterIter(get_tokens(text))

    if tokens.lookahead().value in parens:
        paren_expr()
    else:
        simple_expr()
    row, col = tokens.current_item.end
    return ExpressionNode(text[:col], escape=escape), text[col:]    

</t>
<t tx="zhanglei.20100830144432.1578">def read_assignment(self, text):
    r"""Reads assignment statement from text.

        &gt;&gt;&gt; read_assignment = Parser('').read_assignment
        &gt;&gt;&gt; read_assignment('a = b + 1\nfoo')
        (&lt;assignment: 'a = b + 1'&gt;, 'foo')
    """
    line, text = splitline(text)
    return AssignmentNode(line.strip()), text

</t>
<t tx="zhanglei.20100830144432.1579">def python_lookahead(self, text):
    """Returns the first python token from the given text.

        &gt;&gt;&gt; python_lookahead = Parser('').python_lookahead
        &gt;&gt;&gt; python_lookahead('for i in range(10):')
        'for'
        &gt;&gt;&gt; python_lookahead('else:')
        'else'
        &gt;&gt;&gt; python_lookahead(' x = 1')
        ' '
    """
    readline = iter([text]).next
    tokens = tokenize.generate_tokens(readline)
    return tokens.next()[1]

</t>
<t tx="zhanglei.20100830144432.1580">def python_tokens(self, text):
    readline = iter([text]).next
    tokens = tokenize.generate_tokens(readline)
    return [t[1] for t in tokens]

</t>
<t tx="zhanglei.20100830144432.1581">def read_indented_block(self, text, indent):
    r"""Read a block of text. A block is what typically follows a for or it statement.
    It can be in the same line as that of the statement or an indented block.

        &gt;&gt;&gt; read_indented_block = Parser('').read_indented_block
        &gt;&gt;&gt; read_indented_block('  a\n  b\nc', '  ')
        ('a\nb\n', 'c')
        &gt;&gt;&gt; read_indented_block('  a\n    b\n  c\nd', '  ')
        ('a\n  b\nc\n', 'd')
        &gt;&gt;&gt; read_indented_block('  a\n\n    b\nc', '  ')
        ('a\n\n  b\n', 'c')
    """
    if indent == '':
        return '', text

    block = ""
    while text:
        line, text2 = splitline(text)
        if line.strip() == "":
            block += '\n'
        elif line.startswith(indent):
            block += line[len(indent):]
        else:
            break
        text = text2
    return block, text

</t>
<t tx="zhanglei.20100830144432.1582">def read_statement(self, text):
    r"""Reads a python statement.

        &gt;&gt;&gt; read_statement = Parser('').read_statement
        &gt;&gt;&gt; read_statement('for i in range(10): hello $name')
        ('for i in range(10):', ' hello $name')
    """
    tok = PythonTokenizer(text)
    tok.consume_till(':')
    return text[:tok.index], text[tok.index:]

</t>
<t tx="zhanglei.20100830144432.1583">def read_block_section(self, text, begin_indent=''):
    r"""
        &gt;&gt;&gt; read_block_section = Parser('').read_block_section
        &gt;&gt;&gt; read_block_section('for i in range(10): hello $i\nfoo')
        (&lt;block: 'for i in range(10):', [&lt;line: [t'hello ', $i, t'\n']&gt;]&gt;, 'foo')
        &gt;&gt;&gt; read_block_section('for i in range(10):\n        hello $i\n    foo', begin_indent='    ')
        (&lt;block: 'for i in range(10):', [&lt;line: [t'hello ', $i, t'\n']&gt;]&gt;, '    foo')
        &gt;&gt;&gt; read_block_section('for i in range(10):\n  hello $i\nfoo')
        (&lt;block: 'for i in range(10):', [&lt;line: [t'hello ', $i, t'\n']&gt;]&gt;, 'foo')
    """
    line, text = splitline(text)
    stmt, line = self.read_statement(line)
    keyword = self.python_lookahead(stmt)

    # if there is some thing left in the line
    if line.strip():
        block = line.lstrip()
    else:
        def find_indent(text):
            rx = re_compile('  +')
            match = rx.match(text)    
            first_indent = match and match.group(0)
            return first_indent or ""

        # find the indentation of the block by looking at the first line
        first_indent = find_indent(text)[len(begin_indent):]
        indent = begin_indent + min(first_indent, INDENT)

        block, text = self.read_indented_block(text, indent)

    return self.create_block_node(keyword, stmt, block, begin_indent), text

</t>
<t tx="zhanglei.20100830144432.1584">def create_block_node(self, keyword, stmt, block, begin_indent):
    if keyword in STATEMENT_NODES:
        return STATEMENT_NODES[keyword](stmt, block, begin_indent)
    else:
        raise ParseError, 'Unknown statement: %s' % repr(keyword)

</t>
<t tx="zhanglei.20100830144432.1585">class PythonTokenizer:
    """Utility wrapper over python tokenizer."""
    @others
</t>
<t tx="zhanglei.20100830144432.1586">def __init__(self, text):
    self.text = text
    readline = iter([text]).next
    self.tokens = tokenize.generate_tokens(readline)
    self.index = 0

</t>
<t tx="zhanglei.20100830144432.1587">def consume_till(self, delim):        
    """Consumes tokens till colon.

        &gt;&gt;&gt; tok = PythonTokenizer('for i in range(10): hello $i')
        &gt;&gt;&gt; tok.consume_till(':')
        &gt;&gt;&gt; tok.text[:tok.index]
        'for i in range(10):'
        &gt;&gt;&gt; tok.text[tok.index:]
        ' hello $i'
    """
    try:
        while True:
            t = self.next()
            if t.value == delim:
                break
            elif t.value == '(':
                self.consume_till(')')
            elif t.value == '[':
                self.consume_till(']')
            elif t.value == '{':
                self.consume_till('}')

            # if end of line is found, it is an exception.
            # Since there is no easy way to report the line number,
            # leave the error reporting to the python parser later  
            #@@ This should be fixed.
            if t.value == '\n':
                break
    except:
        #raise ParseError, "Expected %s, found end of line." % repr(delim)

        # raising ParseError doesn't show the line number. 
        # if this error is ignored, then it will be caught when compiling the python code.
        return

</t>
<t tx="zhanglei.20100830144432.1588">def next(self):
    type, t, begin, end, line = self.tokens.next()
    row, col = end
    self.index = col
    return storage(type=type, value=t, begin=begin, end=end)

</t>
<t tx="zhanglei.20100830144432.1589">class DefwithNode:
    @others
</t>
<t tx="zhanglei.20100830144432.1590">def __init__(self, defwith, suite):
    if defwith:
        self.defwith = defwith.replace('with', '__template__') + ':'
    else:
        self.defwith = 'def __template__():'
    self.suite = suite

</t>
<t tx="zhanglei.20100830144432.1591">def emit(self, indent):
    return self.defwith + self.suite.emit(indent + INDENT)

</t>
<t tx="zhanglei.20100830144432.1592">def __repr__(self):
    return "&lt;defwith: %s, %s&gt;" % (self.defwith, self.nodes)

</t>
<t tx="zhanglei.20100830144432.1593">class TextNode:
    @others
</t>
<t tx="zhanglei.20100830144432.1594">def __init__(self, value):
    self.value = value

</t>
<t tx="zhanglei.20100830144432.1595">def emit(self, indent):
    return repr(self.value)

</t>
<t tx="zhanglei.20100830144432.1596">def __repr__(self):
    return 't' + repr(self.value)

</t>
<t tx="zhanglei.20100830144432.1597">class ExpressionNode:
    @others
</t>
<t tx="zhanglei.20100830144432.1598">def __init__(self, value, escape=True):
    self.value = value.strip()

    # convert ${...} to $(...)
    if value.startswith('{') and value.endswith('}'):
        self.value = '(' + self.value[1:-1] + ')'

    self.escape = escape

</t>
<t tx="zhanglei.20100830144432.1599">def emit(self, indent):
    return 'escape_(%s, %s)' % (self.value, bool(self.escape))

</t>
<t tx="zhanglei.20100830144432.1600">def __repr__(self):
    if self.escape:
        escape = ''
    else:
        escape = ':'
    return "$%s%s" % (escape, self.value)

</t>
<t tx="zhanglei.20100830144432.1601">class AssignmentNode:
    @others
</t>
<t tx="zhanglei.20100830144432.1602">def __init__(self, code):
    self.code = code

</t>
<t tx="zhanglei.20100830144432.1603">def emit(self, indent, begin_indent=''):
    return indent + self.code + "\n"

</t>
<t tx="zhanglei.20100830144432.1604">def __repr__(self):
    return "&lt;assignment: %s&gt;" % repr(self.code)

</t>
<t tx="zhanglei.20100830144432.1605">class LineNode:
    @others
</t>
<t tx="zhanglei.20100830144432.1606">def __init__(self, nodes):
    self.nodes = nodes

</t>
<t tx="zhanglei.20100830144432.1607">def emit(self, indent, text_indent='', name=''):
    text = [node.emit('') for node in self.nodes]
    if text_indent:
        text = [repr(text_indent)] + text
    return indent + 'yield %s, join_(%s)\n' % (repr(name), ', '.join(text))

</t>
<t tx="zhanglei.20100830144432.1608">def __repr__(self):
    return "&lt;line: %s&gt;" % repr(self.nodes)

</t>
<t tx="zhanglei.20100830144432.1609">INDENT = '    ' # 4 spaces

class BlockNode:
    @others
</t>
<t tx="zhanglei.20100830144432.1610">def __init__(self, stmt, block, begin_indent=''):
    self.stmt = stmt
    self.suite = Parser('').read_suite(block)
    self.begin_indent = begin_indent

</t>
<t tx="zhanglei.20100830144432.1611">def emit(self, indent, text_indent=''):
    text_indent = self.begin_indent + text_indent
    out = indent + self.stmt + self.suite.emit(indent + INDENT, text_indent)
    return out

</t>
<t tx="zhanglei.20100830144432.1612">def text(self):
    return '${' + self.stmt + '}' + "".join([node.text(indent) for node in self.nodes])

</t>
<t tx="zhanglei.20100830144432.1613">def __repr__(self):
    return "&lt;block: %s, %s&gt;" % (repr(self.stmt), repr(self.nodelist))

</t>
<t tx="zhanglei.20100830144432.1614">class ForNode(BlockNode):
    @others
</t>
<t tx="zhanglei.20100830144432.1615">def __init__(self, stmt, block, begin_indent=''):
    self.original_stmt = stmt
    tok = PythonTokenizer(stmt)
    tok.consume_till('in')
    a = stmt[:tok.index] # for i in
    b = stmt[tok.index:-1] # rest of for stmt excluding :
    stmt = a + ' loop.setup(' + b.strip() + '):'
    BlockNode.__init__(self, stmt, block, begin_indent)

</t>
<t tx="zhanglei.20100830144432.1616">def __repr__(self):
    return "&lt;block: %s, %s&gt;" % (repr(self.original_stmt), repr(self.suite))

</t>
<t tx="zhanglei.20100830144432.1617">class CodeNode:
    @others
</t>
<t tx="zhanglei.20100830144432.1618">def __init__(self, stmt, block, begin_indent=''):
    self.code = block

</t>
<t tx="zhanglei.20100830144432.1619">def emit(self, indent, text_indent=''):
    import re
    rx = re.compile('^', re.M)
    return rx.sub(indent, self.code).rstrip(' ')

</t>
<t tx="zhanglei.20100830144432.1620">def __repr__(self):
    return "&lt;code: %s&gt;" % repr(self.code)

</t>
<t tx="zhanglei.20100830144432.1621">class IfNode(BlockNode):
    pass

</t>
<t tx="zhanglei.20100830144432.1622">class ElseNode(BlockNode):
    pass

</t>
<t tx="zhanglei.20100830144432.1623">class ElifNode(BlockNode):
    pass

</t>
<t tx="zhanglei.20100830144432.1624">class DefNode(BlockNode):
    pass

</t>
<t tx="zhanglei.20100830144432.1625">class VarNode:
    @others
</t>
<t tx="zhanglei.20100830144432.1626">def __init__(self, name, value):
    self.name = name
    self.value = value

</t>
<t tx="zhanglei.20100830144432.1627">def emit(self, indent, text_indent):
    return indent + 'yield %s, %s\n' % (repr(self.name), self.value)

</t>
<t tx="zhanglei.20100830144432.1628">def __repr__(self):
    return "&lt;var: %s = %s&gt;" % (self.name, self.value)

</t>
<t tx="zhanglei.20100830144432.1629">class SuiteNode:
    """Suite is a list of sections."""
    @others
</t>
<t tx="zhanglei.20100830144432.1630">def __init__(self, sections):
    self.sections = sections

</t>
<t tx="zhanglei.20100830144432.1631">def emit(self, indent, text_indent=''):
    return "\n" + "".join([s.emit(indent, text_indent) for s in self.sections])

</t>
<t tx="zhanglei.20100830144432.1632">def __repr__(self):
    return repr(self.sections)

</t>
<t tx="zhanglei.20100830144432.1633">STATEMENT_NODES = {
    'for': ForNode,
    'while': BlockNode,
    'if': IfNode,
    'elif': ElifNode,
    'else': ElseNode,
    'def': DefNode,
    'code': CodeNode
}

KEYWORDS = [
    "pass",
    "break",
    "continue",
    "return"
]

TEMPLATE_BUILTIN_NAMES = [
    "dict", "enumerate", "float", "int", "bool", "list", "long", "reversed", 
    "set", "slice", "tuple", "xrange",
    "abs", "all", "any", "callable", "chr", "cmp", "divmod", "filter", "hex", 
    "id", "isinstance", "iter", "len", "max", "min", "oct", "ord", "pow", "range",
    "True", "False",
    "None",
    "__import__", # some c-libraries like datetime requires __import__ to present in the namespace
]

import __builtin__
TEMPLATE_BUILTINS = dict([(name, getattr(__builtin__, name)) for name in TEMPLATE_BUILTIN_NAMES if name in __builtin__.__dict__])

class ForLoop:
    """
    Wrapper for expression in for stament to support loop.xxx helpers.

        &gt;&gt;&gt; loop = ForLoop()
        &gt;&gt;&gt; for x in loop.setup(['a', 'b', 'c']):
        ...     print loop.index, loop.revindex, loop.parity, x
        ...
        1 3 odd a
        2 2 even b
        3 1 odd c
        &gt;&gt;&gt; loop.index
        Traceback (most recent call last):
            ...
        AttributeError: index
    """
    @others
</t>
<t tx="zhanglei.20100830144432.1634">def __init__(self):
    self._ctx = None

</t>
<t tx="zhanglei.20100830144432.1635">def __getattr__(self, name):
    if self._ctx is None:
        raise AttributeError, name
    else:
        return getattr(self._ctx, name)

</t>
<t tx="zhanglei.20100830144432.1636">def setup(self, seq):        
    self._push()
    return self._ctx.setup(seq)

</t>
<t tx="zhanglei.20100830144432.1637">def _push(self):
    self._ctx = ForLoopContext(self, self._ctx)

</t>
<t tx="zhanglei.20100830144432.1638">def _pop(self):
    self._ctx = self._ctx.parent

</t>
<t tx="zhanglei.20100830144432.1639">class ForLoopContext:
    """Stackable context for ForLoop to support nested for loops.
    """
    @others
</t>
<t tx="zhanglei.20100830144432.1640">def __init__(self, forloop, parent):
    self._forloop = forloop
    self.parent = parent

</t>
<t tx="zhanglei.20100830144432.1641">def setup(self, seq):
    if hasattr(seq, '__len__'):
        n = len(seq)
    else:
        n = 0

    self.index = 0
    seq = iter(seq)

    # Pre python-2.5 does not support yield in try-except.
    # This is a work-around to overcome that limitation.
    def next(seq):
        try:
            return seq.next()
        except:
            self._forloop._pop()
            raise

    while True:
        self._next(self.index + 1, n)
        yield next(seq)

</t>
<t tx="zhanglei.20100830144432.1642">def _next(self, i, n):
    self.index = i
    self.index0 = i - 1
    self.first = (i == 1)
    self.last = (i == n)
    self.odd = (i % 2 == 1)
    self.even = (i % 2 == 0)
    self.parity = ['odd', 'even'][self.even]
    if n:
        self.length = n
        self.revindex0 = n - i
        self.revindex = self.revindex0 + 1

</t>
<t tx="zhanglei.20100830144432.1643">class BaseTemplate:
    @others
</t>
<t tx="zhanglei.20100830144432.1644">def __init__(self, code, filename, filter, globals, builtins):
    self.filename = filename
    self.filter = filter
    self._globals = globals
    self._builtins = builtins
    if code:
        self.t = self._compile(code)
    else:
        self.t = lambda: ''

</t>
<t tx="zhanglei.20100830144432.1645">def _compile(self, code):
    env = self.make_env(self._globals or {}, self._builtins)
    exec(code, env)
    return env['__template__']

</t>
<t tx="zhanglei.20100830144432.1646">def __call__(self, *a, **kw):
    out = self.t(*a, **kw)
    return self._join_output(out)

</t>
<t tx="zhanglei.20100830144432.1647">def _join_output(self, out):
    d = TemplateResult()
    data = []

    for name, value in out:
        if name:
            d[name] = value
        else:
            data.append(value)

    d.__body__ = u"".join(data)
    return d       

</t>
<t tx="zhanglei.20100830144432.1648">def make_env(self, globals, builtins):
    return dict(globals,
        __builtins__=builtins, 
        loop=ForLoop(),
        escape_=self._escape,
        join_=self._join
    )

</t>
<t tx="zhanglei.20100830144432.1649">def _join(self, *items):
    return u"".join([safeunicode(item) for item in items])

</t>
<t tx="zhanglei.20100830144432.1650">def _escape(self, value, escape=False):
    import types
    if value is None: 
        value = ''
    elif isinstance(value, types.GeneratorType):
        value = self._join_output(value)

    value = safeunicode(value)
    if escape and self.filter:
        value = self.filter(value)
    return value

</t>
<t tx="zhanglei.20100830144432.1651">class Template(BaseTemplate):
    CONTENT_TYPES = {
        '.html' : 'text/html; charset=utf-8',
        '.xhtml' : 'application/xhtml+xml; charset=utf-8',
        '.txt' : 'text/plain',
    }
    FILTERS = {
        '.html': websafe,
        '.xhtml': websafe,
        '.xml': websafe
    }
    globals = {}

    @others
</t>
<t tx="zhanglei.20100830144432.1652">def __init__(self, text, filename='&lt;template&gt;', filter=None, globals=None, builtins=None):
    text = Template.normalize_text(text)
    code = self.compile_template(text, filename)

    _, ext = os.path.splitext(filename)
    filter = filter or self.FILTERS.get(ext, None)
    self.content_type = self.CONTENT_TYPES.get(ext, None)

    if globals is None:
        globals = self.globals
    if builtins is None:
        builtins = TEMPLATE_BUILTINS

    BaseTemplate.__init__(self, code=code, filename=filename, filter=filter, globals=globals, builtins=builtins)

</t>
<t tx="zhanglei.20100830144432.1653">def normalize_text(text):
    """Normalizes template text by correcting \r\n, tabs and BOM chars."""
    text = text.replace('\r\n', '\n').replace('\r', '\n').expandtabs()
    if not text.endswith('\n'):
        text += '\n'

    # ignore BOM chars at the begining of template
    BOM = '\xef\xbb\xbf'
    if isinstance(text, str) and text.startswith(BOM):
        text = text[len(BOM):]

    # support fort \$ for backward-compatibility 
    text = text.replace(r'\$', '$$')
    return text
</t>
<t tx="zhanglei.20100830144432.1654">normalize_text = staticmethod(normalize_text)

def __call__(self, *a, **kw):
    import webapi as web
    if 'headers' in web.ctx and self.content_type:
        web.header('Content-Type', self.content_type, unique=True)

    return BaseTemplate.__call__(self, *a, **kw)

</t>
<t tx="zhanglei.20100830144432.1655">def generate_code(text, filename):
    # parse the text
    rootnode = Parser(text, filename).parse()

    # generate python code from the parse tree
    code = rootnode.emit(indent="").strip()
    return safestr(code)

</t>
<t tx="zhanglei.20100830144432.1656">generate_code = staticmethod(generate_code)

def compile_template(self, template_string, filename):
    code = Template.generate_code(template_string, filename)

    def get_source_line(filename, lineno):
        try:
            lines = open(filename).read().splitlines()
            return lines[lineno]
        except:
            return None

    try:
        # compile the code first to report the errors, if any, with the filename
        compiled_code = compile(code, filename, 'exec')
    except SyntaxError, e:
        # display template line that caused the error along with the traceback.
        try:
            e.msg += '\n\nTemplate traceback:\n    File %s, line %s\n        %s' % \
                (repr(e.filename), e.lineno, get_source_line(e.filename, e.lineno-1))
        except: 
            pass
        raise

    # make sure code is safe
    import compiler
    ast = compiler.parse(code)
    SafeVisitor().walk(ast, filename)

    return compiled_code

</t>
<t tx="zhanglei.20100830144432.1657">class CompiledTemplate(Template):
    @others
</t>
<t tx="zhanglei.20100830144432.1658">def __init__(self, f, filename):
    Template.__init__(self, '', filename)
    self.t = f

</t>
<t tx="zhanglei.20100830144432.1659">def compile_template(self, *a):
    return None

</t>
<t tx="zhanglei.20100830144432.1660">def _compile(self, *a):
    return None

</t>
<t tx="zhanglei.20100830144432.1661">class Render:
    """The most preferred way of using templates.

        render = web.template.render('templates')
        print render.foo()

    Optional parameter can be `base` can be used to pass output of 
    every template through the base template.

        render = web.template.render('templates', base='layout')
    """
    @others
</t>
<t tx="zhanglei.20100830144432.1662">def __init__(self, loc='templates', cache=None, base=None, **keywords):
    self._loc = loc
    self._keywords = keywords

    if cache is None:
        cache = not config.get('debug', False)

    if cache:
        self._cache = {}
    else:
        self._cache = None

    if base and not hasattr(base, '__call__'):
        # make base a function, so that it can be passed to sub-renders
        self._base = lambda page: self._template(base)(page)
    else:
        self._base = base

</t>
<t tx="zhanglei.20100830144432.1663">def _lookup(self, name):
    path = os.path.join(self._loc, name)
    if os.path.isdir(path):
        return 'dir', path
    else:
        path = self._findfile(path)
        if path:
            return 'file', path
        else:
            return 'none', None

</t>
<t tx="zhanglei.20100830144432.1664">def _load_template(self, name):
    kind, path = self._lookup(name)

    if kind == 'dir':
        return Render(path, cache=self._cache is not None, base=self._base, **self._keywords)
    elif kind == 'file':
        return Template(open(path).read(), filename=path, **self._keywords)
    else:
        raise AttributeError, "No template named " + name            

</t>
<t tx="zhanglei.20100830144432.1665">def _findfile(self, path_prefix): 
    p = [f for f in glob.glob(path_prefix + '.*') if not f.endswith('~')] # skip backup files
    return p and p[0]

</t>
<t tx="zhanglei.20100830144432.1666">def _template(self, name):
    if self._cache is not None:
        if name not in self._cache:
            self._cache[name] = self._load_template(name)
        return self._cache[name]
    else:
        return self._load_template(name)

</t>
<t tx="zhanglei.20100830144432.1667">def __getattr__(self, name):
    t = self._template(name)
    if self._base and isinstance(t, Template):
        def template(*a, **kw):
            return self._base(t(*a, **kw))
        return template
    else:
        return self._template(name)

</t>
<t tx="zhanglei.20100830144432.1668">class GAE_Render(Render):
    # Render gets over-written. make a copy here.
    super = Render
    @others
</t>
<t tx="zhanglei.20100830144432.1669">def __init__(self, loc, *a, **kw):
    GAE_Render.super.__init__(self, loc, *a, **kw)

    import types
    if isinstance(loc, types.ModuleType):
        self.mod = loc
    else:
        name = loc.rstrip('/').replace('/', '.')
        self.mod = __import__(name, None, None, ['x'])

    self.mod.__dict__.update(kw.get('builtins', TEMPLATE_BUILTINS))
    self.mod.__dict__.update(Template.globals)
    self.mod.__dict__.update(kw.get('globals', {}))

</t>
<t tx="zhanglei.20100830144432.1670">def _load_template(self, name):
    t = getattr(self.mod, name)
    import types
    if isinstance(t, types.ModuleType):
        return GAE_Render(t, cache=self._cache is not None, base=self._base, **self._keywords)
    else:
        return t

</t>
<t tx="zhanglei.20100830144432.1671">render = Render
# setup render for Google App Engine.
try:
    from google import appengine
    render = Render = GAE_Render
except ImportError:
    pass

def frender(path, **keywords):
    """Creates a template from the given file path.
    """
    return Template(open(path).read(), filename=path, **keywords)

</t>
<t tx="zhanglei.20100830144432.1672">def compile_templates(root):
    """Compiles templates to python code."""
    re_start = re_compile('^', re.M)

    for dirpath, dirnames, filenames in os.walk(root):
        filenames = [f for f in filenames if not f.startswith('.') and not f.endswith('~') and not f.startswith('__init__.py')]

        for d in dirnames[:]:
            if d.startswith('.'):
                dirnames.remove(d) # don't visit this dir

        out = open(os.path.join(dirpath, '__init__.py'), 'w')
        out.write('from web.template import CompiledTemplate, ForLoop\n\n')
        if dirnames:
            out.write("import " + ", ".join(dirnames))

        for f in filenames:
            path = os.path.join(dirpath, f)

            if '.' in f:
                name, _ = f.split('.', 1)
            else:
                name = f

            text = open(path).read()
            text = Template.normalize_text(text)
            code = Template.generate_code(text, path)
            code = re_start.sub('    ', code)

            _gen = '' + \
            '\ndef %s():' + \
            '\n    loop = ForLoop()' + \
            '\n    _dummy  = CompiledTemplate(lambda: None, "dummy")' + \
            '\n    join_ = _dummy._join' + \
            '\n    escape_ = _dummy._escape' + \
            '\n' + \
            '\n%s' + \
            '\n    return __template__'

            gen_code = _gen % (name, code)
            out.write(gen_code)
            out.write('\n\n')
            out.write('%s = CompiledTemplate(%s(), %s)\n\n' % (name, name, repr(path)))

            # create template to make sure it compiles
            t = Template(open(path).read(), path)
        out.close()

</t>
<t tx="zhanglei.20100830144432.1673">class ParseError(Exception):
    pass

</t>
<t tx="zhanglei.20100830144432.1674">class SecurityError(Exception):
    """The template seems to be trying to do something naughty."""
    pass

</t>
<t tx="zhanglei.20100830144432.1675"># Enumerate all the allowed AST nodes
ALLOWED_AST_NODES = [
    "Add", "And",
#   "AssAttr",
    "AssList", "AssName", "AssTuple",
#   "Assert",
    "Assign", "AugAssign",
#   "Backquote",
    "Bitand", "Bitor", "Bitxor", "Break",
    "CallFunc","Class", "Compare", "Const", "Continue",
    "Decorators", "Dict", "Discard", "Div",
    "Ellipsis", "EmptyNode",
#   "Exec",
    "Expression", "FloorDiv", "For",
#   "From",
    "Function", 
    "GenExpr", "GenExprFor", "GenExprIf", "GenExprInner",
    "Getattr", 
#   "Global", 
    "If", "IfExp",
#   "Import",
    "Invert", "Keyword", "Lambda", "LeftShift",
    "List", "ListComp", "ListCompFor", "ListCompIf", "Mod",
    "Module",
    "Mul", "Name", "Not", "Or", "Pass", "Power",
#   "Print", "Printnl", "Raise",
    "Return", "RightShift", "Slice", "Sliceobj",
    "Stmt", "Sub", "Subscript",
#   "TryExcept", "TryFinally",
    "Tuple", "UnaryAdd", "UnarySub",
    "While", "With", "Yield",
]

class SafeVisitor(object):
    """
    Make sure code is safe by walking through the AST.

    Code considered unsafe if:
        * it has restricted AST nodes
        * it is trying to access resricted attributes   

    Adopted from http://www.zafar.se/bkz/uploads/safe.txt (public domain, Babar K. Zafar)
    """
    @others
</t>
<t tx="zhanglei.20100830144432.1676">def __init__(self):
    "Initialize visitor by generating callbacks for all AST node types."
    self.errors = []

</t>
<t tx="zhanglei.20100830144432.1677">def walk(self, ast, filename):
    "Validate each node in AST and raise SecurityError if the code is not safe."
    self.filename = filename
    self.visit(ast)

    if self.errors:        
        raise SecurityError, '\n'.join([str(err) for err in self.errors])

</t>
<t tx="zhanglei.20100830144432.1678">def visit(self, node, *args):
    "Recursively validate node and all of its children."
    def classname(obj):
        return obj.__class__.__name__
    nodename = classname(node)
    fn = getattr(self, 'visit' + nodename, None)

    if fn:
        fn(node, *args)
    else:
        if nodename not in ALLOWED_AST_NODES:
            self.fail(node, *args)

    for child in node.getChildNodes():
        self.visit(child, *args)

</t>
<t tx="zhanglei.20100830144432.1679">def visitName(self, node, *args):
    "Disallow any attempts to access a restricted attr."
    #self.assert_attr(node.getChildren()[0], node)
    pass

</t>
<t tx="zhanglei.20100830144432.1680">def visitGetattr(self, node, *args):
    "Disallow any attempts to access a restricted attribute."
    self.assert_attr(node.attrname, node)

</t>
<t tx="zhanglei.20100830144432.1681">def assert_attr(self, attrname, node):
    if self.is_unallowed_attr(attrname):
        lineno = self.get_node_lineno(node)
        e = SecurityError("%s:%d - access to attribute '%s' is denied" % (self.filename, lineno, attrname))
        self.errors.append(e)

</t>
<t tx="zhanglei.20100830144432.1682">def is_unallowed_attr(self, name):
    return name.startswith('_') \
        or name.startswith('func_') \
        or name.startswith('im_')

</t>
<t tx="zhanglei.20100830144432.1683">def get_node_lineno(self, node):
    return (node.lineno) and node.lineno or 0

</t>
<t tx="zhanglei.20100830144432.1684">def fail(self, node, *args):
    "Default callback for unallowed AST nodes."
    lineno = self.get_node_lineno(node)
    nodename = node.__class__.__name__
    e = SecurityError("%s:%d - execution of '%s' statements is denied" % (self.filename, lineno, nodename))
    self.errors.append(e)

</t>
<t tx="zhanglei.20100830144432.1685">class TemplateResult(storage):
    """Dictionary like object for storing template output.

    A template can specify key-value pairs in the output using 
    `var` statements. Each `var` statement adds a new key to the 
    template output and the main output is stored with key 
    __body__.

        &gt;&gt;&gt; d = TemplateResult(__body__='hello, world', x='foo')
        &gt;&gt;&gt; d
        &lt;TemplateResult: {'__body__': 'hello, world', 'x': 'foo'}&gt;
        &gt;&gt;&gt; print d
        hello, world
    """
    @others
</t>
<t tx="zhanglei.20100830144432.1686">def __unicode__(self): 
    return safeunicode(self.get('__body__', ''))

</t>
<t tx="zhanglei.20100830144432.1687">def __str__(self):
    return safestr(self.get('__body__', ''))

</t>
<t tx="zhanglei.20100830144432.1688">def __repr__(self):
    return "&lt;TemplateResult: %s&gt;" % dict.__repr__(self)

</t>
<t tx="zhanglei.20100830144432.1689">def test():
    r"""Doctest for testing template module.

    Define a utility function to run template test.

        &gt;&gt;&gt; class TestResult(TemplateResult):
        ...     def __repr__(self): return repr(unicode(self))
        ...
        &gt;&gt;&gt; def t(code, **keywords):
        ...     tmpl = Template(code, **keywords)
        ...     return lambda *a, **kw: TestResult(tmpl(*a, **kw))
        ...

    Simple tests.

        &gt;&gt;&gt; t('1')()
        u'1\n'
        &gt;&gt;&gt; t('$def with ()\n1')()
        u'1\n'
        &gt;&gt;&gt; t('$def with (a)\n$a')(1)
        u'1\n'
        &gt;&gt;&gt; t('$def with (a=0)\n$a')(1)
        u'1\n'
        &gt;&gt;&gt; t('$def with (a=0)\n$a')(a=1)
        u'1\n'

    Test complicated expressions.

        &gt;&gt;&gt; t('$def with (x)\n$x.upper()')('hello')
        u'HELLO\n'
        &gt;&gt;&gt; t('$(2 * 3 + 4 * 5)')()
        u'26\n'
        &gt;&gt;&gt; t('${2 * 3 + 4 * 5}')()
        u'26\n'
        &gt;&gt;&gt; t('$def with (limit)\nkeep $(limit)ing.')('go')
        u'keep going.\n'
        &gt;&gt;&gt; t('$def with (a)\n$a.b[0]')(storage(b=[1]))
        u'1\n'

    Test html escaping.

        &gt;&gt;&gt; t('$def with (x)\n$x', filename='a.html')('&lt;html&gt;')
        u'&amp;lt;html&amp;gt;\n'
        &gt;&gt;&gt; t('$def with (x)\n$x', filename='a.txt')('&lt;html&gt;')
        u'&lt;html&gt;\n'

    Test if, for and while.

        &gt;&gt;&gt; t('$if 1: 1')()
        u'1\n'
        &gt;&gt;&gt; t('$if 1:\n    1')()
        u'1\n'
        &gt;&gt;&gt; t('$if 1:\n    1\\')()
        u'1'
        &gt;&gt;&gt; t('$if 0: 0\n$elif 1: 1')()
        u'1\n'
        &gt;&gt;&gt; t('$if 0: 0\n$elif None: 0\n$else: 1')()
        u'1\n'
        &gt;&gt;&gt; t('$if 0 &lt; 1 and 1 &lt; 2: 1')()
        u'1\n'
        &gt;&gt;&gt; t('$for x in [1, 2, 3]: $x')()
        u'1\n2\n3\n'
        &gt;&gt;&gt; t('$def with (d)\n$for k, v in d.iteritems(): $k')({1: 1})
        u'1\n'
        &gt;&gt;&gt; t('$for x in [1, 2, 3]:\n\t$x')()
        u'    1\n    2\n    3\n'
        &gt;&gt;&gt; t('$def with (a)\n$while a and a.pop():1')([1, 2, 3])
        u'1\n1\n1\n'

    The space after : must be ignored.

        &gt;&gt;&gt; t('$if True: foo')()
        u'foo\n'

    Test loop.xxx.

        &gt;&gt;&gt; t("$for i in range(5):$loop.index, $loop.parity")()
        u'1, odd\n2, even\n3, odd\n4, even\n5, odd\n'
        &gt;&gt;&gt; t("$for i in range(2):\n    $for j in range(2):$loop.parent.parity $loop.parity")()
        u'odd odd\nodd even\neven odd\neven even\n'

    Test assignment.

        &gt;&gt;&gt; t('$ a = 1\n$a')()
        u'1\n'
        &gt;&gt;&gt; t('$ a = [1]\n$a[0]')()
        u'1\n'
        &gt;&gt;&gt; t('$ a = {1: 1}\n$a.keys()[0]')()
        u'1\n'
        &gt;&gt;&gt; t('$ a = []\n$if not a: 1')()
        u'1\n'
        &gt;&gt;&gt; t('$ a = {}\n$if not a: 1')()
        u'1\n'
        &gt;&gt;&gt; t('$ a = -1\n$a')()
        u'-1\n'
        &gt;&gt;&gt; t('$ a = "1"\n$a')()
        u'1\n'

    Test comments.

        &gt;&gt;&gt; t('$# 0')()
        u'\n'
        &gt;&gt;&gt; t('hello$#comment1\nhello$#comment2')()
        u'hello\nhello\n'
        &gt;&gt;&gt; t('$#comment0\nhello$#comment1\nhello$#comment2')()
        u'\nhello\nhello\n'

    Test unicode.

        &gt;&gt;&gt; t('$def with (a)\n$a')(u'\u203d')
        u'\u203d\n'
        &gt;&gt;&gt; t('$def with (a)\n$a')(u'\u203d'.encode('utf-8'))
        u'\u203d\n'
        &gt;&gt;&gt; t(u'$def with (a)\n$a $:a')(u'\u203d')
        u'\u203d \u203d\n'
        &gt;&gt;&gt; t(u'$def with ()\nfoo')()
        u'foo\n'
        &gt;&gt;&gt; def f(x): return x
        ...
        &gt;&gt;&gt; t(u'$def with (f)\n$:f("x")')(f)
        u'x\n'
        &gt;&gt;&gt; t('$def with (f)\n$:f("x")')(f)
        u'x\n'

    Test dollar escaping.

        &gt;&gt;&gt; t("Stop, $$money isn't evaluated.")()
        u"Stop, $money isn't evaluated.\n"
        &gt;&gt;&gt; t("Stop, \$money isn't evaluated.")()
        u"Stop, $money isn't evaluated.\n"

    Test space sensitivity.

        &gt;&gt;&gt; t('$def with (x)\n$x')(1)
        u'1\n'
        &gt;&gt;&gt; t('$def with(x ,y)\n$x')(1, 1)
        u'1\n'
        &gt;&gt;&gt; t('$(1 + 2*3 + 4)')()
        u'11\n'

    Make sure globals are working.

        &gt;&gt;&gt; t('$x')()
        Traceback (most recent call last):
            ...
        NameError: global name 'x' is not defined
        &gt;&gt;&gt; t('$x', globals={'x': 1})()
        u'1\n'

    Can't change globals.

        &gt;&gt;&gt; t('$ x = 2\n$x', globals={'x': 1})()
        u'2\n'
        &gt;&gt;&gt; t('$ x = x + 1\n$x', globals={'x': 1})()
        Traceback (most recent call last):
            ...
        UnboundLocalError: local variable 'x' referenced before assignment

    Make sure builtins are customizable.

        &gt;&gt;&gt; t('$min(1, 2)')()
        u'1\n'
        &gt;&gt;&gt; t('$min(1, 2)', builtins={})()
        Traceback (most recent call last):
            ...
        NameError: global name 'min' is not defined

    Test vars.

        &gt;&gt;&gt; x = t('$var x: 1')()
        &gt;&gt;&gt; x.x
        u'1'
        &gt;&gt;&gt; x = t('$var x = 1')()
        &gt;&gt;&gt; x.x
        1
        &gt;&gt;&gt; x = t('$var x:  \n    foo\n    bar')()
        &gt;&gt;&gt; x.x
        u'foo\nbar\n'

    Test BOM chars.

        &gt;&gt;&gt; t('\xef\xbb\xbf$def with(x)\n$x')('foo')
        u'foo\n'

    Test for with weird cases.

        &gt;&gt;&gt; t('$for i in range(10)[1:5]:\n    $i')()
        u'1\n2\n3\n4\n'
        &gt;&gt;&gt; t("$for k, v in {'a': 1, 'b': 2}.items():\n    $k $v")()
        u'a 1\nb 2\n'
        &gt;&gt;&gt; t("$for k, v in ({'a': 1, 'b': 2}.items():\n    $k $v")()
        Traceback (most recent call last):
            ...
        SyntaxError: invalid syntax

    Test datetime.

        &gt;&gt;&gt; import datetime
        &gt;&gt;&gt; t("$def with (date)\n$date.strftime('%m %Y')")(datetime.datetime(2009, 1, 1))
        u'01 2009\n'
    """
    pass

</t>
<t tx="zhanglei.20100830144432.1690">@language python
@tabwidth -4
@ignore
@others
</t>
<t tx="zhanglei.20100830144432.1691">"""test utilities
(part of web.py)
"""
import unittest
import sys, os
import web

TestCase = unittest.TestCase
TestSuite = unittest.TestSuite

</t>
<t tx="zhanglei.20100830144432.1692">def load_modules(names):
    return [__import__(name, None, None, "x") for name in names]

</t>
<t tx="zhanglei.20100830144432.1693">def module_suite(module, classnames=None):
    """Makes a suite from a module."""
    if classnames:
        return unittest.TestLoader().loadTestsFromNames(classnames, module)
    elif hasattr(module, 'suite'):
        return module.suite()
    else:
        return unittest.TestLoader().loadTestsFromModule(module)

</t>
<t tx="zhanglei.20100830144432.1694">def doctest_suite(module_names):
    """Makes a test suite from doctests."""
    import doctest
    suite = TestSuite()
    for mod in load_modules(module_names):
        suite.addTest(doctest.DocTestSuite(mod))
    return suite

</t>
<t tx="zhanglei.20100830144432.1695">def suite(module_names):
    """Creates a suite from multiple modules."""
    suite = TestSuite()
    for mod in load_modules(module_names):
        suite.addTest(module_suite(mod))
    return suite

</t>
<t tx="zhanglei.20100830144432.1696">def runTests(suite):
    runner = unittest.TextTestRunner()
    return runner.run(suite)

</t>
<t tx="zhanglei.20100830144432.1697">def main(suite=None):
    if not suite:
        main_module = __import__('__main__')
        # allow command line switches
        args = [a for a in sys.argv[1:] if not a.startswith('-')]
        suite = module_suite(main_module, args or None)

    result = runTests(suite)
    sys.exit(not result.wasSuccessful())

</t>
<t tx="zhanglei.20100830144432.1698">@language python
@tabwidth -4
@others
if __name__ == "__main__":
    import doctest
    doctest.testmod()
</t>
<t tx="zhanglei.20100830144432.1699">#!/usr/bin/env python
"""
General Utilities
(part of web.py)
"""

__all__ = [
  "Storage", "storage", "storify", 
  "iters", 
  "rstrips", "lstrips", "strips", 
  "safeunicode", "safestr", "utf8",
  "TimeoutError", "timelimit",
  "Memoize", "memoize",
  "re_compile", "re_subm",
  "group", "uniq", "iterview",
  "IterBetter", "iterbetter",
  "dictreverse", "dictfind", "dictfindall", "dictincr", "dictadd",
  "listget", "intget", "datestr",
  "numify", "denumify", "commify", "dateify",
  "nthstr",
  "CaptureStdout", "capturestdout", "Profile", "profile",
  "tryall",
  "ThreadedDict", "threadeddict",
  "autoassign",
  "to36",
  "safemarkdown",
  "sendmail"
]

import re, sys, time, threading, itertools

try:
    import subprocess
except ImportError: 
    subprocess = None

try: import datetime
except ImportError: pass

try: set
except NameError:
    from sets import Set as set

</t>
<t tx="zhanglei.20100830144432.1700">class Storage(dict):
    """
    A Storage object is like a dictionary except `obj.foo` can be used
    in addition to `obj['foo']`.

        &gt;&gt;&gt; o = storage(a=1)
        &gt;&gt;&gt; o.a
        1
        &gt;&gt;&gt; o['a']
        1
        &gt;&gt;&gt; o.a = 2
        &gt;&gt;&gt; o['a']
        2
        &gt;&gt;&gt; del o.a
        &gt;&gt;&gt; o.a
        Traceback (most recent call last):
            ...
        AttributeError: 'a'

    """
    @others
</t>
<t tx="zhanglei.20100830144432.1701">def __getattr__(self, key): 
    try:
        return self[key]
    except KeyError, k:
        raise AttributeError, k

</t>
<t tx="zhanglei.20100830144432.1702">def __setattr__(self, key, value): 
    self[key] = value

</t>
<t tx="zhanglei.20100830144432.1703">def __delattr__(self, key):
    try:
        del self[key]
    except KeyError, k:
        raise AttributeError, k

</t>
<t tx="zhanglei.20100830144432.1704">def __repr__(self):     
    return '&lt;Storage ' + dict.__repr__(self) + '&gt;'

</t>
<t tx="zhanglei.20100830144432.1705">storage = Storage

def storify(mapping, *requireds, **defaults):
    """
    Creates a `storage` object from dictionary `mapping`, raising `KeyError` if
    d doesn't have all of the keys in `requireds` and using the default 
    values for keys found in `defaults`.

    For example, `storify({'a':1, 'c':3}, b=2, c=0)` will return the equivalent of
    `storage({'a':1, 'b':2, 'c':3})`.

    If a `storify` value is a list (e.g. multiple values in a form submission), 
    `storify` returns the last element of the list, unless the key appears in 
    `defaults` as a list. Thus:

        &gt;&gt;&gt; storify({'a':[1, 2]}).a
        2
        &gt;&gt;&gt; storify({'a':[1, 2]}, a=[]).a
        [1, 2]
        &gt;&gt;&gt; storify({'a':1}, a=[]).a
        [1]
        &gt;&gt;&gt; storify({}, a=[]).a
        []

    Similarly, if the value has a `value` attribute, `storify will return _its_
    value, unless the key appears in `defaults` as a dictionary.

        &gt;&gt;&gt; storify({'a':storage(value=1)}).a
        1
        &gt;&gt;&gt; storify({'a':storage(value=1)}, a={}).a
        &lt;Storage {'value': 1}&gt;
        &gt;&gt;&gt; storify({}, a={}).a
        {}

    Optionally, keyword parameter `_unicode` can be passed to convert all values to unicode.

        &gt;&gt;&gt; storify({'x': 'a'}, _unicode=True)
        &lt;Storage {'x': u'a'}&gt;
        &gt;&gt;&gt; storify({'x': storage(value='a')}, x={}, _unicode=True)
        &lt;Storage {'x': &lt;Storage {'value': 'a'}&gt;}&gt;
        &gt;&gt;&gt; storify({'x': storage(value='a')}, _unicode=True)
        &lt;Storage {'x': u'a'}&gt;
    """
    _unicode = defaults.pop('_unicode', False)
    def unicodify(s):
        if _unicode and isinstance(s, str): return safeunicode(s)
        else: return s

    def getvalue(x):
        if hasattr(x, 'file') and hasattr(x, 'value'):
            return x.value
        elif hasattr(x, 'value'):
            return unicodify(x.value)
        else:
            return unicodify(x)

    stor = Storage()
    for key in requireds + tuple(mapping.keys()):
        value = mapping[key]
        if isinstance(value, list):
            if isinstance(defaults.get(key), list):
                value = [getvalue(x) for x in value]
            else:
                value = value[-1]
        if not isinstance(defaults.get(key), dict):
            value = getvalue(value)
        if isinstance(defaults.get(key), list) and not isinstance(value, list):
            value = [value]
        setattr(stor, key, value)

    for (key, value) in defaults.iteritems():
        result = value
        if hasattr(stor, key): 
            result = stor[key]
        if value == () and not isinstance(result, tuple): 
            result = (result,)
        setattr(stor, key, result)

    return stor

</t>
<t tx="zhanglei.20100830144432.1706">iters = [list, tuple]
import __builtin__
if hasattr(__builtin__, 'set'):
    iters.append(set)
if hasattr(__builtin__, 'frozenset'):
    iters.append(set)
if sys.version_info &lt; (2,6): # sets module deprecated in 2.6
    try:
        from sets import Set
        iters.append(Set)
    except ImportError: 
        pass

class _hack(tuple): pass
</t>
<t tx="zhanglei.20100830144432.1707">iters = _hack(iters)
iters.__doc__ = """
A list of iterable items (like lists, but not strings). Includes whichever
of lists, tuples, sets, and Sets are available in this version of Python.
"""

def _strips(direction, text, remove):
    if direction == 'l': 
        if text.startswith(remove): 
            return text[len(remove):]
    elif direction == 'r':
        if text.endswith(remove):   
            return text[:-len(remove)]
    else: 
        raise ValueError, "Direction needs to be r or l."
    return text

</t>
<t tx="zhanglei.20100830144432.1708">def rstrips(text, remove):
    """
    removes the string `remove` from the right of `text`

        &gt;&gt;&gt; rstrips("foobar", "bar")
        'foo'

    """
    return _strips('r', text, remove)

</t>
<t tx="zhanglei.20100830144432.1709">def lstrips(text, remove):
    """
    removes the string `remove` from the left of `text`

        &gt;&gt;&gt; lstrips("foobar", "foo")
        'bar'

    """
    return _strips('l', text, remove)

</t>
<t tx="zhanglei.20100830144432.1710">def strips(text, remove):
    """
    removes the string `remove` from the both sides of `text`

        &gt;&gt;&gt; strips("foobarfoo", "foo")
        'bar'

    """
    return rstrips(lstrips(text, remove), remove)

</t>
<t tx="zhanglei.20100830144432.1711">def safeunicode(obj, encoding='utf-8'):
    r"""
    Converts any given object to unicode string.

        &gt;&gt;&gt; safeunicode('hello')
        u'hello'
        &gt;&gt;&gt; safeunicode(2)
        u'2'
        &gt;&gt;&gt; safeunicode('\xe1\x88\xb4')
        u'\u1234'
    """
    if isinstance(obj, unicode):
        return obj
    elif isinstance(obj, str):
        return obj.decode(encoding)
    else:
        if hasattr(obj, '__unicode__'):
            return unicode(obj)
        else:
            return str(obj).decode(encoding)

</t>
<t tx="zhanglei.20100830144432.1712">def safestr(obj, encoding='utf-8'):
    r"""
    Converts any given object to utf-8 encoded string. 

        &gt;&gt;&gt; safestr('hello')
        'hello'
        &gt;&gt;&gt; safestr(u'\u1234')
        '\xe1\x88\xb4'
        &gt;&gt;&gt; safestr(2)
        '2'
    """
    if isinstance(obj, unicode):
        return obj.encode('utf-8')
    elif isinstance(obj, str):
        return obj
    elif hasattr(obj, 'next') and hasattr(obj, '__iter__'): # iterator
        return itertools.imap(safestr, obj)
    else:
        return str(obj)

</t>
<t tx="zhanglei.20100830144432.1713"># for backward-compatibility
utf8 = safestr

class TimeoutError(Exception): pass
</t>
<t tx="zhanglei.20100830144432.1714">def timelimit(timeout):
    """
    A decorator to limit a function to `timeout` seconds, raising `TimeoutError`
    if it takes longer.

        &gt;&gt;&gt; import time
        &gt;&gt;&gt; def meaningoflife():
        ...     time.sleep(.2)
        ...     return 42
        &gt;&gt;&gt; 
        &gt;&gt;&gt; timelimit(.1)(meaningoflife)()
        Traceback (most recent call last):
            ...
        TimeoutError: took too long
        &gt;&gt;&gt; timelimit(1)(meaningoflife)()
        42

    _Caveat:_ The function isn't stopped after `timeout` seconds but continues 
    executing in a separate thread. (There seems to be no way to kill a thread.)

    inspired by &lt;http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/473878&gt;
    """
    def _1(function):
        def _2(*args, **kw):
            class Dispatch(threading.Thread):
                def __init__(self):
                    threading.Thread.__init__(self)
                    self.result = None
                    self.error = None

                    self.setDaemon(True)
                    self.start()

                def run(self):
                    try:
                        self.result = function(*args, **kw)
                    except:
                        self.error = sys.exc_info()

            c = Dispatch()
            c.join(timeout)
            if c.isAlive():
                raise TimeoutError, 'took too long'
            if c.error:
                raise c.error[0], c.error[1]
            return c.result
        return _2
    return _1

</t>
<t tx="zhanglei.20100830144432.1715">class Memoize:
    """
    'Memoizes' a function, caching its return values for each input.
    If `expires` is specified, values are recalculated after `expires` seconds.
    If `background` is specified, values are recalculated in a separate thread.

        &gt;&gt;&gt; calls = 0
        &gt;&gt;&gt; def howmanytimeshaveibeencalled():
        ...     global calls
        ...     calls += 1
        ...     return calls
        &gt;&gt;&gt; fastcalls = memoize(howmanytimeshaveibeencalled)
        &gt;&gt;&gt; howmanytimeshaveibeencalled()
        1
        &gt;&gt;&gt; howmanytimeshaveibeencalled()
        2
        &gt;&gt;&gt; fastcalls()
        3
        &gt;&gt;&gt; fastcalls()
        3
        &gt;&gt;&gt; import time
        &gt;&gt;&gt; fastcalls = memoize(howmanytimeshaveibeencalled, .1, background=False)
        &gt;&gt;&gt; fastcalls()
        4
        &gt;&gt;&gt; fastcalls()
        4
        &gt;&gt;&gt; time.sleep(.2)
        &gt;&gt;&gt; fastcalls()
        5
        &gt;&gt;&gt; def slowfunc():
        ...     time.sleep(.1)
        ...     return howmanytimeshaveibeencalled()
        &gt;&gt;&gt; fastcalls = memoize(slowfunc, .2, background=True)
        &gt;&gt;&gt; fastcalls()
        6
        &gt;&gt;&gt; timelimit(.05)(fastcalls)()
        6
        &gt;&gt;&gt; time.sleep(.2)
        &gt;&gt;&gt; timelimit(.05)(fastcalls)()
        6
        &gt;&gt;&gt; timelimit(.05)(fastcalls)()
        6
        &gt;&gt;&gt; time.sleep(.2)
        &gt;&gt;&gt; timelimit(.05)(fastcalls)()
        7
        &gt;&gt;&gt; fastcalls = memoize(slowfunc, None, background=True)
        &gt;&gt;&gt; threading.Thread(target=fastcalls).start()
        &gt;&gt;&gt; time.sleep(.01)
        &gt;&gt;&gt; fastcalls()
        9
    """
    @others
</t>
<t tx="zhanglei.20100830144432.1716">def __init__(self, func, expires=None, background=True): 
    self.func = func
    self.cache = {}
    self.expires = expires
    self.background = background
    self.running = {}

</t>
<t tx="zhanglei.20100830144432.1717">def __call__(self, *args, **keywords):
    key = (args, tuple(keywords.items()))
    if not self.running.get(key):
        self.running[key] = threading.Lock()
    def update(block=False):
        if self.running[key].acquire(block):
            try:
                self.cache[key] = (self.func(*args, **keywords), time.time())
            finally:
                self.running[key].release()

    if key not in self.cache: 
        update(block=True)
    elif self.expires and (time.time() - self.cache[key][1]) &gt; self.expires:
        if self.background:
            threading.Thread(target=update).start()
        else:
            update()
    return self.cache[key][0]

</t>
<t tx="zhanglei.20100830144432.1718">memoize = Memoize

re_compile = memoize(re.compile) #@@ threadsafe?
re_compile.__doc__ = """
A memoized version of re.compile.
"""

class _re_subm_proxy:
    @others
</t>
<t tx="zhanglei.20100830144432.1719">def __init__(self): 
    self.match = None
</t>
<t tx="zhanglei.20100830144432.1720">def __call__(self, match): 
    self.match = match
    return ''

</t>
<t tx="zhanglei.20100830144432.1721">def re_subm(pat, repl, string):
    """
    Like re.sub, but returns the replacement _and_ the match object.

        &gt;&gt;&gt; t, m = re_subm('g(oo+)fball', r'f\\1lish', 'goooooofball')
        &gt;&gt;&gt; t
        'foooooolish'
        &gt;&gt;&gt; m.groups()
        ('oooooo',)
    """
    compiled_pat = re_compile(pat)
    proxy = _re_subm_proxy()
    compiled_pat.sub(proxy.__call__, string)
    return compiled_pat.sub(repl, string), proxy.match

</t>
<t tx="zhanglei.20100830144432.1722">def group(seq, size): 
    """
    Returns an iterator over a series of lists of length size from iterable.

        &gt;&gt;&gt; list(group([1,2,3,4], 2))
        [[1, 2], [3, 4]]
        &gt;&gt;&gt; list(group([1,2,3,4,5], 2))
        [[1, 2], [3, 4], [5]]
    """
    def take(seq, n):
        for i in xrange(n):
            yield seq.next()

    if not hasattr(seq, 'next'):  
        seq = iter(seq)
    while True: 
        x = list(take(seq, size))
        if x:
            yield x
        else:
            break

</t>
<t tx="zhanglei.20100830144432.1723">def uniq(seq):
   """
   Removes duplicate elements from a list.

       &gt;&gt;&gt; uniq([1,2,3,1,4,5,6])
       [1, 2, 3, 4, 5, 6]
   """
   seen = set()
   result = []
   for item in seq:
       if item in seen: continue
       seen.add(item)
       result.append(item)
   return result

</t>
<t tx="zhanglei.20100830144432.1724">def iterview(x):
   """
   Takes an iterable `x` and returns an iterator over it
   which prints its progress to stderr as it iterates through.
   """
   WIDTH = 70

   def plainformat(n, lenx):
       return '%5.1f%% (%*d/%d)' % ((float(n)/lenx)*100, len(str(lenx)), n, lenx)

   def bars(size, n, lenx):
       val = int((float(n)*size)/lenx + 0.5)
       if size - val:
           spacing = "&gt;" + (" "*(size-val))[1:]
       else:
           spacing = ""
       return "[%s%s]" % ("="*val, spacing)

   def eta(elapsed, n, lenx):
       if n == 0:
           return '--:--:--'
       if n == lenx:
           secs = int(elapsed)
       else:
           secs = int((elapsed/n) * (lenx-n))
       mins, secs = divmod(secs, 60)
       hrs, mins = divmod(mins, 60)

       return '%02d:%02d:%02d' % (hrs, mins, secs)

   def format(starttime, n, lenx):
       out = plainformat(n, lenx) + ' '
       if n == lenx:
           end = '     '
       else:
           end = ' ETA '
       end += eta(time.time() - starttime, n, lenx)
       out += bars(WIDTH - len(out) - len(end), n, lenx)
       out += end
       return out

   starttime = time.time()
   lenx = len(x)
   for n, y in enumerate(x):
       sys.stderr.write('\r' + format(starttime, n, lenx))
       yield y
   sys.stderr.write('\r' + format(starttime, n+1, lenx) + '\n')

</t>
<t tx="zhanglei.20100830144432.1725">class IterBetter:
    """
    Returns an object that can be used as an iterator 
    but can also be used via __getitem__ (although it 
    cannot go backwards -- that is, you cannot request 
    `iterbetter[0]` after requesting `iterbetter[1]`).

        &gt;&gt;&gt; import itertools
        &gt;&gt;&gt; c = iterbetter(itertools.count())
        &gt;&gt;&gt; c[1]
        1
        &gt;&gt;&gt; c[5]
        5
        &gt;&gt;&gt; c[3]
        Traceback (most recent call last):
            ...
        IndexError: already passed 3
    """
    @others
</t>
<t tx="zhanglei.20100830144432.1726">def __init__(self, iterator): 
    self.i, self.c = iterator, 0
</t>
<t tx="zhanglei.20100830144432.1727">def __iter__(self): 
    while 1:    
        yield self.i.next()
        self.c += 1
</t>
<t tx="zhanglei.20100830144432.1728">def __getitem__(self, i):
    #todo: slices
    if i &lt; self.c: 
        raise IndexError, "already passed "+str(i)
    try:
        while i &gt; self.c: 
            self.i.next()
            self.c += 1
        # now self.c == i
        self.c += 1
        return self.i.next()
    except StopIteration: 
        raise IndexError, str(i)

</t>
<t tx="zhanglei.20100830144432.1729">def __nonzero__(self):
    return len(self) != 0

</t>
<t tx="zhanglei.20100830144432.1730">iterbetter = IterBetter

def dictreverse(mapping):
    """
    Returns a new dictionary with keys and values swapped.

        &gt;&gt;&gt; dictreverse({1: 2, 3: 4})
        {2: 1, 4: 3}
    """
    return dict([(value, key) for (key, value) in mapping.iteritems()])

</t>
<t tx="zhanglei.20100830144432.1731">def dictfind(dictionary, element):
    """
    Returns a key whose value in `dictionary` is `element` 
    or, if none exists, None.

        &gt;&gt;&gt; d = {1:2, 3:4}
        &gt;&gt;&gt; dictfind(d, 4)
        3
        &gt;&gt;&gt; dictfind(d, 5)
    """
    for (key, value) in dictionary.iteritems():
        if element is value: 
            return key

</t>
<t tx="zhanglei.20100830144432.1732">def dictfindall(dictionary, element):
    """
    Returns the keys whose values in `dictionary` are `element`
    or, if none exists, [].

        &gt;&gt;&gt; d = {1:4, 3:4}
        &gt;&gt;&gt; dictfindall(d, 4)
        [1, 3]
        &gt;&gt;&gt; dictfindall(d, 5)
        []
    """
    res = []
    for (key, value) in dictionary.iteritems():
        if element is value:
            res.append(key)
    return res

</t>
<t tx="zhanglei.20100830144432.1733">def dictincr(dictionary, element):
    """
    Increments `element` in `dictionary`, 
    setting it to one if it doesn't exist.

        &gt;&gt;&gt; d = {1:2, 3:4}
        &gt;&gt;&gt; dictincr(d, 1)
        3
        &gt;&gt;&gt; d[1]
        3
        &gt;&gt;&gt; dictincr(d, 5)
        1
        &gt;&gt;&gt; d[5]
        1
    """
    dictionary.setdefault(element, 0)
    dictionary[element] += 1
    return dictionary[element]

</t>
<t tx="zhanglei.20100830144432.1734">def dictadd(*dicts):
    """
    Returns a dictionary consisting of the keys in the argument dictionaries.
    If they share a key, the value from the last argument is used.

        &gt;&gt;&gt; dictadd({1: 0, 2: 0}, {2: 1, 3: 1})
        {1: 0, 2: 1, 3: 1}
    """
    result = {}
    for dct in dicts:
        result.update(dct)
    return result

</t>
<t tx="zhanglei.20100830144432.1735">def listget(lst, ind, default=None):
    """
    Returns `lst[ind]` if it exists, `default` otherwise.

        &gt;&gt;&gt; listget(['a'], 0)
        'a'
        &gt;&gt;&gt; listget(['a'], 1)
        &gt;&gt;&gt; listget(['a'], 1, 'b')
        'b'
    """
    if len(lst)-1 &lt; ind: 
        return default
    return lst[ind]

</t>
<t tx="zhanglei.20100830144432.1736">def intget(integer, default=None):
    """
    Returns `integer` as an int or `default` if it can't.

        &gt;&gt;&gt; intget('3')
        3
        &gt;&gt;&gt; intget('3a')
        &gt;&gt;&gt; intget('3a', 0)
        0
    """
    try:
        return int(integer)
    except (TypeError, ValueError):
        return default

</t>
<t tx="zhanglei.20100830144432.1737">def datestr(then, now=None):
    """
    Converts a (UTC) datetime object to a nice string representation.

        &gt;&gt;&gt; from datetime import datetime, timedelta
        &gt;&gt;&gt; d = datetime(1970, 5, 1)
        &gt;&gt;&gt; datestr(d, now=d)
        '0 microseconds ago'
        &gt;&gt;&gt; for t, v in {
        ...   timedelta(microseconds=1): '1 microsecond ago',
        ...   timedelta(microseconds=2): '2 microseconds ago',
        ...   -timedelta(microseconds=1): '1 microsecond from now',
        ...   -timedelta(microseconds=2): '2 microseconds from now',
        ...   timedelta(microseconds=2000): '2 milliseconds ago',
        ...   timedelta(seconds=2): '2 seconds ago',
        ...   timedelta(seconds=2*60): '2 minutes ago',
        ...   timedelta(seconds=2*60*60): '2 hours ago',
        ...   timedelta(days=2): '2 days ago',
        ... }.iteritems():
        ...     assert datestr(d, now=d+t) == v
        &gt;&gt;&gt; datestr(datetime(1970, 1, 1), now=d)
        'January  1'
        &gt;&gt;&gt; datestr(datetime(1969, 1, 1), now=d)
        'January  1, 1969'
        &gt;&gt;&gt; datestr(datetime(1970, 6, 1), now=d)
        'June  1, 1970'
        &gt;&gt;&gt; datestr(None)
        ''
    """
    def agohence(n, what, divisor=None):
        if divisor: n = n // divisor

        out = str(abs(n)) + ' ' + what       # '2 day'
        if abs(n) != 1: out += 's'           # '2 days'
        out += ' '                           # '2 days '
        if n &lt; 0:
            out += 'from now'
        else:
            out += 'ago'
        return out                           # '2 days ago'

    oneday = 24 * 60 * 60

    if not then: return ""
    if not now: now = datetime.datetime.utcnow()
    if type(now).__name__ == "DateTime":
        now = datetime.datetime.fromtimestamp(now)
    if type(then).__name__ == "DateTime":
        then = datetime.datetime.fromtimestamp(then)
    elif type(then).__name__ == "date":
        then = datetime.datetime(then.year, then.month, then.day)

    delta = now - then
    deltaseconds = int(delta.days * oneday + delta.seconds + delta.microseconds * 1e-06)
    deltadays = abs(deltaseconds) // oneday
    if deltaseconds &lt; 0: deltadays *= -1 # fix for oddity of floor

    if deltadays:
        if abs(deltadays) &lt; 4:
            return agohence(deltadays, 'day')

        out = then.strftime('%B %e') # e.g. 'June 13'
        if then.year != now.year or deltadays &lt; 0:
            out += ', %s' % then.year
        return out

    if int(deltaseconds):
        if abs(deltaseconds) &gt; (60 * 60):
            return agohence(deltaseconds, 'hour', 60 * 60)
        elif abs(deltaseconds) &gt; 60:
            return agohence(deltaseconds, 'minute', 60)
        else:
            return agohence(deltaseconds, 'second')

    deltamicroseconds = delta.microseconds
    if delta.days: deltamicroseconds = int(delta.microseconds - 1e6) # datetime oddity
    if abs(deltamicroseconds) &gt; 1000:
        return agohence(deltamicroseconds, 'millisecond', 1000)

    return agohence(deltamicroseconds, 'microsecond')

</t>
<t tx="zhanglei.20100830144432.1738">def numify(string):
    """
    Removes all non-digit characters from `string`.

        &gt;&gt;&gt; numify('800-555-1212')
        '8005551212'
        &gt;&gt;&gt; numify('800.555.1212')
        '8005551212'

    """
    return ''.join([c for c in str(string) if c.isdigit()])

</t>
<t tx="zhanglei.20100830144432.1739">def denumify(string, pattern):
    """
    Formats `string` according to `pattern`, where the letter X gets replaced
    by characters from `string`.

        &gt;&gt;&gt; denumify("8005551212", "(XXX) XXX-XXXX")
        '(800) 555-1212'

    """
    out = []
    for c in pattern:
        if c == "X":
            out.append(string[0])
            string = string[1:]
        else:
            out.append(c)
    return ''.join(out)

</t>
<t tx="zhanglei.20100830144432.1740">def commify(n):
    """
    Add commas to an integer `n`.

        &gt;&gt;&gt; commify(1)
        '1'
        &gt;&gt;&gt; commify(123)
        '123'
        &gt;&gt;&gt; commify(1234)
        '1,234'
        &gt;&gt;&gt; commify(1234567890)
        '1,234,567,890'
        &gt;&gt;&gt; commify(123.0)
        '123.0'
        &gt;&gt;&gt; commify(1234.5)
        '1,234.5'
        &gt;&gt;&gt; commify(1234.56789)
        '1,234.56789'
        &gt;&gt;&gt; commify('%.2f' % 1234.5)
        '1,234.50'
        &gt;&gt;&gt; commify(None)
        &gt;&gt;&gt;

    """
    if n is None: return None
    n = str(n)
    if '.' in n:
        dollars, cents = n.split('.')
    else:
        dollars, cents = n, None

    r = []
    for i, c in enumerate(str(dollars)[::-1]):
        if i and (not (i % 3)):
            r.insert(0, ',')
        r.insert(0, c)
    out = ''.join(r)
    if cents:
        out += '.' + cents
    return out

</t>
<t tx="zhanglei.20100830144432.1741">def dateify(datestring):
    """
    Formats a numified `datestring` properly.
    """
    return denumify(datestring, "XXXX-XX-XX XX:XX:XX")


</t>
<t tx="zhanglei.20100830144432.1742">def nthstr(n):
    """
    Formats an ordinal.
    Doesn't handle negative numbers.

        &gt;&gt;&gt; nthstr(1)
        '1st'
        &gt;&gt;&gt; nthstr(0)
        '0th'
        &gt;&gt;&gt; [nthstr(x) for x in [2, 3, 4, 5, 10, 11, 12, 13, 14, 15]]
        ['2nd', '3rd', '4th', '5th', '10th', '11th', '12th', '13th', '14th', '15th']
        &gt;&gt;&gt; [nthstr(x) for x in [91, 92, 93, 94, 99, 100, 101, 102]]
        ['91st', '92nd', '93rd', '94th', '99th', '100th', '101st', '102nd']
        &gt;&gt;&gt; [nthstr(x) for x in [111, 112, 113, 114, 115]]
        ['111th', '112th', '113th', '114th', '115th']

    """

    assert n &gt;= 0
    if n % 100 in [11, 12, 13]: return '%sth' % n
    return {1: '%sst', 2: '%snd', 3: '%srd'}.get(n % 10, '%sth') % n

</t>
<t tx="zhanglei.20100830144432.1743">def cond(predicate, consequence, alternative=None):
    """
    Function replacement for if-else to use in expressions.

        &gt;&gt;&gt; x = 2
        &gt;&gt;&gt; cond(x % 2 == 0, "even", "odd")
        'even'
        &gt;&gt;&gt; cond(x % 2 == 0, "even", "odd") + '_row'
        'even_row'
    """
    if predicate:
        return consequence
    else:
        return alternative

</t>
<t tx="zhanglei.20100830144432.1744">class CaptureStdout:
    """
    Captures everything `func` prints to stdout and returns it instead.

        &gt;&gt;&gt; def idiot():
        ...     print "foo"
        &gt;&gt;&gt; capturestdout(idiot)()
        'foo\\n'

    **WARNING:** Not threadsafe!
    """
    @others
</t>
<t tx="zhanglei.20100830144432.1745">def __init__(self, func): 
    self.func = func
</t>
<t tx="zhanglei.20100830144432.1746">def __call__(self, *args, **keywords):
    from cStringIO import StringIO
    # Not threadsafe!
    out = StringIO()
    oldstdout = sys.stdout
    sys.stdout = out
    try: 
        self.func(*args, **keywords)
    finally: 
        sys.stdout = oldstdout
    return out.getvalue()

</t>
<t tx="zhanglei.20100830144432.1747">capturestdout = CaptureStdout

class Profile:
    """
    Profiles `func` and returns a tuple containing its output
    and a string with human-readable profiling information.

        &gt;&gt;&gt; import time
        &gt;&gt;&gt; out, inf = profile(time.sleep)(.001)
        &gt;&gt;&gt; out
        &gt;&gt;&gt; inf[:10].strip()
        'took 0.0'
    """
    @others
</t>
<t tx="zhanglei.20100830144432.1748">def __init__(self, func): 
    self.func = func
</t>
<t tx="zhanglei.20100830144432.1749">def __call__(self, *args): ##, **kw):   kw unused
    import hotshot, hotshot.stats, os, tempfile ##, time already imported
    f, filename = tempfile.mkstemp()
    os.close(f)

    prof = hotshot.Profile(filename)

    stime = time.time()
    result = prof.runcall(self.func, *args)
    stime = time.time() - stime
    prof.close()

    import cStringIO
    out = cStringIO.StringIO()
    stats = hotshot.stats.load(filename)
    stats.stream = out
    stats.strip_dirs()
    stats.sort_stats('time', 'calls')
    stats.print_stats(40)
    stats.print_callers()

    x =  '\n\ntook '+ str(stime) + ' seconds\n'
    x += out.getvalue()

    # remove the tempfile
    try:
        os.remove(filename)
    except IOError:
        pass

    return result, x

</t>
<t tx="zhanglei.20100830144432.1750">profile = Profile


import traceback
# hack for compatibility with Python 2.3:
if not hasattr(traceback, 'format_exc'):
    from cStringIO import StringIO
    def format_exc(limit=None):
        strbuf = StringIO()
        traceback.print_exc(limit, strbuf)
        return strbuf.getvalue()
    traceback.format_exc = format_exc

def tryall(context, prefix=None):
    """
    Tries a series of functions and prints their results. 
    `context` is a dictionary mapping names to values; 
    the value will only be tried if it's callable.

        &gt;&gt;&gt; tryall(dict(j=lambda: True))
        j: True
        ----------------------------------------
        results:
           True: 1

    For example, you might have a file `test/stuff.py` 
    with a series of functions testing various things in it. 
    At the bottom, have a line:

        if __name__ == "__main__": tryall(globals())

    Then you can run `python test/stuff.py` and get the results of 
    all the tests.
    """
    context = context.copy() # vars() would update
    results = {}
    for (key, value) in context.iteritems():
        if not hasattr(value, '__call__'): 
            continue
        if prefix and not key.startswith(prefix): 
            continue
        print key + ':',
        try:
            r = value()
            dictincr(results, r)
            print r
        except:
            print 'ERROR'
            dictincr(results, 'ERROR')
            print '   ' + '\n   '.join(traceback.format_exc().split('\n'))

    print '-'*40
    print 'results:'
    for (key, value) in results.iteritems():
        print ' '*2, str(key)+':', value

</t>
<t tx="zhanglei.20100830144432.1751">class ThreadedDict:
    """
    Thread local storage.

        &gt;&gt;&gt; d = ThreadedDict()
        &gt;&gt;&gt; d.x = 1
        &gt;&gt;&gt; d.x
        1
        &gt;&gt;&gt; import threading
        &gt;&gt;&gt; def f(): d.x = 2
        ...
        &gt;&gt;&gt; t = threading.Thread(target=f)
        &gt;&gt;&gt; t.start()
        &gt;&gt;&gt; t.join()
        &gt;&gt;&gt; d.x
        1
    """
    @others
</t>
<t tx="zhanglei.20100830144432.1752">def __getattr__(self, key):
    return getattr(self._getd(), key)

</t>
<t tx="zhanglei.20100830144432.1753">def __setattr__(self, key, value):
    return setattr(self._getd(), key, value)

</t>
<t tx="zhanglei.20100830144432.1754">def __delattr__(self, key):
    return delattr(self._getd(), key)

</t>
<t tx="zhanglei.20100830144432.1755">def __hash__(self): 
    return id(self)

</t>
<t tx="zhanglei.20100830144432.1756">def _getd(self):
    t = threading.currentThread()
    if not hasattr(t, '_d'):
        # using __dict__ of thread as thread local storage
        t._d = {}

    # there could be multiple instances of ThreadedDict.
    # use self as key
    if self not in t._d:
        t._d[self] = storage()
    return t._d[self]

</t>
<t tx="zhanglei.20100830144432.1757">threadeddict = ThreadedDict

def autoassign(self, locals):
    """
    Automatically assigns local variables to `self`.

        &gt;&gt;&gt; self = storage()
        &gt;&gt;&gt; autoassign(self, dict(a=1, b=2))
        &gt;&gt;&gt; self
        &lt;Storage {'a': 1, 'b': 2}&gt;

    Generally used in `__init__` methods, as in:

        def __init__(self, foo, bar, baz=1): autoassign(self, locals())
    """
    for (key, value) in locals.iteritems():
        if key == 'self': 
            continue
        setattr(self, key, value)

</t>
<t tx="zhanglei.20100830144432.1758">def to36(q):
    """
    Converts an integer to base 36 (a useful scheme for human-sayable IDs).

        &gt;&gt;&gt; to36(35)
        'z'
        &gt;&gt;&gt; to36(119292)
        '2k1o'
        &gt;&gt;&gt; int(to36(939387374), 36)
        939387374
        &gt;&gt;&gt; to36(0)
        '0'
        &gt;&gt;&gt; to36(-393)
        Traceback (most recent call last):
            ... 
        ValueError: must supply a positive integer

    """
    if q &lt; 0: raise ValueError, "must supply a positive integer"
    letters = "0123456789abcdefghijklmnopqrstuvwxyz"
    converted = []
    while q != 0:
        q, r = divmod(q, 36)
        converted.insert(0, letters[r])
    return "".join(converted) or '0'


</t>
<t tx="zhanglei.20100830144432.1759">r_url = re_compile('(?&lt;!\()(http://(\S+))')
def safemarkdown(text):
    """
    Converts text to HTML following the rules of Markdown, but blocking any
    outside HTML input, so that only the things supported by Markdown
    can be used. Also converts raw URLs to links.

    (requires [markdown.py](http://webpy.org/markdown.py))
    """
    from markdown import markdown
    if text:
        text = text.replace('&lt;', '&amp;lt;')
        # TODO: automatically get page title?
        text = r_url.sub(r'&lt;\1&gt;', text)
        text = markdown(text)
        return text

</t>
<t tx="zhanglei.20100830144432.1760">def sendmail(from_address, to_address, subject, message, headers=None, **kw):
    """
    Sends the email message `message` with mail and envelope headers
    for from `from_address_` to `to_address` with `subject`. 
    Additional email headers can be specified with the dictionary 
    `headers.

    If `web.config.smtp_server` is set, it will send the message
    to that SMTP server. Otherwise it will look for 
    `/usr/sbin/sendmail`, the typical location for the sendmail-style
    binary. To use sendmail from a different path, set `web.config.sendmail_path`.
    """
    try:
        import webapi
    except ImportError:
        webapi = Storage(config=Storage())

    if headers is None: headers = {}

    cc = kw.get('cc', [])
    bcc = kw.get('bcc', [])

    def listify(x):
        if not isinstance(x, list):
            return [safestr(x)]
        else:
            return [safestr(a) for a in x]

    from_address = safestr(from_address)

    to_address = listify(to_address)
    cc = listify(cc)
    bcc = listify(bcc)

    recipients = to_address + cc + bcc

    headers = dictadd({
      'MIME-Version': '1.0',
      'Content-Type': 'text/plain; charset=UTF-8',
      'Content-Disposition': 'inline',
      'From': from_address,
      'To': ", ".join(to_address),
      'Subject': subject
    }, headers)

    if cc:
        headers['Cc'] = ", ".join(cc)

    import email.Utils
    from_address = email.Utils.parseaddr(from_address)[1]
    recipients = [email.Utils.parseaddr(r)[1] for r in recipients]
    message = ('\n'.join([safestr('%s: %s' % x) for x in headers.iteritems()])
      + "\n\n" +  safestr(message))

    if webapi.config.get('smtp_server'):
        server = webapi.config.get('smtp_server')
        port = webapi.config.get('smtp_port', 0)
        username = webapi.config.get('smtp_username') 
        password = webapi.config.get('smtp_password')
        debug_level = webapi.config.get('smtp_debuglevel', None)
        starttls = webapi.config.get('smtp_starttls', False)

        import smtplib
        smtpserver = smtplib.SMTP(server, port)

        if debug_level:
            smtpserver.set_debuglevel(debug_level)

        if starttls:
            smtpserver.ehlo()
            smtpserver.starttls()
            smtpserver.ehlo()

        if username and password:
            smtpserver.login(username, password)

        smtpserver.sendmail(from_address, recipients, message)
        smtpserver.quit()
    else:
        sendmail = webapi.config.get('sendmail_path', '/usr/sbin/sendmail')

        assert not from_address.startswith('-'), 'security'
        for r in recipients:
            assert not r.startswith('-'), 'security'

        cmd = [sendmail, '-f', from_address] + recipients

        if subprocess:
            p = subprocess.Popen(cmd, stdin=subprocess.PIPE)
            p.stdin.write(message)
            p.stdin.close()
            p.wait()
        else:
            import os
            i, o = os.popen2(cmd)
            i.write(message)
            i.close()
            o.close()
            del i, o

</t>
<t tx="zhanglei.20100830144432.1761">@language python
@tabwidth -4
@others
@ignore
debug.write = _debugwrite

ctx = context = threadeddict()

ctx.__doc__ = """
A `storage` object containing various information about the request:

`environ` (aka `env`)
   : A dictionary containing the standard WSGI environment variables.

`host`
   : The domain (`Host` header) requested by the user.

`home`
   : The base path for the application.

`ip`
   : The IP address of the requester.

`method`
   : The HTTP method used.

`path`
   : The path request.

`query`
   : If there are no query arguments, the empty string. Otherwise, a `?` followed
     by the query string.

`fullpath`
   : The full path requested, including query arguments (`== path + query`).

### Response Data

`status` (default: "200 OK")
   : The status code to be used in the response.

`headers`
   : A list of 2-tuples to be used in the response.

`output`
   : A string to be used as the response.
"""
</t>
<t tx="zhanglei.20100830144432.1762">"""
Web API (wrapper around WSGI)
(from web.py)
"""

__all__ = [
    "config",
    "header", "debug",
    "input", "data",
    "setcookie", "cookies",
    "ctx", 
    "HTTPError", 

    # 200, 201, 202
    "OK", "Created", "Accepted",    
    "ok", "created", "accepted",

    # 301, 302, 303, 304, 407
    "Redirect", "Found", "SeeOther", "NotModified", "TempRedirect", 
    "redirect", "found", "seeother", "notmodified", "tempredirect",

    # 400, 401, 403, 404, 405, 406, 409, 410, 412
    "BadRequest", "Unauthorized", "Forbidden", "NoMethod", "NotFound", "NotAcceptable", "Conflict", "Gone", "PreconditionFailed",
    "badrequest", "unauthorized", "forbidden", "nomethod", "notfound", "notacceptable", "conflict", "gone", "preconditionfailed",

    # 500
    "InternalError", 
    "internalerror",
]

import sys, cgi, Cookie, pprint, urlparse, urllib
from utils import storage, storify, threadeddict, dictadd, intget, utf8

config = storage()
config.__doc__ = """
A configuration object for various aspects of web.py.

`debug`
   : when True, enables reloading, disabled template caching and sets internalerror to debugerror.
"""

</t>
<t tx="zhanglei.20100830144432.1763">class HTTPError(Exception):
    @others
</t>
<t tx="zhanglei.20100830144432.1764">def __init__(self, status, headers={}, data=""):
    ctx.status = status
    for k, v in headers.items():
        header(k, v)
    self.data = data
    Exception.__init__(self, status)

</t>
<t tx="zhanglei.20100830144432.1765">def _status_code(status, data=None, classname=None, docstring=None):
    if data is None:
        data = status.split(" ", 1)[1]
    classname = status.split(" ", 1)[1].replace(' ', '') # 304 Not Modified -&gt; NotModified    
    docstring = docstring or '`%s` status' % status

    def __init__(self, data=data, headers={}):
        HTTPError.__init__(self, status, headers, data)

    # trick to create class dynamically with dynamic docstring.
    return type(classname, (HTTPError, object), {
        '__doc__': docstring,
        '__init__': __init__
    })

</t>
<t tx="zhanglei.20100830144432.1766">ok = OK = _status_code("200 OK", data="")
created = Created = _status_code("201 Created")
accepted = Accepted = _status_code("202 Accepted")

class Redirect(HTTPError):
    """A `301 Moved Permanently` redirect."""
    @others
</t>
<t tx="zhanglei.20100830144432.1767">def __init__(self, url, status='301 Moved Permanently', absolute=False):
    """
    Returns a `status` redirect to the new URL. 
    `url` is joined with the base URL so that things like 
    `redirect("about") will work properly.
    """
    newloc = urlparse.urljoin(ctx.path, url)

    if newloc.startswith('/'):
        if absolute:
            home = ctx.realhome
        else:
            home = ctx.home
        newloc = home + newloc

    headers = {
        'Content-Type': 'text/html',
        'Location': newloc
    }
    HTTPError.__init__(self, status, headers, "")

</t>
<t tx="zhanglei.20100830144432.1768">redirect = Redirect

class Found(Redirect):
    """A `302 Found` redirect."""
    @others
</t>
<t tx="zhanglei.20100830144432.1769">def __init__(self, url, absolute=False):
    Redirect.__init__(self, url, '302 Found', absolute=absolute)

</t>
<t tx="zhanglei.20100830144432.1770">found = Found

class SeeOther(Redirect):
    """A `303 See Other` redirect."""
    @others
</t>
<t tx="zhanglei.20100830144432.1771">def __init__(self, url, absolute=False):
    Redirect.__init__(self, url, '303 See Other', absolute=absolute)

</t>
<t tx="zhanglei.20100830144432.1772">seeother = SeeOther

class NotModified(HTTPError):
    """A `304 Not Modified` status."""
    @others
</t>
<t tx="zhanglei.20100830144432.1773">def __init__(self):
    HTTPError.__init__(self, "304 Not Modified")

</t>
<t tx="zhanglei.20100830144432.1774">notmodified = NotModified

class TempRedirect(Redirect):
    """A `307 Temporary Redirect` redirect."""
    @others
</t>
<t tx="zhanglei.20100830144432.1775">def __init__(self, url, absolute=False):
    Redirect.__init__(self, url, '307 Temporary Redirect', absolute=absolute)

</t>
<t tx="zhanglei.20100830144432.1776">tempredirect = TempRedirect

class BadRequest(HTTPError):
    """`400 Bad Request` error."""
    message = "bad request"
    @others
</t>
<t tx="zhanglei.20100830144432.1777">def __init__(self):
    status = "400 Bad Request"
    headers = {'Content-Type': 'text/html'}
    HTTPError.__init__(self, status, headers, self.message)

</t>
<t tx="zhanglei.20100830144432.1778">badrequest = BadRequest

class _NotFound(HTTPError):
    """`404 Not Found` error."""
    message = "not found"
    @others
</t>
<t tx="zhanglei.20100830144432.1779">def __init__(self, message=None):
    status = '404 Not Found'
    headers = {'Content-Type': 'text/html'}
    HTTPError.__init__(self, status, headers, message or self.message)

</t>
<t tx="zhanglei.20100830144432.1780">def NotFound(message=None):
    """Returns HTTPError with '404 Not Found' error from the active application.
    """
    if message:
        return _NotFound(message)
    elif ctx.get('app_stack'):
        return ctx.app_stack[-1].notfound()
    else:
        return _NotFound()

</t>
<t tx="zhanglei.20100830144432.1781">notfound = NotFound

unauthorized = Unauthorized = _status_code("401 Unauthorized")
forbidden = Forbidden = _status_code("403 Forbidden")
notacceptable = NotAcceptable = _status_code("406 Not Acceptable")
conflict = Conflict = _status_code("409 Conflict")
preconditionfailed = PreconditionFailed = _status_code("412 Precondition Failed")

class NoMethod(HTTPError):
    """A `405 Method Not Allowed` error."""
    @others
</t>
<t tx="zhanglei.20100830144432.1782">def __init__(self, cls=None):
    status = '405 Method Not Allowed'
    headers = {}
    headers['Content-Type'] = 'text/html'

    methods = ['GET', 'HEAD', 'POST', 'PUT', 'DELETE']
    if cls:
        methods = [method for method in methods if hasattr(cls, method)]

    headers['Allow'] = ', '.join(methods)
    data = None
    HTTPError.__init__(self, status, headers, data)

</t>
<t tx="zhanglei.20100830144432.1783">nomethod = NoMethod

class Gone(HTTPError):
    """`410 Gone` error."""
    message = "gone"
    @others
</t>
<t tx="zhanglei.20100830144432.1784">def __init__(self):
    status = '410 Gone'
    headers = {'Content-Type': 'text/html'}
    HTTPError.__init__(self, status, headers, self.message)

</t>
<t tx="zhanglei.20100830144432.1785">gone = Gone

class _InternalError(HTTPError):
    """500 Internal Server Error`."""
    message = "internal server error"

    @others
</t>
<t tx="zhanglei.20100830144432.1786">def __init__(self, message=None):
    status = '500 Internal Server Error'
    headers = {'Content-Type': 'text/html'}
    HTTPError.__init__(self, status, headers, message or self.message)

</t>
<t tx="zhanglei.20100830144432.1787">def InternalError(message=None):
    """Returns HTTPError with '500 internal error' error from the active application.
    """
    if message:
        return _InternalError(message)
    elif ctx.get('app_stack'):
        return ctx.app_stack[-1].internalerror()
    else:
        return _InternalError()

</t>
<t tx="zhanglei.20100830144432.1788">internalerror = InternalError

def header(hdr, value, unique=False):
    """
    Adds the header `hdr: value` with the response.

    If `unique` is True and a header with that name already exists,
    it doesn't add a new one. 
    """
    hdr, value = utf8(hdr), utf8(value)
    # protection against HTTP response splitting attack
    if '\n' in hdr or '\r' in hdr or '\n' in value or '\r' in value:
        raise ValueError, 'invalid characters in header'

    if unique is True:
        for h, v in ctx.headers:
            if h.lower() == hdr.lower(): return

    ctx.headers.append((hdr, value))

</t>
<t tx="zhanglei.20100830144432.1789">def rawinput(method=None):
    """Returns storage object with GET or POST arguments.
    """
    method = method or "both"
    from cStringIO import StringIO

    def dictify(fs): 
        # hack to make web.input work with enctype='text/plain.
        if fs.list is None:
            fs.list = [] 

        return dict([(k, fs[k]) for k in fs.keys()])

    e = ctx.env.copy()
    a = b = {}

    if method.lower() in ['both', 'post', 'put']:
        if e['REQUEST_METHOD'] in ['POST', 'PUT']:
            if e.get('CONTENT_TYPE', '').lower().startswith('multipart/'):
                # since wsgi.input is directly passed to cgi.FieldStorage, 
                # it can not be called multiple times. Saving the FieldStorage
                # object in ctx to allow calling web.input multiple times.
                a = ctx.get('_fieldstorage')
                if not a:
                    fp = e['wsgi.input']
                    a = cgi.FieldStorage(fp=fp, environ=e, keep_blank_values=1)
                    ctx._fieldstorage = a
            else:
                fp = StringIO(data())
                a = cgi.FieldStorage(fp=fp, environ=e, keep_blank_values=1)
            a = dictify(a)

    if method.lower() in ['both', 'get']:
        e['REQUEST_METHOD'] = 'GET'
        b = dictify(cgi.FieldStorage(environ=e, keep_blank_values=1))

    def process_fieldstorage(fs):
        if isinstance(fs, list):
            return [process_fieldstorage(x) for x in fs]
        elif fs.filename is None:
            return fs.value
        else:
            return fs

    return storage([(k, process_fieldstorage(v)) for k, v in dictadd(b, a).items()])

</t>
<t tx="zhanglei.20100830144432.1790">def input(*requireds, **defaults):
    """
    Returns a `storage` object with the GET and POST arguments. 
    See `storify` for how `requireds` and `defaults` work.
    """
    _method = defaults.pop('_method', 'both')
    out = rawinput(_method)
    try:
        defaults.setdefault('_unicode', True) # force unicode conversion by default.
        return storify(out, *requireds, **defaults)
    except KeyError:
        raise badrequest()

</t>
<t tx="zhanglei.20100830144432.1791">def data():
    """Returns the data sent with the request."""
    if 'data' not in ctx:
        cl = intget(ctx.env.get('CONTENT_LENGTH'), 0)
        ctx.data = ctx.env['wsgi.input'].read(cl)
    return ctx.data

</t>
<t tx="zhanglei.20100830144432.1792">def setcookie(name, value, expires="", domain=None, secure=False):
    """Sets a cookie."""
    if expires &lt; 0: 
        expires = -1000000000 
    kargs = {'expires': expires, 'path':'/'}
    if domain: 
        kargs['domain'] = domain
    if secure:
        kargs['secure'] = secure
    # @@ should we limit cookies to a different path?
    cookie = Cookie.SimpleCookie()
    cookie[name] = urllib.quote(utf8(value))
    for key, val in kargs.iteritems(): 
        cookie[name][key] = val
    header('Set-Cookie', cookie.items()[0][1].OutputString())

</t>
<t tx="zhanglei.20100830144432.1793">def cookies(*requireds, **defaults):
    """
    Returns a `storage` object with all the cookies in it.
    See `storify` for how `requireds` and `defaults` work.
    """
    cookie = Cookie.SimpleCookie()
    cookie.load(ctx.env.get('HTTP_COOKIE', ''))
    try:
        d = storify(cookie, *requireds, **defaults)
        for k, v in d.items():
            d[k] = v and urllib.unquote(v)
        return d
    except KeyError:
        badrequest()
        raise StopIteration

</t>
<t tx="zhanglei.20100830144432.1794">def debug(*args):
    """
    Prints a prettyprinted version of `args` to stderr.
    """
    try: 
        out = ctx.environ['wsgi.errors']
    except: 
        out = sys.stderr
    for arg in args:
        print &gt;&gt; out, pprint.pformat(arg)
    return ''

</t>
<t tx="zhanglei.20100830144432.1795">def _debugwrite(x):
    try: 
        out = ctx.environ['wsgi.errors']
    except: 
        out = sys.stderr
    out.write(x)
</t>
<t tx="zhanglei.20100830144432.1796">@language python
@tabwidth -4
@others
@ignore</t>
<t tx="zhanglei.20100830144432.1797">"""openid.py: an openid library for web.py

Notes:

 - This will create a file called .openid_secret_key in the 
   current directory with your secret key in it. If someone 
   has access to this file they can log in as any user. And 
   if the app can't find this file for any reason (e.g. you 
   moved the app somewhere else) then each currently logged 
   in user will get logged out.

 - State must be maintained through the entire auth process 
   -- this means that if you have multiple web.py processes 
   serving one set of URLs or if you restart your app often 
   then log ins will fail. You have to replace sessions and 
   store for things to work.

 - We set cookies starting with "openid_".

"""

import os
import random
import hmac
import __init__ as web
import openid.consumer.consumer
import openid.store.memstore

sessions = {}
store = openid.store.memstore.MemoryStore()

</t>
<t tx="zhanglei.20100830144432.1798">def _secret():
    try:
        secret = file('.openid_secret_key').read()
    except IOError:
        # file doesn't exist
        secret = os.urandom(20)
        file('.openid_secret_key', 'w').write(secret)
    return secret

</t>
<t tx="zhanglei.20100830144432.1799">def _hmac(identity_url):
    return hmac.new(_secret(), identity_url).hexdigest()

</t>
<t tx="zhanglei.20100830144432.1800">def _random_session():
    n = random.random()
    while n in sessions:
        n = random.random()
    n = str(n)
    return n

</t>
<t tx="zhanglei.20100830144432.1801">def status():
    oid_hash = web.cookies().get('openid_identity_hash', '').split(',', 1)
    if len(oid_hash) &gt; 1:
        oid_hash, identity_url = oid_hash
        if oid_hash == _hmac(identity_url):
            return identity_url
    return None

</t>
<t tx="zhanglei.20100830144432.1802">def form(openid_loc):
    oid = status()
    if oid:
        return '''
        &lt;form method="post" action="%s"&gt;
          &lt;img src="http://openid.net/login-bg.gif" alt="OpenID" /&gt;
          &lt;strong&gt;%s&lt;/strong&gt;
          &lt;input type="hidden" name="action" value="logout" /&gt;
          &lt;input type="hidden" name="return_to" value="%s" /&gt;
          &lt;button type="submit"&gt;log out&lt;/button&gt;
        &lt;/form&gt;''' % (openid_loc, oid, web.ctx.fullpath)
    else:
        return '''
        &lt;form method="post" action="%s"&gt;
          &lt;input type="text" name="openid" value="" 
            style="background: url(http://openid.net/login-bg.gif) no-repeat; padding-left: 18px; background-position: 0 50%%;" /&gt;
          &lt;input type="hidden" name="return_to" value="%s" /&gt;
          &lt;button type="submit"&gt;log in&lt;/button&gt;
        &lt;/form&gt;''' % (openid_loc, web.ctx.fullpath)

</t>
<t tx="zhanglei.20100830144432.1803">def logout():
    web.setcookie('openid_identity_hash', '', expires=-1)

</t>
<t tx="zhanglei.20100830144432.1804">class host:
    @others
</t>
<t tx="zhanglei.20100830144432.1805">def POST(self):
    # unlike the usual scheme of things, the POST is actually called
    # first here
    i = web.input(return_to='/')
    if i.get('action') == 'logout':
        logout()
        return web.redirect(i.return_to)

    i = web.input('openid', return_to='/')

    n = _random_session()
    sessions[n] = {'webpy_return_to': i.return_to}

    c = openid.consumer.consumer.Consumer(sessions[n], store)
    a = c.begin(i.openid)
    f = a.redirectURL(web.ctx.home, web.ctx.home + web.ctx.fullpath)

    web.setcookie('openid_session_id', n)
    return web.redirect(f)

</t>
<t tx="zhanglei.20100830144432.1806">def GET(self):
    n = web.cookies('openid_session_id').openid_session_id
    web.setcookie('openid_session_id', '', expires=-1)
    return_to = sessions[n]['webpy_return_to']

    c = openid.consumer.consumer.Consumer(sessions[n], store)
    a = c.complete(web.input(), web.ctx.home + web.ctx.fullpath)

    if a.status.lower() == 'success':
        web.setcookie('openid_identity_hash', _hmac(a.identity_url) + ',' + a.identity_url)

    del sessions[n]
    return web.redirect(return_to)
</t>
<t tx="zhanglei.20100830144432.1807">@language python
@tabwidth -4
@ignore
@others
# When running the builtin-server, enable debug mode if not already set.
web.config.setdefault('debug', _is_dev_mode())
</t>
<t tx="zhanglei.20100830144432.1808">"""
WSGI Utilities
(from web.py)
"""

import os, sys

import http
import webapi as web
from utils import listget
from net import validaddr, validip
import httpserver

</t>
<t tx="zhanglei.20100830144432.1809">def runfcgi(func, addr=('localhost', 8000)):
    """Runs a WSGI function as a FastCGI server."""
    import flup.server.fcgi as flups
    return flups.WSGIServer(func, multiplexed=True, bindAddress=addr).run()

</t>
<t tx="zhanglei.20100830144432.1810">def runscgi(func, addr=('localhost', 4000)):
    """Runs a WSGI function as an SCGI server."""
    import flup.server.scgi as flups
    return flups.WSGIServer(func, bindAddress=addr).run()

</t>
<t tx="zhanglei.20100830144432.1811">def runwsgi(func):
    """
    Runs a WSGI-compatible `func` using FCGI, SCGI, or a simple web server,
    as appropriate based on context and `sys.argv`.
    """

    if os.environ.has_key('SERVER_SOFTWARE'): # cgi
        os.environ['FCGI_FORCE_CGI'] = 'Y'

    if (os.environ.has_key('PHP_FCGI_CHILDREN') #lighttpd fastcgi
      or os.environ.has_key('SERVER_SOFTWARE')):
        return runfcgi(func, None)

    if 'fcgi' in sys.argv or 'fastcgi' in sys.argv:
        args = sys.argv[1:]
        if 'fastcgi' in args: args.remove('fastcgi')
        elif 'fcgi' in args: args.remove('fcgi')
        if args:
            return runfcgi(func, validaddr(args[0]))
        else:
            return runfcgi(func, None)

    if 'scgi' in sys.argv:
        args = sys.argv[1:]
        args.remove('scgi')
        if args:
            return runscgi(func, validaddr(args[0]))
        else:
            return runscgi(func)

    return httpserver.runsimple(func, validip(listget(sys.argv, 1, '')))

</t>
<t tx="zhanglei.20100830144432.1812">def _is_dev_mode():
    # quick hack to check if the program is running in dev mode.
    if os.environ.has_key('SERVER_SOFTWARE') \
        or os.environ.has_key('PHP_FCGI_CHILDREN') \
        or 'fcgi' in sys.argv or 'fastcgi' in sys.argv \
        or 'mod_wsgi' in sys.argv:
            return False
    return True

</t>
<t tx="zhanglei.20100830144432.1813"></t>
<t tx="zhanglei.20100830144432.1814"></t>
<t tx="zhanglei.20100830144432.1815">@language python
@tabwidth -4
@others
@ignore</t>
<t tx="zhanglei.20100830144432.1816">"""A high-speed, production ready, thread pooled, generic WSGI server.

Simplest example on how to use this module directly
(without using CherryPy's application machinery):

    from cherrypy import wsgiserver

    def my_crazy_app(environ, start_response):
        status = '200 OK'
        response_headers = [('Content-type','text/plain')]
        start_response(status, response_headers)
        return ['Hello world!\n']

    server = wsgiserver.CherryPyWSGIServer(
                ('0.0.0.0', 8070), my_crazy_app,
                server_name='www.cherrypy.example')

The CherryPy WSGI server can serve as many WSGI applications 
as you want in one instance by using a WSGIPathInfoDispatcher:

    d = WSGIPathInfoDispatcher({'/': my_crazy_app, '/blog': my_blog_app})
    server = wsgiserver.CherryPyWSGIServer(('0.0.0.0', 80), d)

Want SSL support? Just set these attributes:

    server.ssl_certificate = &lt;filename&gt;
    server.ssl_private_key = &lt;filename&gt;

    if __name__ == '__main__':
        try:
            server.start()
        except KeyboardInterrupt:
            server.stop()

This won't call the CherryPy engine (application side) at all, only the
WSGI server, which is independant from the rest of CherryPy. Don't
let the name "CherryPyWSGIServer" throw you; the name merely reflects
its origin, not its coupling.

For those of you wanting to understand internals of this module, here's the
basic call flow. The server's listening thread runs a very tight loop,
sticking incoming connections onto a Queue:

    server = CherryPyWSGIServer(...)
    server.start()
    while True:
        tick()
        # This blocks until a request comes in:
        child = socket.accept()
        conn = HTTPConnection(child, ...)
        server.requests.put(conn)

Worker threads are kept in a pool and poll the Queue, popping off and then
handling each connection in turn. Each connection can consist of an arbitrary
number of requests and their responses, so we run a nested loop:

    while True:
        conn = server.requests.get()
        conn.communicate()
        -&gt;  while True:
                req = HTTPRequest(...)
                req.parse_request()
                -&gt;  # Read the Request-Line, e.g. "GET /page HTTP/1.1"
                    req.rfile.readline()
                    req.read_headers()
                req.respond()
                -&gt;  response = wsgi_app(...)
                    try:
                        for chunk in response:
                            if chunk:
                                req.write(chunk)
                    finally:
                        if hasattr(response, "close"):
                            response.close()
                if req.close_connection:
                    return
"""


import base64
import os
import Queue
import re
quoted_slash = re.compile("(?i)%2F")
import rfc822
import socket
try:
    import cStringIO as StringIO
except ImportError:
    import StringIO

_fileobject_uses_str_type = isinstance(socket._fileobject(None)._rbuf, basestring)

import sys
import threading
import time
import traceback
from urllib import unquote
from urlparse import urlparse
import warnings

try:
    from OpenSSL import SSL
    from OpenSSL import crypto
except ImportError:
    SSL = None

import errno


def plat_specific_errors(*errnames):
    """Return error numbers for all errors in errnames on this platform.

    The 'errno' module contains different global constants depending on
    the specific platform (OS). This function will return the list of
    numeric values for a given list of potential names.
    """
    errno_names = dir(errno)
    nums = [getattr(errno, k) for k in errnames if k in errno_names]
    # de-dupe the list
    return dict.fromkeys(nums).keys()


socket_error_eintr = plat_specific_errors("EINTR", "WSAEINTR")

socket_errors_to_ignore = plat_specific_errors(
    "EPIPE",
    "EBADF", "WSAEBADF",
    "ENOTSOCK", "WSAENOTSOCK",
    "ETIMEDOUT", "WSAETIMEDOUT",
    "ECONNREFUSED", "WSAECONNREFUSED",
    "ECONNRESET", "WSAECONNRESET",
    "ECONNABORTED", "WSAECONNABORTED",
    "ENETRESET", "WSAENETRESET",
    "EHOSTDOWN", "EHOSTUNREACH",
    )
socket_errors_to_ignore.append("timed out")

socket_errors_nonblocking = plat_specific_errors(
    'EAGAIN', 'EWOULDBLOCK', 'WSAEWOULDBLOCK')

comma_separated_headers = ['ACCEPT', 'ACCEPT-CHARSET', 'ACCEPT-ENCODING',
    'ACCEPT-LANGUAGE', 'ACCEPT-RANGES', 'ALLOW', 'CACHE-CONTROL',
    'CONNECTION', 'CONTENT-ENCODING', 'CONTENT-LANGUAGE', 'EXPECT',
    'IF-MATCH', 'IF-NONE-MATCH', 'PRAGMA', 'PROXY-AUTHENTICATE', 'TE',
    'TRAILER', 'TRANSFER-ENCODING', 'UPGRADE', 'VARY', 'VIA', 'WARNING',
    'WWW-AUTHENTICATE']


class WSGIPathInfoDispatcher(object):
    """A WSGI dispatcher for dispatch based on the PATH_INFO.

    apps: a dict or list of (path_prefix, app) pairs.
    """


    def __init__(self, apps):
        try:
            apps = apps.items()
        except AttributeError:
            pass

        # Sort the apps by len(path), descending
        apps.sort()
        apps.reverse()

        # The path_prefix strings must start, but not end, with a slash.
        # Use "" instead of "/".
        self.apps = [(p.rstrip("/"), a) for p, a in apps]


    def __call__(self, environ, start_response):
        path = environ["PATH_INFO"] or "/"
        for p, app in self.apps:
            # The apps list should be sorted by length, descending.
            if path.startswith(p + "/") or path == p:
                environ = environ.copy()
                environ["SCRIPT_NAME"] = environ["SCRIPT_NAME"] + p
                environ["PATH_INFO"] = path[len(p):]
                return app(environ, start_response)

        start_response('404 Not Found', [('Content-Type', 'text/plain'),
                                         ('Content-Length', '0')])
        return ['']



class MaxSizeExceeded(Exception):
    pass


class SizeCheckWrapper(object):
    """Wraps a file-like object, raising MaxSizeExceeded if too large."""

    def __init__(self, rfile, maxlen):
        self.rfile = rfile
        self.maxlen = maxlen
        self.bytes_read = 0


    def _check_length(self):
        if self.maxlen and self.bytes_read &gt; self.maxlen:
            raise MaxSizeExceeded()


    def read(self, size=None):
        data = self.rfile.read(size)
        self.bytes_read += len(data)
        self._check_length()
        return data


    def readline(self, size=None):
        if size is not None:
            data = self.rfile.readline(size)
            self.bytes_read += len(data)
            self._check_length()
            return data

        # User didn't specify a size ...
        # We read the line in chunks to make sure it's not a 100MB line !
        res = []
        while True:
            data = self.rfile.readline(256)
            self.bytes_read += len(data)
            self._check_length()
            res.append(data)
            # See http://www.cherrypy.org/ticket/421
            if len(data) &lt; 256 or data[-1:] == "\n":
                return ''.join(res)


    def readlines(self, sizehint=0):
        # Shamelessly stolen from StringIO
        total = 0
        lines = []
        line = self.readline()
        while line:
            lines.append(line)
            total += len(line)
            if 0 &lt; sizehint &lt;= total:
                break
            line = self.readline()
        return lines


    def close(self):
        self.rfile.close()


    def __iter__(self):
        return self


    def next(self):
        data = self.rfile.next()
        self.bytes_read += len(data)
        self._check_length()
        return data



class HTTPRequest(object):
    """An HTTP Request (and response).

    A single HTTP connection may consist of multiple request/response pairs.

    send: the 'send' method from the connection's socket object.
    wsgi_app: the WSGI application to call.
    environ: a partial WSGI environ (server and connection entries).
        The caller MUST set the following entries:
        * All wsgi.* entries, including .input
        * SERVER_NAME and SERVER_PORT
        * Any SSL_* entries
        * Any custom entries like REMOTE_ADDR and REMOTE_PORT
        * SERVER_SOFTWARE: the value to write in the "Server" response header.
        * ACTUAL_SERVER_PROTOCOL: the value to write in the Status-Line of
            the response. From RFC 2145: "An HTTP server SHOULD send a
            response version equal to the highest version for which the
            server is at least conditionally compliant, and whose major
            version is less than or equal to the one received in the
            request.  An HTTP server MUST NOT send a version for which
            it is not at least conditionally compliant."

    outheaders: a list of header tuples to write in the response.
    ready: when True, the request has been parsed and is ready to begin
        generating the response. When False, signals the calling Connection
        that the response should not be generated and the connection should
        close.
    close_connection: signals the calling Connection that the request
        should close. This does not imply an error! The client and/or
        server may each request that the connection be closed.
    chunked_write: if True, output will be encoded with the "chunked"
        transfer-coding. This value is set automatically inside
        send_headers.
    """

    max_request_header_size = 0
    max_request_body_size = 0

    @others
</t>
<t tx="zhanglei.20100830144432.1832">def __init__(self, wfile, environ, wsgi_app):
    self.rfile = environ['wsgi.input']
    self.wfile = wfile
    self.environ = environ.copy()
    self.wsgi_app = wsgi_app

    self.ready = False
    self.started_response = False
    self.status = ""
    self.outheaders = []
    self.sent_headers = False
    self.close_connection = False
    self.chunked_write = False

</t>
<t tx="zhanglei.20100830144432.1833">def parse_request(self):
    """Parse the next HTTP request start-line and message-headers."""
    self.rfile.maxlen = self.max_request_header_size
    self.rfile.bytes_read = 0

    try:
        self._parse_request()
    except MaxSizeExceeded:
        self.simple_response("413 Request Entity Too Large")
        return

</t>
<t tx="zhanglei.20100830144432.1834">def _parse_request(self):
    # HTTP/1.1 connections are persistent by default. If a client
    # requests a page, then idles (leaves the connection open),
    # then rfile.readline() will raise socket.error("timed out").
    # Note that it does this based on the value given to settimeout(),
    # and doesn't need the client to request or acknowledge the close
    # (although your TCP stack might suffer for it: cf Apache's history
    # with FIN_WAIT_2).
    request_line = self.rfile.readline()
    if not request_line:
        # Force self.ready = False so the connection will close.
        self.ready = False
        return

    if request_line == "\r\n":
        # RFC 2616 sec 4.1: "...if the server is reading the protocol
        # stream at the beginning of a message and receives a CRLF
        # first, it should ignore the CRLF."
        # But only ignore one leading line! else we enable a DoS.
        request_line = self.rfile.readline()
        if not request_line:
            self.ready = False
            return

    environ = self.environ

    try:
        method, path, req_protocol = request_line.strip().split(" ", 2)
    except ValueError:
        self.simple_response(400, "Malformed Request-Line")
        return

    environ["REQUEST_METHOD"] = method

    # path may be an abs_path (including "http://host.domain.tld");
    scheme, location, path, params, qs, frag = urlparse(path)

    if frag:
        self.simple_response("400 Bad Request",
                             "Illegal #fragment in Request-URI.")
        return

    if scheme:
        environ["wsgi.url_scheme"] = scheme
    if params:
        path = path + ";" + params

    environ["SCRIPT_NAME"] = ""

    # Unquote the path+params (e.g. "/this%20path" -&gt; "this path").
    # http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.2
    #
    # But note that "...a URI must be separated into its components
    # before the escaped characters within those components can be
    # safely decoded." http://www.ietf.org/rfc/rfc2396.txt, sec 2.4.2
    atoms = [unquote(x) for x in quoted_slash.split(path)]
    path = "%2F".join(atoms)
    environ["PATH_INFO"] = path

    # Note that, like wsgiref and most other WSGI servers,
    # we unquote the path but not the query string.
    environ["QUERY_STRING"] = qs

    # Compare request and server HTTP protocol versions, in case our
    # server does not support the requested protocol. Limit our output
    # to min(req, server). We want the following output:
    #     request    server     actual written   supported response
    #     protocol   protocol  response protocol    feature set
    # a     1.0        1.0           1.0                1.0
    # b     1.0        1.1           1.1                1.0
    # c     1.1        1.0           1.0                1.0
    # d     1.1        1.1           1.1                1.1
    # Notice that, in (b), the response will be "HTTP/1.1" even though
    # the client only understands 1.0. RFC 2616 10.5.6 says we should
    # only return 505 if the _major_ version is different.
    rp = int(req_protocol[5]), int(req_protocol[7])
    server_protocol = environ["ACTUAL_SERVER_PROTOCOL"]
    sp = int(server_protocol[5]), int(server_protocol[7])
    if sp[0] != rp[0]:
        self.simple_response("505 HTTP Version Not Supported")
        return
    # Bah. "SERVER_PROTOCOL" is actually the REQUEST protocol.
    environ["SERVER_PROTOCOL"] = req_protocol
    self.response_protocol = "HTTP/%s.%s" % min(rp, sp)

    # If the Request-URI was an absoluteURI, use its location atom.
    if location:
        environ["SERVER_NAME"] = location

    # then all the http headers
    try:
        self.read_headers()
    except ValueError, ex:
        self.simple_response("400 Bad Request", repr(ex.args))
        return

    mrbs = self.max_request_body_size
    if mrbs and int(environ.get("CONTENT_LENGTH", 0)) &gt; mrbs:
        self.simple_response("413 Request Entity Too Large")
        return

    # Persistent connection support
    if self.response_protocol == "HTTP/1.1":
        # Both server and client are HTTP/1.1
        if environ.get("HTTP_CONNECTION", "") == "close":
            self.close_connection = True
    else:
        # Either the server or client (or both) are HTTP/1.0
        if environ.get("HTTP_CONNECTION", "") != "Keep-Alive":
            self.close_connection = True

    # Transfer-Encoding support
    te = None
    if self.response_protocol == "HTTP/1.1":
        te = environ.get("HTTP_TRANSFER_ENCODING")
        if te:
            te = [x.strip().lower() for x in te.split(",") if x.strip()]

    self.chunked_read = False

    if te:
        for enc in te:
            if enc == "chunked":
                self.chunked_read = True
            else:
                # Note that, even if we see "chunked", we must reject
                # if there is an extension we don't recognize.
                self.simple_response("501 Unimplemented")
                self.close_connection = True
                return

    # From PEP 333:
    # "Servers and gateways that implement HTTP 1.1 must provide
    # transparent support for HTTP 1.1's "expect/continue" mechanism.
    # This may be done in any of several ways:
    #   1. Respond to requests containing an Expect: 100-continue request
    #      with an immediate "100 Continue" response, and proceed normally.
    #   2. Proceed with the request normally, but provide the application
    #      with a wsgi.input stream that will send the "100 Continue"
    #      response if/when the application first attempts to read from
    #      the input stream. The read request must then remain blocked
    #      until the client responds.
    #   3. Wait until the client decides that the server does not support
    #      expect/continue, and sends the request body on its own.
    #      (This is suboptimal, and is not recommended.)
    #
    # We used to do 3, but are now doing 1. Maybe we'll do 2 someday,
    # but it seems like it would be a big slowdown for such a rare case.
    if environ.get("HTTP_EXPECT", "") == "100-continue":
        self.simple_response(100)

    self.ready = True

</t>
<t tx="zhanglei.20100830144432.1835">def read_headers(self):
    """Read header lines from the incoming stream."""
    environ = self.environ

    while True:
        line = self.rfile.readline()
        if not line:
            # No more data--illegal end of headers
            raise ValueError("Illegal end of headers.")

        if line == '\r\n':
            # Normal end of headers
            break

        if line[0] in ' \t':
            # It's a continuation line.
            v = line.strip()
        else:
            k, v = line.split(":", 1)
            k, v = k.strip().upper(), v.strip()
            envname = "HTTP_" + k.replace("-", "_")

        if k in comma_separated_headers:
            existing = environ.get(envname)
            if existing:
                v = ", ".join((existing, v))
        environ[envname] = v

    ct = environ.pop("HTTP_CONTENT_TYPE", None)
    if ct is not None:
        environ["CONTENT_TYPE"] = ct
    cl = environ.pop("HTTP_CONTENT_LENGTH", None)
    if cl is not None:
        environ["CONTENT_LENGTH"] = cl

</t>
<t tx="zhanglei.20100830144432.1836">def decode_chunked(self):
    """Decode the 'chunked' transfer coding."""
    cl = 0
    data = StringIO.StringIO()
    while True:
        line = self.rfile.readline().strip().split(";", 1)
        chunk_size = int(line.pop(0), 16)
        if chunk_size &lt;= 0:
            break
##            if line: chunk_extension = line[0]
        cl += chunk_size
        data.write(self.rfile.read(chunk_size))
        crlf = self.rfile.read(2)
        if crlf != "\r\n":
            self.simple_response("400 Bad Request",
                                 "Bad chunked transfer coding "
                                 "(expected '\\r\\n', got %r)" % crlf)
            return

    # Grab any trailer headers
    self.read_headers()

    data.seek(0)
    self.environ["wsgi.input"] = data
    self.environ["CONTENT_LENGTH"] = str(cl) or ""
    return True

</t>
<t tx="zhanglei.20100830144432.1837">def respond(self):
    """Call the appropriate WSGI app and write its iterable output."""
    # Set rfile.maxlen to ensure we don't read past Content-Length.
    # This will also be used to read the entire request body if errors
    # are raised before the app can read the body.
    if self.chunked_read:
        # If chunked, Content-Length will be 0.
        self.rfile.maxlen = self.max_request_body_size
    else:
        cl = int(self.environ.get("CONTENT_LENGTH", 0))
        if self.max_request_body_size:
            self.rfile.maxlen = min(cl, self.max_request_body_size)
        else:
            self.rfile.maxlen = cl
    self.rfile.bytes_read = 0

    try:
        self._respond()
    except MaxSizeExceeded:
        if not self.sent_headers:
            self.simple_response("413 Request Entity Too Large")
        return

</t>
<t tx="zhanglei.20100830144432.1838">def _respond(self):
    if self.chunked_read:
        if not self.decode_chunked():
            self.close_connection = True
            return

    response = self.wsgi_app(self.environ, self.start_response)
    try:
        for chunk in response:
            # "The start_response callable must not actually transmit
            # the response headers. Instead, it must store them for the
            # server or gateway to transmit only after the first
            # iteration of the application return value that yields
            # a NON-EMPTY string, or upon the application's first
            # invocation of the write() callable." (PEP 333)
            if chunk:
                self.write(chunk)
    finally:
        if hasattr(response, "close"):
            response.close()

    if (self.ready and not self.sent_headers):
        self.sent_headers = True
        self.send_headers()
    if self.chunked_write:
        self.wfile.sendall("0\r\n\r\n")

</t>
<t tx="zhanglei.20100830144432.1839">def simple_response(self, status, msg=""):
    """Write a simple response back to the client."""
    status = str(status)
    buf = ["%s %s\r\n" % (self.environ['ACTUAL_SERVER_PROTOCOL'], status),
           "Content-Length: %s\r\n" % len(msg),
           "Content-Type: text/plain\r\n"]

    if status[:3] == "413" and self.response_protocol == 'HTTP/1.1':
        # Request Entity Too Large
        self.close_connection = True
        buf.append("Connection: close\r\n")

    buf.append("\r\n")
    if msg:
        buf.append(msg)

    try:
        self.wfile.sendall("".join(buf))
    except socket.error, x:
        if x.args[0] not in socket_errors_to_ignore:
            raise

</t>
<t tx="zhanglei.20100830144432.1840">def start_response(self, status, headers, exc_info = None):
    """WSGI callable to begin the HTTP response."""
    # "The application may call start_response more than once,
    # if and only if the exc_info argument is provided."
    if self.started_response and not exc_info:
        raise AssertionError("WSGI start_response called a second "
                             "time with no exc_info.")

    # "if exc_info is provided, and the HTTP headers have already been
    # sent, start_response must raise an error, and should raise the
    # exc_info tuple."
    if self.sent_headers:
        try:
            raise exc_info[0], exc_info[1], exc_info[2]
        finally:
            exc_info = None

    self.started_response = True
    self.status = status
    self.outheaders.extend(headers)
    return self.write

</t>
<t tx="zhanglei.20100830144432.1841">def write(self, chunk):
    """WSGI callable to write unbuffered data to the client.

    This method is also used internally by start_response (to write
    data from the iterable returned by the WSGI application).
    """
    if not self.started_response:
        raise AssertionError("WSGI write called before start_response.")

    if not self.sent_headers:
        self.sent_headers = True
        self.send_headers()

    if self.chunked_write and chunk:
        buf = [hex(len(chunk))[2:], "\r\n", chunk, "\r\n"]
        self.wfile.sendall("".join(buf))
    else:
        self.wfile.sendall(chunk)

</t>
<t tx="zhanglei.20100830144432.1842">def send_headers(self):
    """Assert, process, and send the HTTP response message-headers."""
    hkeys = [key.lower() for key, value in self.outheaders]
    status = int(self.status[:3])

    if status == 413:
        # Request Entity Too Large. Close conn to avoid garbage.
        self.close_connection = True
    elif "content-length" not in hkeys:
        # "All 1xx (informational), 204 (no content),
        # and 304 (not modified) responses MUST NOT
        # include a message-body." So no point chunking.
        if status &lt; 200 or status in (204, 205, 304):
            pass
        else:
            if (self.response_protocol == 'HTTP/1.1'
                and self.environ["REQUEST_METHOD"] != 'HEAD'):
                # Use the chunked transfer-coding
                self.chunked_write = True
                self.outheaders.append(("Transfer-Encoding", "chunked"))
            else:
                # Closing the conn is the only way to determine len.
                self.close_connection = True

    if "connection" not in hkeys:
        if self.response_protocol == 'HTTP/1.1':
            # Both server and client are HTTP/1.1 or better
            if self.close_connection:
                self.outheaders.append(("Connection", "close"))
        else:
            # Server and/or client are HTTP/1.0
            if not self.close_connection:
                self.outheaders.append(("Connection", "Keep-Alive"))

    if (not self.close_connection) and (not self.chunked_read):
        # Read any remaining request body data on the socket.
        # "If an origin server receives a request that does not include an
        # Expect request-header field with the "100-continue" expectation,
        # the request includes a request body, and the server responds
        # with a final status code before reading the entire request body
        # from the transport connection, then the server SHOULD NOT close
        # the transport connection until it has read the entire request,
        # or until the client closes the connection. Otherwise, the client
        # might not reliably receive the response message. However, this
        # requirement is not be construed as preventing a server from
        # defending itself against denial-of-service attacks, or from
        # badly broken client implementations."
        size = self.rfile.maxlen - self.rfile.bytes_read
        if size &gt; 0:
            self.rfile.read(size)

    if "date" not in hkeys:
        self.outheaders.append(("Date", rfc822.formatdate()))

    if "server" not in hkeys:
        self.outheaders.append(("Server", self.environ['SERVER_SOFTWARE']))

    buf = [self.environ['ACTUAL_SERVER_PROTOCOL'], " ", self.status, "\r\n"]
    try:
        buf += [k + ": " + v + "\r\n" for k, v in self.outheaders]
    except TypeError:
        if not isinstance(k, str):
            raise TypeError("WSGI response header key %r is not a string.")
        if not isinstance(v, str):
            raise TypeError("WSGI response header value %r is not a string.")
        else:
            raise
    buf.append("\r\n")
    self.wfile.sendall("".join(buf))


</t>
<t tx="zhanglei.20100830144432.1843">class NoSSLError(Exception):
    """Exception raised when a client speaks HTTP to an HTTPS socket."""
    pass


</t>
<t tx="zhanglei.20100830144432.1844">class FatalSSLAlert(Exception):
    """Exception raised when the SSL implementation signals a fatal alert."""
    pass


</t>
<t tx="zhanglei.20100830144432.1845">if not _fileobject_uses_str_type:
    class CP_fileobject(socket._fileobject):
        """Faux file object attached to a socket object."""

        def sendall(self, data):
            """Sendall for non-blocking sockets."""
            while data:
                try:
                    bytes_sent = self.send(data)
                    data = data[bytes_sent:]
                except socket.error, e:
                    if e.args[0] not in socket_errors_nonblocking:
                        raise

        def send(self, data):
            return self._sock.send(data)

        def flush(self):
            if self._wbuf:
                buffer = "".join(self._wbuf)
                self._wbuf = []
                self.sendall(buffer)

        def recv(self, size):
            while True:
                try:
                    return self._sock.recv(size)
                except socket.error, e:
                    if (e.args[0] not in socket_errors_nonblocking
                        and e.args[0] not in socket_error_eintr):
                        raise

        def read(self, size=-1):
            # Use max, disallow tiny reads in a loop as they are very inefficient.
            # We never leave read() with any leftover data from a new recv() call
            # in our internal buffer.
            rbufsize = max(self._rbufsize, self.default_bufsize)
            # Our use of StringIO rather than lists of string objects returned by
            # recv() minimizes memory usage and fragmentation that occurs when
            # rbufsize is large compared to the typical return value of recv().
            buf = self._rbuf
            buf.seek(0, 2)  # seek end
            if size &lt; 0:
                # Read until EOF
                self._rbuf = StringIO.StringIO()  # reset _rbuf.  we consume it via buf.
                while True:
                    data = self.recv(rbufsize)
                    if not data:
                        break
                    buf.write(data)
                return buf.getvalue()
            else:
                # Read until size bytes or EOF seen, whichever comes first
                buf_len = buf.tell()
                if buf_len &gt;= size:
                    # Already have size bytes in our buffer?  Extract and return.
                    buf.seek(0)
                    rv = buf.read(size)
                    self._rbuf = StringIO.StringIO()
                    self._rbuf.write(buf.read())
                    return rv

                self._rbuf = StringIO.StringIO()  # reset _rbuf.  we consume it via buf.
                while True:
                    left = size - buf_len
                    # recv() will malloc the amount of memory given as its
                    # parameter even though it often returns much less data
                    # than that.  The returned data string is short lived
                    # as we copy it into a StringIO and free it.  This avoids
                    # fragmentation issues on many platforms.
                    data = self.recv(left)
                    if not data:
                        break
                    n = len(data)
                    if n == size and not buf_len:
                        # Shortcut.  Avoid buffer data copies when:
                        # - We have no data in our buffer.
                        # AND
                        # - Our call to recv returned exactly the
                        #   number of bytes we were asked to read.
                        return data
                    if n == left:
                        buf.write(data)
                        del data  # explicit free
                        break
                    assert n &lt;= left, "recv(%d) returned %d bytes" % (left, n)
                    buf.write(data)
                    buf_len += n
                    del data  # explicit free
                    #assert buf_len == buf.tell()
                return buf.getvalue()

        def readline(self, size=-1):
            buf = self._rbuf
            buf.seek(0, 2)  # seek end
            if buf.tell() &gt; 0:
                # check if we already have it in our buffer
                buf.seek(0)
                bline = buf.readline(size)
                if bline.endswith('\n') or len(bline) == size:
                    self._rbuf = StringIO.StringIO()
                    self._rbuf.write(buf.read())
                    return bline
                del bline
            if size &lt; 0:
                # Read until \n or EOF, whichever comes first
                if self._rbufsize &lt;= 1:
                    # Speed up unbuffered case
                    buf.seek(0)
                    buffers = [buf.read()]
                    self._rbuf = StringIO.StringIO()  # reset _rbuf.  we consume it via buf.
                    data = None
                    recv = self.recv
                    while data != "\n":
                        data = recv(1)
                        if not data:
                            break
                        buffers.append(data)
                    return "".join(buffers)

                buf.seek(0, 2)  # seek end
                self._rbuf = StringIO.StringIO()  # reset _rbuf.  we consume it via buf.
                while True:
                    data = self.recv(self._rbufsize)
                    if not data:
                        break
                    nl = data.find('\n')
                    if nl &gt;= 0:
                        nl += 1
                        buf.write(data[:nl])
                        self._rbuf.write(data[nl:])
                        del data
                        break
                    buf.write(data)
                return buf.getvalue()
            else:
                # Read until size bytes or \n or EOF seen, whichever comes first
                buf.seek(0, 2)  # seek end
                buf_len = buf.tell()
                if buf_len &gt;= size:
                    buf.seek(0)
                    rv = buf.read(size)
                    self._rbuf = StringIO.StringIO()
                    self._rbuf.write(buf.read())
                    return rv
                self._rbuf = StringIO.StringIO()  # reset _rbuf.  we consume it via buf.
                while True:
                    data = self.recv(self._rbufsize)
                    if not data:
                        break
                    left = size - buf_len
                    # did we just receive a newline?
                    nl = data.find('\n', 0, left)
                    if nl &gt;= 0:
                        nl += 1
                        # save the excess data to _rbuf
                        self._rbuf.write(data[nl:])
                        if buf_len:
                            buf.write(data[:nl])
                            break
                        else:
                            # Shortcut.  Avoid data copy through buf when returning
                            # a substring of our first recv().
                            return data[:nl]
                    n = len(data)
                    if n == size and not buf_len:
                        # Shortcut.  Avoid data copy through buf when
                        # returning exactly all of our first recv().
                        return data
                    if n &gt;= left:
                        buf.write(data[:left])
                        self._rbuf.write(data[left:])
                        break
                    buf.write(data)
                    buf_len += n
                    #assert buf_len == buf.tell()
                return buf.getvalue()

else:
    class CP_fileobject(socket._fileobject):
        """Faux file object attached to a socket object."""

        def sendall(self, data):
            """Sendall for non-blocking sockets."""
            while data:
                try:
                    bytes_sent = self.send(data)
                    data = data[bytes_sent:]
                except socket.error, e:
                    if e.args[0] not in socket_errors_nonblocking:
                        raise

        def send(self, data):
            return self._sock.send(data)

        def flush(self):
            if self._wbuf:
                buffer = "".join(self._wbuf)
                self._wbuf = []
                self.sendall(buffer)

        def recv(self, size):
            while True:
                try:
                    return self._sock.recv(size)
                except socket.error, e:
                    if (e.args[0] not in socket_errors_nonblocking
                        and e.args[0] not in socket_error_eintr):
                        raise

        def read(self, size=-1):
            if size &lt; 0:
                # Read until EOF
                buffers = [self._rbuf]
                self._rbuf = ""
                if self._rbufsize &lt;= 1:
                    recv_size = self.default_bufsize
                else:
                    recv_size = self._rbufsize

                while True:
                    data = self.recv(recv_size)
                    if not data:
                        break
                    buffers.append(data)
                return "".join(buffers)
            else:
                # Read until size bytes or EOF seen, whichever comes first
                data = self._rbuf
                buf_len = len(data)
                if buf_len &gt;= size:
                    self._rbuf = data[size:]
                    return data[:size]
                buffers = []
                if data:
                    buffers.append(data)
                self._rbuf = ""
                while True:
                    left = size - buf_len
                    recv_size = max(self._rbufsize, left)
                    data = self.recv(recv_size)
                    if not data:
                        break
                    buffers.append(data)
                    n = len(data)
                    if n &gt;= left:
                        self._rbuf = data[left:]
                        buffers[-1] = data[:left]
                        break
                    buf_len += n
                return "".join(buffers)

        def readline(self, size=-1):
            data = self._rbuf
            if size &lt; 0:
                # Read until \n or EOF, whichever comes first
                if self._rbufsize &lt;= 1:
                    # Speed up unbuffered case
                    assert data == ""
                    buffers = []
                    while data != "\n":
                        data = self.recv(1)
                        if not data:
                            break
                        buffers.append(data)
                    return "".join(buffers)
                nl = data.find('\n')
                if nl &gt;= 0:
                    nl += 1
                    self._rbuf = data[nl:]
                    return data[:nl]
                buffers = []
                if data:
                    buffers.append(data)
                self._rbuf = ""
                while True:
                    data = self.recv(self._rbufsize)
                    if not data:
                        break
                    buffers.append(data)
                    nl = data.find('\n')
                    if nl &gt;= 0:
                        nl += 1
                        self._rbuf = data[nl:]
                        buffers[-1] = data[:nl]
                        break
                return "".join(buffers)
            else:
                # Read until size bytes or \n or EOF seen, whichever comes first
                nl = data.find('\n', 0, size)
                if nl &gt;= 0:
                    nl += 1
                    self._rbuf = data[nl:]
                    return data[:nl]
                buf_len = len(data)
                if buf_len &gt;= size:
                    self._rbuf = data[size:]
                    return data[:size]
                buffers = []
                if data:
                    buffers.append(data)
                self._rbuf = ""
                while True:
                    data = self.recv(self._rbufsize)
                    if not data:
                        break
                    buffers.append(data)
                    left = size - buf_len
                    nl = data.find('\n', 0, left)
                    if nl &gt;= 0:
                        nl += 1
                        self._rbuf = data[nl:]
                        buffers[-1] = data[:nl]
                        break
                    n = len(data)
                    if n &gt;= left:
                        self._rbuf = data[left:]
                        buffers[-1] = data[:left]
                        break
                    buf_len += n
                return "".join(buffers)


class SSL_fileobject(CP_fileobject):
    """SSL file object attached to a socket object."""

    ssl_timeout = 3
    ssl_retry = .01

    @others
</t>
<t tx="zhanglei.20100830144432.1846">def _safe_call(self, is_reader, call, *args, **kwargs):
    """Wrap the given call with SSL error-trapping.

    is_reader: if False EOF errors will be raised. If True, EOF errors
        will return "" (to emulate normal sockets).
    """
    start = time.time()
    while True:
        try:
            return call(*args, **kwargs)
        except SSL.WantReadError:
            # Sleep and try again. This is dangerous, because it means
            # the rest of the stack has no way of differentiating
            # between a "new handshake" error and "client dropped".
            # Note this isn't an endless loop: there's a timeout below.
            time.sleep(self.ssl_retry)
        except SSL.WantWriteError:
            time.sleep(self.ssl_retry)
        except SSL.SysCallError, e:
            if is_reader and e.args == (-1, 'Unexpected EOF'):
                return ""

            errnum = e.args[0]
            if is_reader and errnum in socket_errors_to_ignore:
                return ""
            raise socket.error(errnum)
        except SSL.Error, e:
            if is_reader and e.args == (-1, 'Unexpected EOF'):
                return ""

            thirdarg = None
            try:
                thirdarg = e.args[0][0][2]
            except IndexError:
                pass

            if thirdarg == 'http request':
                # The client is talking HTTP to an HTTPS server.
                raise NoSSLError()
            raise FatalSSLAlert(*e.args)
        except:
            raise

        if time.time() - start &gt; self.ssl_timeout:
            raise socket.timeout("timed out")

</t>
<t tx="zhanglei.20100830144432.1847">def recv(self, *args, **kwargs):
    buf = []
    r = super(SSL_fileobject, self).recv
    while True:
        data = self._safe_call(True, r, *args, **kwargs)
        buf.append(data)
        p = self._sock.pending()
        if not p:
            return "".join(buf)

</t>
<t tx="zhanglei.20100830144432.1848">def sendall(self, *args, **kwargs):
    return self._safe_call(False, super(SSL_fileobject, self).sendall, *args, **kwargs)

</t>
<t tx="zhanglei.20100830144432.1849">def send(self, *args, **kwargs):
    return self._safe_call(False, super(SSL_fileobject, self).send, *args, **kwargs)


</t>
<t tx="zhanglei.20100830144432.1850">class HTTPConnection(object):
    """An HTTP connection (active socket).

    socket: the raw socket object (usually TCP) for this connection.
    wsgi_app: the WSGI application for this server/connection.
    environ: a WSGI environ template. This will be copied for each request.

    rfile: a fileobject for reading from the socket.
    send: a function for writing (+ flush) to the socket.
    """

    rbufsize = -1
    RequestHandlerClass = HTTPRequest
    environ = {"wsgi.version": (1, 0),
               "wsgi.url_scheme": "http",
               "wsgi.multithread": True,
               "wsgi.multiprocess": False,
               "wsgi.run_once": False,
               "wsgi.errors": sys.stderr,
               }

    @others
</t>
<t tx="zhanglei.20100830144432.1851">def __init__(self, sock, wsgi_app, environ):
    self.socket = sock
    self.wsgi_app = wsgi_app

    # Copy the class environ into self.
    self.environ = self.environ.copy()
    self.environ.update(environ)

    if SSL and isinstance(sock, SSL.ConnectionType):
        timeout = sock.gettimeout()
        self.rfile = SSL_fileobject(sock, "rb", self.rbufsize)
        self.rfile.ssl_timeout = timeout
        self.wfile = SSL_fileobject(sock, "wb", -1)
        self.wfile.ssl_timeout = timeout
    else:
        self.rfile = CP_fileobject(sock, "rb", self.rbufsize)
        self.wfile = CP_fileobject(sock, "wb", -1)

    # Wrap wsgi.input but not HTTPConnection.rfile itself.
    # We're also not setting maxlen yet; we'll do that separately
    # for headers and body for each iteration of self.communicate
    # (if maxlen is 0 the wrapper doesn't check length).
    self.environ["wsgi.input"] = SizeCheckWrapper(self.rfile, 0)

</t>
<t tx="zhanglei.20100830144432.1852">def communicate(self):
    """Read each request and respond appropriately."""
    try:
        while True:
            # (re)set req to None so that if something goes wrong in
            # the RequestHandlerClass constructor, the error doesn't
            # get written to the previous request.
            req = None
            req = self.RequestHandlerClass(self.wfile, self.environ,
                                           self.wsgi_app)

            # This order of operations should guarantee correct pipelining.
            req.parse_request()
            if not req.ready:
                return

            req.respond()
            if req.close_connection:
                return

    except socket.error, e:
        errnum = e.args[0]
        if errnum == 'timed out':
            if req and not req.sent_headers:
                req.simple_response("408 Request Timeout")
        elif errnum not in socket_errors_to_ignore:
            if req and not req.sent_headers:
                req.simple_response("500 Internal Server Error",
                                    format_exc())
        return
    except (KeyboardInterrupt, SystemExit):
        raise
    except FatalSSLAlert, e:
        # Close the connection.
        return
    except NoSSLError:
        if req and not req.sent_headers:
            # Unwrap our wfile
            req.wfile = CP_fileobject(self.socket._sock, "wb", -1)
            req.simple_response("400 Bad Request",
                "The client sent a plain HTTP request, but "
                "this server only speaks HTTPS on this port.")
            self.linger = True
    except Exception, e:
        if req and not req.sent_headers:
            req.simple_response("500 Internal Server Error", format_exc())

</t>
<t tx="zhanglei.20100830144432.1853">linger = False

def close(self):
    """Close the socket underlying this connection."""
    self.rfile.close()

    if not self.linger:
        # Python's socket module does NOT call close on the kernel socket
        # when you call socket.close(). We do so manually here because we
        # want this server to send a FIN TCP segment immediately. Note this
        # must be called *before* calling socket.close(), because the latter
        # drops its reference to the kernel socket.
        self.socket._sock.close()
        self.socket.close()
    else:
        # On the other hand, sometimes we want to hang around for a bit
        # to make sure the client has a chance to read our entire
        # response. Skipping the close() calls here delays the FIN
        # packet until the socket object is garbage-collected later.
        # Someday, perhaps, we'll do the full lingering_close that
        # Apache does, but not today.
        pass


</t>
<t tx="zhanglei.20100830144432.1854">def format_exc(limit=None):
    """Like print_exc() but return a string. Backport for Python 2.3."""
    try:
        etype, value, tb = sys.exc_info()
        return ''.join(traceback.format_exception(etype, value, tb, limit))
    finally:
        etype = value = tb = None


</t>
<t tx="zhanglei.20100830144432.1855">_SHUTDOWNREQUEST = None

class WorkerThread(threading.Thread):
    """Thread which continuously polls a Queue for Connection objects.

    server: the HTTP Server which spawned this thread, and which owns the
        Queue and is placing active connections into it.
    ready: a simple flag for the calling server to know when this thread
        has begun polling the Queue.

    Due to the timing issues of polling a Queue, a WorkerThread does not
    check its own 'ready' flag after it has started. To stop the thread,
    it is necessary to stick a _SHUTDOWNREQUEST object onto the Queue
    (one for each running WorkerThread).
    """

    conn = None

    @others
</t>
<t tx="zhanglei.20100830144432.1856">def __init__(self, server):
    self.ready = False
    self.server = server
    threading.Thread.__init__(self)

</t>
<t tx="zhanglei.20100830144432.1857">def run(self):
    try:
        self.ready = True
        while True:
            conn = self.server.requests.get()
            if conn is _SHUTDOWNREQUEST:
                return

            self.conn = conn
            try:
                conn.communicate()
            finally:
                conn.close()
                self.conn = None
    except (KeyboardInterrupt, SystemExit), exc:
        self.server.interrupt = exc


</t>
<t tx="zhanglei.20100830144432.1858">class ThreadPool(object):
    """A Request Queue for the CherryPyWSGIServer which pools threads.

    ThreadPool objects must provide min, get(), put(obj), start()
    and stop(timeout) attributes.
    """
    @others
</t>
<t tx="zhanglei.20100830144432.1859">
def __init__(self, server, min=10, max=-1):
    self.server = server
    self.min = min
    self.max = max
    self._threads = []
    self._queue = Queue.Queue()
    self.get = self._queue.get

</t>
<t tx="zhanglei.20100830144432.1860">def start(self):
    """Start the pool of threads."""
    for i in xrange(self.min):
        self._threads.append(WorkerThread(self.server))
    for worker in self._threads:
        worker.setName("CP WSGIServer " + worker.getName())
        worker.start()
    for worker in self._threads:
        while not worker.ready:
            time.sleep(.1)

</t>
<t tx="zhanglei.20100830144432.1861">def _get_idle(self):
    """Number of worker threads which are idle. Read-only."""
    return len([t for t in self._threads if t.conn is None])
</t>
<t tx="zhanglei.20100830144432.1862">idle = property(_get_idle, doc=_get_idle.__doc__)

def put(self, obj):
    self._queue.put(obj)
    if obj is _SHUTDOWNREQUEST:
        return

</t>
<t tx="zhanglei.20100830144432.1863">def grow(self, amount):
    """Spawn new worker threads (not above self.max)."""
    for i in xrange(amount):
        if self.max &gt; 0 and len(self._threads) &gt;= self.max:
            break
        worker = WorkerThread(self.server)
        worker.setName("CP WSGIServer " + worker.getName())
        self._threads.append(worker)
        worker.start()

</t>
<t tx="zhanglei.20100830144432.1864">def shrink(self, amount):
    """Kill off worker threads (not below self.min)."""
    # Grow/shrink the pool if necessary.
    # Remove any dead threads from our list
    for t in self._threads:
        if not t.isAlive():
            self._threads.remove(t)
            amount -= 1

    if amount &gt; 0:
        for i in xrange(min(amount, len(self._threads) - self.min)):
            # Put a number of shutdown requests on the queue equal
            # to 'amount'. Once each of those is processed by a worker,
            # that worker will terminate and be culled from our list
            # in self.put.
            self._queue.put(_SHUTDOWNREQUEST)

</t>
<t tx="zhanglei.20100830144432.1865">def stop(self, timeout=5):
    # Must shut down threads here so the code that calls
    # this method can know when all threads are stopped.
    for worker in self._threads:
        self._queue.put(_SHUTDOWNREQUEST)

    # Don't join currentThread (when stop is called inside a request).
    current = threading.currentThread()
    while self._threads:
        worker = self._threads.pop()
        if worker is not current and worker.isAlive():
            try:
                if timeout is None or timeout &lt; 0:
                    worker.join()
                else:
                    worker.join(timeout)
                    if worker.isAlive():
                        # We exhausted the timeout.
                        # Forcibly shut down the socket.
                        c = worker.conn
                        if c and not c.rfile.closed:
                            if SSL and isinstance(c.socket, SSL.ConnectionType):
                                # pyOpenSSL.socket.shutdown takes no args
                                c.socket.shutdown()
                            else:
                                c.socket.shutdown(socket.SHUT_RD)
                        worker.join()
            except (AssertionError,
                    # Ignore repeated Ctrl-C.
                    # See http://www.cherrypy.org/ticket/691.
                    KeyboardInterrupt), exc1:
                pass



</t>
<t tx="zhanglei.20100830144432.1866">class SSLConnection:
    """A thread-safe wrapper for an SSL.Connection.

    *args: the arguments to create the wrapped SSL.Connection(*args).
    """
    @others
    for f in ('get_context', 'pending', 'send', 'write', 'recv', 'read',
              'renegotiate', 'bind', 'listen', 'connect', 'accept',
              'setblocking', 'fileno', 'shutdown', 'close', 'get_cipher_list',
              'getpeername', 'getsockname', 'getsockopt', 'setsockopt',
              'makefile', 'get_app_data', 'set_app_data', 'state_string',
              'sock_shutdown', 'get_peer_certificate', 'want_read',
              'want_write', 'set_connect_state', 'set_accept_state',
              'connect_ex', 'sendall', 'settimeout'):
        exec """def %s(self, *args):
        self._lock.acquire()
        try:
            return self._ssl_conn.%s(*args)
        finally:
            self._lock.release()
""" % (f, f)


</t>
<t tx="zhanglei.20100830144432.1867">
def __init__(self, *args):
    self._ssl_conn = SSL.Connection(*args)
    self._lock = threading.RLock()

</t>
<t tx="zhanglei.20100830144432.1868">try:
    import fcntl
except ImportError:
    try:
        from ctypes import windll, WinError
    except ImportError:
        def prevent_socket_inheritance(sock):
            """Dummy function, since neither fcntl nor ctypes are available."""
            pass
    else:
        def prevent_socket_inheritance(sock):
            """Mark the given socket fd as non-inheritable (Windows)."""
            if not windll.kernel32.SetHandleInformation(sock.fileno(), 1, 0):
                raise WinError()
else:
    def prevent_socket_inheritance(sock):
        """Mark the given socket fd as non-inheritable (POSIX)."""
        fd = sock.fileno()
        old_flags = fcntl.fcntl(fd, fcntl.F_GETFD)
        fcntl.fcntl(fd, fcntl.F_SETFD, old_flags | fcntl.FD_CLOEXEC)


class CherryPyWSGIServer(object):
    """An HTTP server for WSGI.

    bind_addr: The interface on which to listen for connections.
        For TCP sockets, a (host, port) tuple. Host values may be any IPv4
        or IPv6 address, or any valid hostname. The string 'localhost' is a
        synonym for '127.0.0.1' (or '::1', if your hosts file prefers IPv6).
        The string '0.0.0.0' is a special IPv4 entry meaning "any active
        interface" (INADDR_ANY), and '::' is the similar IN6ADDR_ANY for
        IPv6. The empty string or None are not allowed.

        For UNIX sockets, supply the filename as a string.
    wsgi_app: the WSGI 'application callable'; multiple WSGI applications
        may be passed as (path_prefix, app) pairs.
    numthreads: the number of worker threads to create (default 10).
    server_name: the string to set for WSGI's SERVER_NAME environ entry.
        Defaults to socket.gethostname().
    max: the maximum number of queued requests (defaults to -1 = no limit).
    request_queue_size: the 'backlog' argument to socket.listen();
        specifies the maximum number of queued connections (default 5).
    timeout: the timeout in seconds for accepted connections (default 10).

    nodelay: if True (the default since 3.1), sets the TCP_NODELAY socket
        option.

    protocol: the version string to write in the Status-Line of all
        HTTP responses. For example, "HTTP/1.1" (the default). This
        also limits the supported features used in the response.


    SSL/HTTPS
    ---------
    The OpenSSL module must be importable for SSL functionality.
    You can obtain it from http://pyopenssl.sourceforge.net/

    ssl_certificate: the filename of the server SSL certificate.
    ssl_privatekey: the filename of the server's private key file.

    If either of these is None (both are None by default), this server
    will not use SSL. If both are given and are valid, they will be read
    on server start and used in the SSL context for the listening socket.
    """

    protocol = "HTTP/1.1"
    _bind_addr = "127.0.0.1"
    version = "CherryPy/3.1.2"
    ready = False
    _interrupt = None

    nodelay = True

    ConnectionClass = HTTPConnection
    environ = {}

    # Paths to certificate and private key files
    ssl_certificate = None
    ssl_private_key = None

    @others
</t>
<t tx="zhanglei.20100830144432.1869">def __init__(self, bind_addr, wsgi_app, numthreads=10, server_name=None,
             max=-1, request_queue_size=5, timeout=10, shutdown_timeout=5):
    self.requests = ThreadPool(self, min=numthreads or 1, max=max)

    if callable(wsgi_app):
        # We've been handed a single wsgi_app, in CP-2.1 style.
        # Assume it's mounted at "".
        self.wsgi_app = wsgi_app
    else:
        # We've been handed a list of (path_prefix, wsgi_app) tuples,
        # so that the server can call different wsgi_apps, and also
        # correctly set SCRIPT_NAME.
        warnings.warn("The ability to pass multiple apps is deprecated "
                      "and will be removed in 3.2. You should explicitly "
                      "include a WSGIPathInfoDispatcher instead.",
                      DeprecationWarning)
        self.wsgi_app = WSGIPathInfoDispatcher(wsgi_app)

    self.bind_addr = bind_addr
    if not server_name:
        server_name = socket.gethostname()
    self.server_name = server_name
    self.request_queue_size = request_queue_size

    self.timeout = timeout
    self.shutdown_timeout = shutdown_timeout

</t>
<t tx="zhanglei.20100830144432.1870">def _get_numthreads(self):
    return self.requests.min
</t>
<t tx="zhanglei.20100830144432.1871">def _set_numthreads(self, value):
    self.requests.min = value
</t>
<t tx="zhanglei.20100830144432.1872">numthreads = property(_get_numthreads, _set_numthreads)

def __str__(self):
    return "%s.%s(%r)" % (self.__module__, self.__class__.__name__,
                          self.bind_addr)

</t>
<t tx="zhanglei.20100830144432.1873">def _get_bind_addr(self):
    return self._bind_addr
</t>
<t tx="zhanglei.20100830144432.1874">def _set_bind_addr(self, value):
    if isinstance(value, tuple) and value[0] in ('', None):
        # Despite the socket module docs, using '' does not
        # allow AI_PASSIVE to work. Passing None instead
        # returns '0.0.0.0' like we want. In other words:
        #     host    AI_PASSIVE     result
        #      ''         Y         192.168.x.y
        #      ''         N         192.168.x.y
        #     None        Y         0.0.0.0
        #     None        N         127.0.0.1
        # But since you can get the same effect with an explicit
        # '0.0.0.0', we deny both the empty string and None as values.
        raise ValueError("Host values of '' or None are not allowed. "
                         "Use '0.0.0.0' (IPv4) or '::' (IPv6) instead "
                         "to listen on all active interfaces.")
    self._bind_addr = value
</t>
<t tx="zhanglei.20100830144432.1875">bind_addr = property(_get_bind_addr, _set_bind_addr,
    doc="""The interface on which to listen for connections.

    For TCP sockets, a (host, port) tuple. Host values may be any IPv4
    or IPv6 address, or any valid hostname. The string 'localhost' is a
    synonym for '127.0.0.1' (or '::1', if your hosts file prefers IPv6).
    The string '0.0.0.0' is a special IPv4 entry meaning "any active
    interface" (INADDR_ANY), and '::' is the similar IN6ADDR_ANY for
    IPv6. The empty string or None are not allowed.

    For UNIX sockets, supply the filename as a string.""")

def start(self):
    """Run the server forever."""
    # We don't have to trap KeyboardInterrupt or SystemExit here,
    # because cherrpy.server already does so, calling self.stop() for us.
    # If you're using this server with another framework, you should
    # trap those exceptions in whatever code block calls start().
    self._interrupt = None

    # Select the appropriate socket
    if isinstance(self.bind_addr, basestring):
        # AF_UNIX socket

        # So we can reuse the socket...
        try: os.unlink(self.bind_addr)
        except: pass

        # So everyone can access the socket...
        try: os.chmod(self.bind_addr, 0777)
        except: pass

        info = [(socket.AF_UNIX, socket.SOCK_STREAM, 0, "", self.bind_addr)]
    else:
        # AF_INET or AF_INET6 socket
        # Get the correct address family for our host (allows IPv6 addresses)
        host, port = self.bind_addr
        try:
            info = socket.getaddrinfo(host, port, socket.AF_UNSPEC,
                                      socket.SOCK_STREAM, 0, socket.AI_PASSIVE)
        except socket.gaierror:
            # Probably a DNS issue. Assume IPv4.
            info = [(socket.AF_INET, socket.SOCK_STREAM, 0, "", self.bind_addr)]

    self.socket = None
    msg = "No socket could be created"
    for res in info:
        af, socktype, proto, canonname, sa = res
        try:
            self.bind(af, socktype, proto)
        except socket.error, msg:
            if self.socket:
                self.socket.close()
            self.socket = None
            continue
        break
    if not self.socket:
        raise socket.error, msg

    # Timeout so KeyboardInterrupt can be caught on Win32
    self.socket.settimeout(1)
    self.socket.listen(self.request_queue_size)

    # Create worker threads
    self.requests.start()

    self.ready = True
    while self.ready:
        self.tick()
        if self.interrupt:
            while self.interrupt is True:
                # Wait for self.stop() to complete. See _set_interrupt.
                time.sleep(0.1)
            if self.interrupt:
                raise self.interrupt

</t>
<t tx="zhanglei.20100830144432.1876">def bind(self, family, type, proto=0):
    """Create (or recreate) the actual socket object."""
    self.socket = socket.socket(family, type, proto)
    prevent_socket_inheritance(self.socket)
    self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    if self.nodelay:
        self.socket.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    if self.ssl_certificate and self.ssl_private_key:
        if SSL is None:
            raise ImportError("You must install pyOpenSSL to use HTTPS.")

        # See http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/442473
        ctx = SSL.Context(SSL.SSLv23_METHOD)
        ctx.use_privatekey_file(self.ssl_private_key)
        ctx.use_certificate_file(self.ssl_certificate)
        self.socket = SSLConnection(ctx, self.socket)
        self.populate_ssl_environ()

        # If listening on the IPV6 any address ('::' = IN6ADDR_ANY),
        # activate dual-stack. See http://www.cherrypy.org/ticket/871.
        if (not isinstance(self.bind_addr, basestring)
            and self.bind_addr[0] == '::' and family == socket.AF_INET6):
            try:
                self.socket.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_V6ONLY, 0)
            except (AttributeError, socket.error):
                # Apparently, the socket option is not available in
                # this machine's TCP stack
                pass

    self.socket.bind(self.bind_addr)

</t>
<t tx="zhanglei.20100830144432.1877">def tick(self):
    """Accept a new connection and put it on the Queue."""
    try:
        s, addr = self.socket.accept()
        prevent_socket_inheritance(s)
        if not self.ready:
            return
        if hasattr(s, 'settimeout'):
            s.settimeout(self.timeout)

        environ = self.environ.copy()
        # SERVER_SOFTWARE is common for IIS. It's also helpful for
        # us to pass a default value for the "Server" response header.
        if environ.get("SERVER_SOFTWARE") is None:
            environ["SERVER_SOFTWARE"] = "%s WSGI Server" % self.version
        # set a non-standard environ entry so the WSGI app can know what
        # the *real* server protocol is (and what features to support).
        # See http://www.faqs.org/rfcs/rfc2145.html.
        environ["ACTUAL_SERVER_PROTOCOL"] = self.protocol
        environ["SERVER_NAME"] = self.server_name

        if isinstance(self.bind_addr, basestring):
            # AF_UNIX. This isn't really allowed by WSGI, which doesn't
            # address unix domain sockets. But it's better than nothing.
            environ["SERVER_PORT"] = ""
        else:
            environ["SERVER_PORT"] = str(self.bind_addr[1])
            # optional values
            # Until we do DNS lookups, omit REMOTE_HOST
            environ["REMOTE_ADDR"] = addr[0]
            environ["REMOTE_PORT"] = str(addr[1])

        conn = self.ConnectionClass(s, self.wsgi_app, environ)
        self.requests.put(conn)
    except socket.timeout:
        # The only reason for the timeout in start() is so we can
        # notice keyboard interrupts on Win32, which don't interrupt
        # accept() by default
        return
    except socket.error, x:
        if x.args[0] in socket_error_eintr:
            # I *think* this is right. EINTR should occur when a signal
            # is received during the accept() call; all docs say retry
            # the call, and I *think* I'm reading it right that Python
            # will then go ahead and poll for and handle the signal
            # elsewhere. See http://www.cherrypy.org/ticket/707.
            return
        if x.args[0] in socket_errors_nonblocking:
            # Just try again. See http://www.cherrypy.org/ticket/479.
            return
        if x.args[0] in socket_errors_to_ignore:
            # Our socket was closed.
            # See http://www.cherrypy.org/ticket/686.
            return
        raise

</t>
<t tx="zhanglei.20100830144432.1878">def _get_interrupt(self):
    return self._interrupt
</t>
<t tx="zhanglei.20100830144432.1879">def _set_interrupt(self, interrupt):
    self._interrupt = True
    self.stop()
    self._interrupt = interrupt
</t>
<t tx="zhanglei.20100830144432.1880">interrupt = property(_get_interrupt, _set_interrupt,
                     doc="Set this to an Exception instance to "
                         "interrupt the server.")

def stop(self):
    """Gracefully shutdown a server that is serving forever."""
    self.ready = False

    sock = getattr(self, "socket", None)
    if sock:
        if not isinstance(self.bind_addr, basestring):
            # Touch our own socket to make accept() return immediately.
            try:
                host, port = sock.getsockname()[:2]
            except socket.error, x:
                if x.args[0] not in socket_errors_to_ignore:
                    raise
            else:
                # Note that we're explicitly NOT using AI_PASSIVE,
                # here, because we want an actual IP to touch.
                # localhost won't work if we've bound to a public IP,
                # but it will if we bound to '0.0.0.0' (INADDR_ANY).
                for res in socket.getaddrinfo(host, port, socket.AF_UNSPEC,
                                              socket.SOCK_STREAM):
                    af, socktype, proto, canonname, sa = res
                    s = None
                    try:
                        s = socket.socket(af, socktype, proto)
                        # See http://groups.google.com/group/cherrypy-users/
                        #        browse_frm/thread/bbfe5eb39c904fe0
                        s.settimeout(1.0)
                        s.connect((host, port))
                        s.close()
                    except socket.error:
                        if s:
                            s.close()
        if hasattr(sock, "close"):
            sock.close()
        self.socket = None

    self.requests.stop(self.shutdown_timeout)

</t>
<t tx="zhanglei.20100830144432.1881">def populate_ssl_environ(self):
    """Create WSGI environ entries to be merged into each request."""
    cert = open(self.ssl_certificate, 'rb').read()
    cert = crypto.load_certificate(crypto.FILETYPE_PEM, cert)
    ssl_environ = {
        "wsgi.url_scheme": "https",
        "HTTPS": "on",
        # pyOpenSSL doesn't provide access to any of these AFAICT
##            'SSL_PROTOCOL': 'SSLv2',
##            SSL_CIPHER 	string 	The cipher specification name
##            SSL_VERSION_INTERFACE 	string 	The mod_ssl program version
##            SSL_VERSION_LIBRARY 	string 	The OpenSSL program version
        }

    # Server certificate attributes
    ssl_environ.update({
        'SSL_SERVER_M_VERSION': cert.get_version(),
        'SSL_SERVER_M_SERIAL': cert.get_serial_number(),
##            'SSL_SERVER_V_START': Validity of server's certificate (start time),
##            'SSL_SERVER_V_END': Validity of server's certificate (end time),
        })

    for prefix, dn in [("I", cert.get_issuer()),
                       ("S", cert.get_subject())]:
        # X509Name objects don't seem to have a way to get the
        # complete DN string. Use str() and slice it instead,
        # because str(dn) == "&lt;X509Name object '/C=US/ST=...'&gt;"
        dnstr = str(dn)[18:-2]

        wsgikey = 'SSL_SERVER_%s_DN' % prefix
        ssl_environ[wsgikey] = dnstr

        # The DN should be of the form: /k1=v1/k2=v2, but we must allow
        # for any value to contain slashes itself (in a URL).
        while dnstr:
            pos = dnstr.rfind("=")
            dnstr, value = dnstr[:pos], dnstr[pos + 1:]
            pos = dnstr.rfind("/")
            dnstr, key = dnstr[:pos], dnstr[pos + 1:]
            if key and value:
                wsgikey = 'SSL_SERVER_%s_DN_%s' % (prefix, key)
                ssl_environ[wsgikey] = value

    self.environ.update(ssl_environ)

</t>
<t tx="zhanglei.20100830144432.1882"></t>
<t tx="zhanglei.20100830144432.1883">@language python
@tabwidth -4
@others
@ignore
</t>
<t tx="zhanglei.20100830144432.1884">"""
Interface to various templating engines.
"""
import os.path

__all__ = [
    "render_cheetah", "render_genshi", "render_mako",
    "cache", 
]

</t>
<t tx="zhanglei.20100830144432.1885">class render_cheetah:
    """Rendering interface to Cheetah Templates.

    Example:

        render = render_cheetah('templates')
        render.hello(name="cheetah")
    """
    @others
</t>
<t tx="zhanglei.20100830144432.1886">def __init__(self, path):
    # give error if Chetah is not installed
    from Cheetah.Template import Template
    self.path = path

</t>
<t tx="zhanglei.20100830144432.1887">def __getattr__(self, name):
    from Cheetah.Template import Template
    path = os.path.join(self.path, name + ".html")

    def template(**kw):
        t = Template(file=path, searchList=[kw])
        return t.respond()

    return template

</t>
<t tx="zhanglei.20100830144432.1888">class render_genshi:
    """Rendering interface genshi templates.
    Example:

    for xml/html templates.

        render = render_genshi(['templates/'])
        render.hello(name='genshi')

    For text templates:

        render = render_genshi(['templates/'], type='text')
        render.hello(name='genshi')
    """
    @others
</t>
<t tx="zhanglei.20100830144432.1889">
def __init__(self, *a, **kwargs):
    from genshi.template import TemplateLoader

    self._type = kwargs.pop('type', None)
    self._loader = TemplateLoader(*a, **kwargs)

</t>
<t tx="zhanglei.20100830144432.1890">def __getattr__(self, name):
    # Assuming all templates are html
    path = name + ".html"

    if self._type == "text":
        from genshi.template import TextTemplate
        cls = TextTemplate
        type = "text"
    else:
        cls = None
        type = None

    t = self._loader.load(path, cls=cls)
    def template(**kw):
        stream = t.generate(**kw)
        if type:
            return stream.render(type)
        else:
            return stream.render()
    return template

</t>
<t tx="zhanglei.20100830144432.1891">class render_jinja:
    """Rendering interface to Jinja2 Templates

    Example:

        render= render_jinja('templates')
        render.hello(name='jinja2')
    """
    @others
</t>
<t tx="zhanglei.20100830144432.1892">def __init__(self, *a, **kwargs):
    extensions = kwargs.pop('extensions', [])
    globals = kwargs.pop('globals', {})

    from jinja2 import Environment,FileSystemLoader
    self._lookup = Environment(loader=FileSystemLoader(*a, **kwargs), extensions=extensions)
    self._lookup.globals.update(globals)

</t>
<t tx="zhanglei.20100830144432.1893">def __getattr__(self, name):
    # Assuming all templates end with .html
    path = name + '.html'
    t = self._lookup.get_template(path)
    return t.render

</t>
<t tx="zhanglei.20100830144432.1894">class render_mako:
    """Rendering interface to Mako Templates.

    Example:

        render = render_mako(directories=['templates'])
        render.hello(name="mako")
    """
    @others
</t>
<t tx="zhanglei.20100830144432.1895">def __init__(self, *a, **kwargs):
    from mako.lookup import TemplateLookup
    self._lookup = TemplateLookup(*a, **kwargs)

</t>
<t tx="zhanglei.20100830144432.1896">def __getattr__(self, name):
    # Assuming all templates are html
    path = name + ".html"
    t = self._lookup.get_template(path)
    return t.render

</t>
<t tx="zhanglei.20100830144432.1897">class cache:
    """Cache for any rendering interface.

    Example:

        render = cache(render_cheetah("templates/"))
        render.hello(name='cache')
    """
    @others
</t>
<t tx="zhanglei.20100830144432.1898">def __init__(self, render):
    self._render = render
    self._cache = {}

</t>
<t tx="zhanglei.20100830144432.1899">def __getattr__(self, name):
    if name not in self._cache:
        self._cache[name] = getattr(self._render, name)
    return self._cache[name]
</t>
</tnodes>
</leo_file>
