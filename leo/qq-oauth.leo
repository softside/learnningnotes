<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="wjl.20110117235658.1869"><vh>@chapters</vh></v>
<v t="newlife.20110117110751.1267"><vh>qq-oauth验证</vh>
<v t="newlife.20110117110751.1268"><vh>文档</vh></v>
<v t="newlife.20110117110751.1879"><vh>urls</vh></v>
<v t="newlife.20110117110751.1867"><vh>views</vh>
<v t="newlife.20110117110751.1868"><vh>@file /home/newlife/ppy_office/ppy_official/users/helper_sina.py</vh>
<v t="newlife.20110117110751.1869"><vh>helper_sina declarations</vh></v>
<v t="newlife.20110117110751.1870"><vh>update_sina_accesstoken</vh></v>
<v t="newlife.20110117110751.1871"><vh>is_send_feed</vh></v>
<v t="newlife.20110117110751.1872"><vh>send_user_feed</vh></v>
<v t="newlife.20110117110751.1873"><vh>get_request_token</vh></v>
<v t="newlife.20110117110751.1876"><vh>sina_bind_newfeed</vh></v>
<v t="newlife.20110117110751.1877"><vh>sina_upload</vh></v>
</v>
</v>
<v t="newlife.20110117110751.1269"><vh>oauth_library</vh>
<v t="newlife.20110117110751.1569"><vh>@file /home/newlife/ppy_office/ppy_official/thirdparty/weibopy/api.py</vh>
<v t="newlife.20110117110751.1570"><vh>api declarations</vh></v>
<v t="newlife.20110117110751.1571"><vh>class API</vh>
<v t="newlife.20110117110751.1572"><vh>__init__</vh></v>
<v t="newlife.20110117110751.1573"><vh>upload</vh></v>
<v t="newlife.20110117110751.1574"><vh>me</vh></v>
<v t="newlife.20110117110751.1575"><vh>verify_credentials</vh></v>
<v t="newlife.20110117110751.1576"><vh>update_profile_image</vh></v>
<v t="newlife.20110117110751.1577"><vh>update_profile_background_image</vh></v>
<v t="newlife.20110117110751.1578"><vh>exists_block</vh></v>
<v t="newlife.20110117110751.1579"><vh>test</vh></v>
<v t="newlife.20110117110751.1580"><vh>create_list</vh></v>
<v t="newlife.20110117110751.1581"><vh>destroy_list</vh></v>
<v t="newlife.20110117110751.1582"><vh>update_list</vh></v>
<v t="newlife.20110117110751.1583"><vh>add_list_member</vh></v>
<v t="newlife.20110117110751.1584"><vh>remove_list_member</vh></v>
<v t="newlife.20110117110751.1585"><vh>is_list_member</vh></v>
<v t="newlife.20110117110751.1586"><vh>is_subscribed_list</vh></v>
<v t="newlife.20110117110751.1587"><vh>_pack_image</vh></v>
</v>
</v>
<v t="newlife.20110117110751.1588"><vh>@file /home/newlife/ppy_office/ppy_official/thirdparty/weibopy/auth.py</vh>
<v t="newlife.20110117110751.1589"><vh>auth declarations</vh></v>
<v t="newlife.20110117110751.1590"><vh>class AuthHandler</vh>
<v t="newlife.20110117110751.1591"><vh>apply_auth</vh></v>
<v t="newlife.20110117110751.1592"><vh>get_username</vh></v>
</v>
<v t="newlife.20110117110751.1593"><vh>class BasicAuthHandler</vh>
<v t="newlife.20110117110751.1594"><vh>__init__</vh></v>
<v t="newlife.20110117110751.1595"><vh>apply_auth</vh></v>
<v t="newlife.20110117110751.1596"><vh>get_username</vh></v>
</v>
<v t="newlife.20110117110751.1597"><vh>class OAuthHandler</vh>
<v t="newlife.20110117110751.1598"><vh>__init__</vh></v>
<v t="newlife.20110117110751.1599"><vh>_get_oauth_url</vh></v>
<v t="newlife.20110117110751.1600"><vh>apply_auth</vh></v>
<v t="newlife.20110117110751.1601"><vh>_get_request_token</vh></v>
<v t="newlife.20110117110751.1602"><vh>set_request_token</vh></v>
<v t="newlife.20110117110751.1603"><vh>set_access_token</vh></v>
<v t="newlife.20110117110751.1604"><vh>get_authorization_url</vh></v>
<v t="newlife.20110117110751.1605"><vh>get_access_token</vh></v>
<v t="newlife.20110117110751.1606"><vh>setToken</vh></v>
<v t="newlife.20110117110751.1607"><vh>get_username</vh></v>
</v>
</v>
<v t="newlife.20110117110751.1608"><vh>@file /home/newlife/ppy_office/ppy_official/thirdparty/weibopy/binder.py</vh>
<v t="newlife.20110117110751.1609"><vh>binder declarations</vh></v>
<v t="newlife.20110117110751.1610"><vh>bind_api</vh></v>
</v>
<v t="newlife.20110117110751.1611"><vh>@file /home/newlife/ppy_office/ppy_official/thirdparty/weibopy/cache.py</vh>
<v t="newlife.20110117110751.1612"><vh>cache declarations</vh></v>
<v t="newlife.20110117110751.1613"><vh>class Cache</vh>
<v t="newlife.20110117110751.1614"><vh>__init__</vh></v>
<v t="newlife.20110117110751.1615"><vh>store</vh></v>
<v t="newlife.20110117110751.1616"><vh>get</vh></v>
<v t="newlife.20110117110751.1617"><vh>count</vh></v>
<v t="newlife.20110117110751.1618"><vh>cleanup</vh></v>
<v t="newlife.20110117110751.1619"><vh>flush</vh></v>
</v>
<v t="newlife.20110117110751.1620"><vh>class MemoryCache</vh>
<v t="newlife.20110117110751.1621"><vh>__init__</vh></v>
<v t="newlife.20110117110751.1622"><vh>__getstate__</vh></v>
<v t="newlife.20110117110751.1623"><vh>__setstate__</vh></v>
<v t="newlife.20110117110751.1624"><vh>_is_expired</vh></v>
<v t="newlife.20110117110751.1625"><vh>store</vh></v>
<v t="newlife.20110117110751.1626"><vh>get</vh></v>
<v t="newlife.20110117110751.1627"><vh>count</vh></v>
<v t="newlife.20110117110751.1628"><vh>cleanup</vh></v>
<v t="newlife.20110117110751.1629"><vh>flush</vh></v>
</v>
<v t="newlife.20110117110751.1630"><vh>class FileCache</vh>
<v t="newlife.20110117110751.1631"><vh>__init__</vh></v>
<v t="newlife.20110117110751.1632"><vh>_get_path</vh></v>
<v t="newlife.20110117110751.1633"><vh>_lock_file_dummy</vh></v>
<v t="newlife.20110117110751.1634"><vh>_unlock_file_dummy</vh></v>
<v t="newlife.20110117110751.1635"><vh>_lock_file_posix</vh></v>
<v t="newlife.20110117110751.1636"><vh>_unlock_file_posix</vh></v>
<v t="newlife.20110117110751.1637"><vh>_lock_file_win32</vh></v>
<v t="newlife.20110117110751.1638"><vh>_unlock_file_win32</vh></v>
<v t="newlife.20110117110751.1639"><vh>_delete_file</vh></v>
<v t="newlife.20110117110751.1640"><vh>store</vh></v>
<v t="newlife.20110117110751.1641"><vh>get</vh></v>
<v t="newlife.20110117110751.1642"><vh>_get</vh></v>
<v t="newlife.20110117110751.1643"><vh>count</vh></v>
<v t="newlife.20110117110751.1644"><vh>cleanup</vh></v>
<v t="newlife.20110117110751.1645"><vh>flush</vh></v>
</v>
</v>
<v t="newlife.20110117110751.1646"><vh>@file /home/newlife/ppy_office/ppy_official/thirdparty/weibopy/cursor.py</vh>
<v t="newlife.20110117110751.1647"><vh>cursor declarations</vh></v>
<v t="newlife.20110117110751.1648"><vh>class Cursor</vh>
<v t="newlife.20110117110751.1649"><vh>__init__</vh></v>
<v t="newlife.20110117110751.1650"><vh>pages</vh></v>
<v t="newlife.20110117110751.1651"><vh>items</vh></v>
</v>
<v t="newlife.20110117110751.1652"><vh>class BaseIterator</vh>
<v t="newlife.20110117110751.1653"><vh>__init__</vh></v>
<v t="newlife.20110117110751.1654"><vh>next</vh></v>
<v t="newlife.20110117110751.1655"><vh>prev</vh></v>
<v t="newlife.20110117110751.1656"><vh>__iter__</vh></v>
</v>
<v t="newlife.20110117110751.1657"><vh>class CursorIterator</vh>
<v t="newlife.20110117110751.1658"><vh>__init__</vh></v>
<v t="newlife.20110117110751.1659"><vh>next</vh></v>
<v t="newlife.20110117110751.1660"><vh>prev</vh></v>
</v>
<v t="newlife.20110117110751.1661"><vh>class PageIterator</vh>
<v t="newlife.20110117110751.1662"><vh>__init__</vh></v>
<v t="newlife.20110117110751.1663"><vh>next</vh></v>
<v t="newlife.20110117110751.1664"><vh>prev</vh></v>
</v>
<v t="newlife.20110117110751.1665"><vh>class ItemIterator</vh>
<v t="newlife.20110117110751.1666"><vh>__init__</vh></v>
<v t="newlife.20110117110751.1667"><vh>next</vh></v>
<v t="newlife.20110117110751.1668"><vh>prev</vh></v>
</v>
</v>
<v t="newlife.20110117110751.1669"><vh>@file /home/newlife/ppy_office/ppy_official/thirdparty/weibopy/error.py</vh>
<v t="newlife.20110117110751.1670"><vh>class WeibopError</vh>
<v t="newlife.20110117110751.1671"><vh>__init__</vh></v>
<v t="newlife.20110117110751.1672"><vh>__str__</vh></v>
</v>
</v>
<v t="newlife.20110117110751.1673"><vh>@file /home/newlife/ppy_office/ppy_official/thirdparty/weibopy/__init__.py</vh>
<v t="newlife.20110117110751.1674"><vh>__init__ declarations</vh></v>
<v t="newlife.20110117110751.1675"><vh>debug</vh></v>
</v>
<v t="newlife.20110117110751.1676"><vh>@file /home/newlife/ppy_office/ppy_official/thirdparty/weibopy/models.py</vh>
<v t="newlife.20110117110751.1677"><vh>models declarations</vh></v>
<v t="newlife.20110117110751.1678"><vh>class ResultSet</vh></v>
<v t="newlife.20110117110751.1679"><vh>class Model</vh>
<v t="newlife.20110117110751.1680"><vh>__init__</vh></v>
<v t="newlife.20110117110751.1681"><vh>__getstate__</vh></v>
<v t="newlife.20110117110751.1682"><vh>parse</vh></v>
<v t="newlife.20110117110751.1683"><vh>parse_list</vh></v>
</v>
<v t="newlife.20110117110751.1684"><vh>class Status</vh>
<v t="newlife.20110117110751.1685"><vh>parse</vh></v>
<v t="newlife.20110117110751.1686"><vh>destroy</vh></v>
<v t="newlife.20110117110751.1687"><vh>retweet</vh></v>
<v t="newlife.20110117110751.1688"><vh>retweets</vh></v>
<v t="newlife.20110117110751.1689"><vh>favorite</vh></v>
</v>
<v t="newlife.20110117110751.1690"><vh>class Geo</vh>
<v t="newlife.20110117110751.1691"><vh>parse</vh></v>
</v>
<v t="newlife.20110117110751.1692"><vh>class Comments</vh>
<v t="newlife.20110117110751.1693"><vh>parse</vh></v>
<v t="newlife.20110117110751.1694"><vh>destroy</vh></v>
<v t="newlife.20110117110751.1695"><vh>retweet</vh></v>
<v t="newlife.20110117110751.1696"><vh>retweets</vh></v>
<v t="newlife.20110117110751.1697"><vh>favorite</vh></v>
</v>
<v t="newlife.20110117110751.1698"><vh>class User</vh>
<v t="newlife.20110117110751.1699"><vh>parse</vh></v>
<v t="newlife.20110117110751.1700"><vh>parse_list</vh></v>
<v t="newlife.20110117110751.1701"><vh>timeline</vh></v>
<v t="newlife.20110117110751.1702"><vh>friends</vh></v>
<v t="newlife.20110117110751.1703"><vh>followers</vh></v>
<v t="newlife.20110117110751.1704"><vh>follow</vh></v>
<v t="newlife.20110117110751.1705"><vh>unfollow</vh></v>
<v t="newlife.20110117110751.1706"><vh>lists_memberships</vh></v>
<v t="newlife.20110117110751.1707"><vh>lists_subscriptions</vh></v>
<v t="newlife.20110117110751.1708"><vh>lists</vh></v>
<v t="newlife.20110117110751.1709"><vh>followers_ids</vh></v>
</v>
<v t="newlife.20110117110751.1710"><vh>class DirectMessage</vh>
<v t="newlife.20110117110751.1711"><vh>parse</vh></v>
</v>
<v t="newlife.20110117110751.1712"><vh>class Friendship</vh>
<v t="newlife.20110117110751.1713"><vh>parse</vh></v>
</v>
<v t="newlife.20110117110751.1714"><vh>class SavedSearch</vh>
<v t="newlife.20110117110751.1715"><vh>parse</vh></v>
<v t="newlife.20110117110751.1716"><vh>destroy</vh></v>
</v>
<v t="newlife.20110117110751.1717"><vh>class SearchResult</vh>
<v t="newlife.20110117110751.1718"><vh>parse</vh></v>
<v t="newlife.20110117110751.1719"><vh>parse_list</vh></v>
</v>
<v t="newlife.20110117110751.1720"><vh>class List</vh>
<v t="newlife.20110117110751.1721"><vh>parse</vh></v>
<v t="newlife.20110117110751.1722"><vh>parse_list</vh></v>
<v t="newlife.20110117110751.1723"><vh>update</vh></v>
<v t="newlife.20110117110751.1724"><vh>destroy</vh></v>
<v t="newlife.20110117110751.1725"><vh>timeline</vh></v>
<v t="newlife.20110117110751.1726"><vh>add_member</vh></v>
<v t="newlife.20110117110751.1727"><vh>remove_member</vh></v>
<v t="newlife.20110117110751.1728"><vh>members</vh></v>
<v t="newlife.20110117110751.1729"><vh>is_member</vh></v>
<v t="newlife.20110117110751.1730"><vh>subscribe</vh></v>
<v t="newlife.20110117110751.1731"><vh>unsubscribe</vh></v>
<v t="newlife.20110117110751.1732"><vh>subscribers</vh></v>
<v t="newlife.20110117110751.1733"><vh>is_subscribed</vh></v>
</v>
<v t="newlife.20110117110751.1734"><vh>class JSONModel</vh>
<v t="newlife.20110117110751.1735"><vh>parse</vh></v>
</v>
<v t="newlife.20110117110751.1736"><vh>class IDSModel</vh>
<v t="newlife.20110117110751.1737"><vh>parse</vh></v>
</v>
<v t="newlife.20110117110751.1738"><vh>class Counts</vh>
<v t="newlife.20110117110751.1739"><vh>parse</vh></v>
</v>
<v t="newlife.20110117110751.1740"><vh>class ModelFactory</vh></v>
</v>
<v t="newlife.20110117110751.1741"><vh>@file /home/newlife/ppy_office/ppy_official/thirdparty/weibopy/oauth.py</vh>
<v t="newlife.20110117110751.1742"><vh>oauth declarations</vh></v>
<v t="newlife.20110117110751.1743"><vh>class OAuthError</vh>
<v t="newlife.20110117110751.1744"><vh>__init__</vh></v>
</v>
<v t="newlife.20110117110751.1745"><vh>build_authenticate_header</vh></v>
<v t="newlife.20110117110751.1746"><vh>escape</vh></v>
<v t="newlife.20110117110751.1747"><vh>_utf8_str</vh></v>
<v t="newlife.20110117110751.1748"><vh>generate_timestamp</vh></v>
<v t="newlife.20110117110751.1749"><vh>generate_nonce</vh></v>
<v t="newlife.20110117110751.1750"><vh>generate_verifier</vh></v>
<v t="newlife.20110117110751.1751"><vh>class OAuthConsumer</vh>
<v t="newlife.20110117110751.1752"><vh>__init__</vh></v>
</v>
<v t="newlife.20110117110751.1753"><vh>class OAuthToken</vh>
<v t="newlife.20110117110751.1754"><vh>__init__</vh></v>
<v t="newlife.20110117110751.1755"><vh>set_callback</vh></v>
<v t="newlife.20110117110751.1756"><vh>set_verifier</vh></v>
<v t="newlife.20110117110751.1757"><vh>get_callback_url</vh></v>
<v t="newlife.20110117110751.1758"><vh>to_string</vh></v>
<v t="newlife.20110117110751.1759"><vh>from_string</vh></v>
<v t="newlife.20110117110751.1760"><vh>__str__</vh></v>
</v>
<v t="newlife.20110117110751.1761"><vh>class OAuthRequest</vh>
<v t="newlife.20110117110751.1762"><vh>__init__</vh></v>
<v t="newlife.20110117110751.1763"><vh>set_parameter</vh></v>
<v t="newlife.20110117110751.1764"><vh>get_parameter</vh></v>
<v t="newlife.20110117110751.1765"><vh>_get_timestamp_nonce</vh></v>
<v t="newlife.20110117110751.1766"><vh>get_nonoauth_parameters</vh></v>
<v t="newlife.20110117110751.1767"><vh>to_header</vh></v>
<v t="newlife.20110117110751.1768"><vh>to_postdata</vh></v>
<v t="newlife.20110117110751.1769"><vh>to_url</vh></v>
<v t="newlife.20110117110751.1770"><vh>get_normalized_parameters</vh></v>
<v t="newlife.20110117110751.1771"><vh>get_normalized_http_method</vh></v>
<v t="newlife.20110117110751.1772"><vh>get_normalized_http_url</vh></v>
<v t="newlife.20110117110751.1773"><vh>sign_request</vh></v>
<v t="newlife.20110117110751.1774"><vh>build_signature</vh></v>
<v t="newlife.20110117110751.1775"><vh>from_request</vh></v>
<v t="newlife.20110117110751.1776"><vh>from_consumer_and_token</vh></v>
<v t="newlife.20110117110751.1777"><vh>from_token_and_callback</vh></v>
<v t="newlife.20110117110751.1778"><vh>_split_header</vh></v>
<v t="newlife.20110117110751.1779"><vh>_split_url_string</vh></v>
</v>
<v t="newlife.20110117110751.1780"><vh>class OAuthServer</vh>
<v t="newlife.20110117110751.1781"><vh>__init__</vh></v>
<v t="newlife.20110117110751.1782"><vh>set_data_store</vh></v>
<v t="newlife.20110117110751.1783"><vh>get_data_store</vh></v>
<v t="newlife.20110117110751.1784"><vh>add_signature_method</vh></v>
<v t="newlife.20110117110751.1785"><vh>fetch_request_token</vh></v>
<v t="newlife.20110117110751.1786"><vh>fetch_access_token</vh></v>
<v t="newlife.20110117110751.1787"><vh>verify_request</vh></v>
<v t="newlife.20110117110751.1788"><vh>authorize_token</vh></v>
<v t="newlife.20110117110751.1789"><vh>get_callback</vh></v>
<v t="newlife.20110117110751.1790"><vh>build_authenticate_header</vh></v>
<v t="newlife.20110117110751.1791"><vh>_get_version</vh></v>
<v t="newlife.20110117110751.1792"><vh>_get_signature_method</vh></v>
<v t="newlife.20110117110751.1793"><vh>_get_consumer</vh></v>
<v t="newlife.20110117110751.1794"><vh>_get_token</vh></v>
<v t="newlife.20110117110751.1795"><vh>_get_verifier</vh></v>
<v t="newlife.20110117110751.1796"><vh>_check_signature</vh></v>
<v t="newlife.20110117110751.1797"><vh>_check_timestamp</vh></v>
<v t="newlife.20110117110751.1798"><vh>_check_nonce</vh></v>
</v>
<v t="newlife.20110117110751.1799"><vh>class OAuthClient</vh>
<v t="newlife.20110117110751.1800"><vh>__init__</vh></v>
<v t="newlife.20110117110751.1801"><vh>get_consumer</vh></v>
<v t="newlife.20110117110751.1802"><vh>get_token</vh></v>
<v t="newlife.20110117110751.1803"><vh>fetch_request_token</vh></v>
<v t="newlife.20110117110751.1804"><vh>fetch_access_token</vh></v>
<v t="newlife.20110117110751.1805"><vh>access_resource</vh></v>
</v>
<v t="newlife.20110117110751.1806"><vh>class OAuthDataStore</vh>
<v t="newlife.20110117110751.1807"><vh>lookup_consumer</vh></v>
<v t="newlife.20110117110751.1808"><vh>lookup_token</vh></v>
<v t="newlife.20110117110751.1809"><vh>lookup_nonce</vh></v>
<v t="newlife.20110117110751.1810"><vh>fetch_request_token</vh></v>
<v t="newlife.20110117110751.1811"><vh>fetch_access_token</vh></v>
<v t="newlife.20110117110751.1812"><vh>authorize_request_token</vh></v>
</v>
<v t="newlife.20110117110751.1813"><vh>class OAuthSignatureMethod</vh>
<v t="newlife.20110117110751.1814"><vh>get_name</vh></v>
<v t="newlife.20110117110751.1815"><vh>build_signature_base_string</vh></v>
<v t="newlife.20110117110751.1816"><vh>build_signature</vh></v>
<v t="newlife.20110117110751.1817"><vh>check_signature</vh></v>
</v>
<v t="newlife.20110117110751.1818"><vh>class OAuthSignatureMethod_HMAC_SHA1</vh>
<v t="newlife.20110117110751.1819"><vh>get_name</vh></v>
<v t="newlife.20110117110751.1820"><vh>build_signature_base_string</vh></v>
<v t="newlife.20110117110751.1821"><vh>build_signature</vh></v>
</v>
<v t="newlife.20110117110751.1822"><vh>class OAuthSignatureMethod_PLAINTEXT</vh>
<v t="newlife.20110117110751.1823"><vh>get_name</vh></v>
<v t="newlife.20110117110751.1824"><vh>build_signature_base_string</vh></v>
<v t="newlife.20110117110751.1825"><vh>build_signature</vh></v>
</v>
</v>
<v t="newlife.20110117110751.1826"><vh>@file /home/newlife/ppy_office/ppy_official/thirdparty/weibopy/parsers.py</vh>
<v t="newlife.20110117110751.1827"><vh>parsers declarations</vh></v>
<v t="newlife.20110117110751.1828"><vh>class Parser</vh>
<v t="newlife.20110117110751.1829"><vh>parse</vh></v>
<v t="newlife.20110117110751.1830"><vh>parse_error</vh></v>
</v>
<v t="newlife.20110117110751.1831"><vh>class JSONParser</vh>
<v t="newlife.20110117110751.1832"><vh>__init__</vh></v>
<v t="newlife.20110117110751.1833"><vh>parse</vh></v>
<v t="newlife.20110117110751.1834"><vh>parse_error</vh></v>
</v>
<v t="newlife.20110117110751.1835"><vh>class ModelParser</vh>
<v t="newlife.20110117110751.1836"><vh>__init__</vh></v>
<v t="newlife.20110117110751.1837"><vh>parse</vh></v>
</v>
</v>
<v t="newlife.20110117110751.1838" a="E"><vh>@file /home/newlife/ppy_office/ppy_official/thirdparty/weibopy/streaming.py</vh>
<v t="newlife.20110117110751.1839"><vh>streaming declarations</vh></v>
<v t="newlife.20110117110751.1840" a="E"><vh>class StreamListener</vh>
<v t="newlife.20110117110751.1841"><vh>__init__</vh></v>
<v t="newlife.20110117110751.1842"><vh>on_data</vh></v>
<v t="newlife.20110117110751.1843"><vh>on_status</vh></v>
<v t="newlife.20110117110751.1844"><vh>on_delete</vh></v>
<v t="newlife.20110117110751.1845"><vh>on_limit</vh></v>
<v t="newlife.20110117110751.1846"><vh>on_error</vh></v>
<v t="newlife.20110117110751.1847"><vh>on_timeout</vh></v>
</v>
<v t="newlife.20110117110751.1848"><vh>class Stream</vh>
<v t="newlife.20110117110751.1849"><vh>__init__</vh></v>
<v t="newlife.20110117110751.1850"><vh>_run</vh></v>
<v t="newlife.20110117110751.1851"><vh>_read_loop</vh></v>
<v t="newlife.20110117110751.1852"><vh>_start</vh></v>
<v t="newlife.20110117110751.1853"><vh>firehose</vh></v>
<v t="newlife.20110117110751.1854"><vh>retweet</vh></v>
<v t="newlife.20110117110751.1855"><vh>sample</vh></v>
<v t="newlife.20110117110751.1856"><vh>filter</vh></v>
<v t="newlife.20110117110751.1857"><vh>disconnect</vh></v>
</v>
</v>
<v t="newlife.20110117110751.1858"><vh>@file /home/newlife/ppy_office/ppy_official/thirdparty/weibopy/utils.py</vh>
<v t="newlife.20110117110751.1859"><vh>utils declarations</vh></v>
<v t="newlife.20110117110751.1860"><vh>parse_datetime</vh></v>
<v t="newlife.20110117110751.1861"><vh>parse_html_value</vh></v>
<v t="newlife.20110117110751.1862"><vh>parse_a_href</vh></v>
<v t="newlife.20110117110751.1863"><vh>parse_search_datetime</vh></v>
<v t="newlife.20110117110751.1864"><vh>unescape_html</vh></v>
<v t="newlife.20110117110751.1865"><vh>convert_to_utf8_str</vh></v>
<v t="newlife.20110117110751.1866"><vh>import_simplejson</vh></v>
</v>
</v>
<v t="newlife.20110117110751.1880"><vh>流程</vh>
<v t="newlife.20110117110751.1874"><vh>get_user_authorize</vh></v>
<v t="newlife.20110117110751.1875"><vh>get_access_token</vh>
<v t="wjl.20110119224651.1871" a="E"><vh>@file /home/wjl/ppy/ppy_official/users/helper_tencent.py</vh>
<v t="wjl.20110119224651.1872"><vh>helper_tencent declarations</vh></v>
<v t="wjl.20110119224651.1873"><vh>get_request_token</vh></v>
<v t="wjl.20110119224651.1874"><vh>get_user_authorize</vh></v>
<v t="wjl.20110119224651.1875"><vh>get_access_token</vh></v>
<v t="wjl.20110119224651.1876"><vh>tencent_upload</vh></v>
<v t="wjl.20110119224651.1889"><vh>get_member_bindblog_info</vh></v>
</v>
<v t="wjl.20110119224651.1877" a="E"><vh>@file /home/wjl/ppy/ppy_official/users/helper_sina.py</vh>
<v t="wjl.20110119224651.1878"><vh>helper_sina declarations</vh></v>
<v t="wjl.20110119224651.1879"><vh>update_sina_accesstoken</vh></v>
<v t="wjl.20110119224651.1880"><vh>is_send_feed</vh></v>
<v t="wjl.20110119224651.1881"><vh>send_user_feed</vh></v>
<v t="wjl.20110119224651.1882"><vh>get_request_token</vh></v>
<v t="wjl.20110119224651.1883"><vh>get_user_authorize</vh></v>
<v t="wjl.20110119224651.1884"><vh>get_access_token</vh></v>
<v t="wjl.20110119224651.1885"><vh>sina_bind_newfeed</vh></v>
<v t="wjl.20110119224651.1886"><vh>sina_upload</vh></v>
</v>
</v>
</v>
<v t="wjl.20110119224651.1890" a="E"><vh>任务估计</vh>
<v t="wjl.20110119224651.1891"><vh>1，上传数据</vh></v>
<v t="wjl.20110119224651.1892"><vh>2，js调用</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="newlife.20110117110751.1267">通过这次的工作，我深刻的意识，

状态，需要不断的保持，不能闲啊，一定要保持旺盛的斗志，我就是前一段时间太闲了，
导致学习和工作的状态持续下滑，

看看现在连一个简单的去qq_oauth登录都做不出来，一方面，这个东西以前确实没做过，
还有对http请求这块也不熟，所以才造成这样的后果，
再有就是这个库写的那叫一个恶心啊
任何的学习都不会是轻而易举的。

这是在逼我啊，，
看来要我从头研究一边这个傻逼的oauth库。。。。

干！！！

OAuth规范定义了三种传递OAuth参数方式：
1.header中
2.url中
3.post form中
然而进行POST，PUT，DELETE请求时，腾讯微博暂时不支持使用在OAuth中传递OAuth参数。因此你只能选择在url中传递OAuth参数。
所以我传post的时候咋传啊

</t>
<t tx="newlife.20110117110751.1268">http://open.t.qq.com/resource.php?i=1,2

1.获取未授权的Request Token(temporary credentials)
2.请求用户授权Request Token
3.使用授权后的Request Token换取Access Token(token credentials)
4.使用 Access Token 访问或修改受保护资源

由我的qq号申请的腾讯微博开发key：

App Key：051cc73533344b74b234c4504fb8868d
App Secret：1aae7458103e4ee3bb1bf740f6954aee</t>
<t tx="newlife.20110117110751.1269"></t>
<t tx="newlife.20110117110751.1569">@language python
@tabwidth -4
@others
@ignore</t>
<t tx="newlife.20110117110751.1570"># -*- coding: utf-8 -*-

# Copyright 2009-2010 Joshua Roesslein
# See LICENSE for details.

import os
import mimetypes

from weibopy.binder import bind_api
from weibopy.error import WeibopError
from weibopy.parsers import ModelParser


</t>
<t tx="newlife.20110117110751.1571">class API(object):
    """Twitter API"""
    @others
</t>
<t tx="newlife.20110117110751.1572">
def __init__(self, auth_handler=None,
        host='api.t.sina.com.cn', search_host='api.t.sina.com.cn',
         cache=None, secure=False, api_root='', search_root='',
        retry_count=0, retry_delay=0, retry_errors=None,source=None,
        parser=None, log = None):
    self.auth = auth_handler
    self.host = host
    if source == None:
        if auth_handler != None:
            self.source = self.auth._consumer.key
    else:
        self.source = source
    self.search_host = search_host
    self.api_root = api_root
    self.search_root = search_root
    self.cache = cache
    self.secure = secure
    self.retry_count = retry_count
    self.retry_delay = retry_delay
    self.retry_errors = retry_errors
    self.parser = parser or ModelParser()
    self.log = log

</t>
<t tx="newlife.20110117110751.1573">""" statuses/public_timeline """
public_timeline = bind_api(
    path = '/statuses/public_timeline.json',
    payload_type = 'status', payload_list = True,
    allowed_param = []
)

""" statuses/home_timeline """
home_timeline = bind_api(
    path = '/statuses/home_timeline.json',
    payload_type = 'status', payload_list = True,
    allowed_param = ['since_id', 'max_id', 'count', 'page'],
    require_auth = True
)

""" statuses/friends_timeline """
friends_timeline = bind_api(
    path = '/statuses/friends_timeline.json',
    payload_type = 'status', payload_list = True,
    allowed_param = ['since_id', 'max_id', 'count', 'page'],
    require_auth = True
)
""" statuses/comment """
comment = bind_api(
    path = '/statuses/comment.json',
    method = 'POST',
    payload_type = 'comments',
    allowed_param = ['id', 'cid', 'comment'],
    require_auth = True
)

""" statuses/comment_destroy """
comment_destroy  = bind_api(
    path = '/statuses/comment_destroy/{id}.json',
    method = 'POST',
    payload_type = 'comments',
    allowed_param = ['id'],
    require_auth = True
)

""" statuses/comments_timeline """
comments = bind_api(
    path = '/statuses/comments.json',
    payload_type = 'comments', payload_list = True,
    allowed_param = ['id', 'count', 'page'],
    require_auth = True
)

""" statuses/comments_timeline """
comments_timeline = bind_api(
    path = '/statuses/comments_timeline.json',
    payload_type = 'comments', payload_list = True,
    allowed_param = ['since_id', 'max_id', 'count', 'page'],
    require_auth = True
)

""" statuses/comments_by_me """
comments_by_me = bind_api(
    path = '/statuses/comments_by_me.json',
    payload_type = 'comments', payload_list = True,
    allowed_param = ['since_id', 'max_id', 'count', 'page'],
    require_auth = True
)

""" statuses/user_timeline """
user_timeline = bind_api(
    path = '/statuses/user_timeline.json',
    payload_type = 'status', payload_list = True,
    allowed_param = ['id', 'user_id', 'screen_name', 'since_id',
                      'max_id', 'count', 'page']
)

""" statuses/mentions """
mentions = bind_api(
    path = '/statuses/mentions.json',
    payload_type = 'status', payload_list = True,
    allowed_param = ['since_id', 'max_id', 'count', 'page'],
    require_auth = True
)

""" statuses/counts """
counts = bind_api(
    path = '/statuses/counts.json',
    payload_type = 'counts', payload_list = True,
    allowed_param = ['ids'],
    require_auth = True
)

""" statuses/unread """
unread = bind_api(
    path = '/statuses/unread.json',
    payload_type = 'counts'
)

""" statuses/retweeted_by_me """
retweeted_by_me = bind_api(
    path = '/statuses/retweeted_by_me.json',
    payload_type = 'status', payload_list = True,
    allowed_param = ['since_id', 'max_id', 'count', 'page'],
    require_auth = True
)

""" statuses/retweeted_to_me """
retweeted_to_me = bind_api(
    path = '/statuses/retweeted_to_me.json',
    payload_type = 'status', payload_list = True,
    allowed_param = ['since_id', 'max_id', 'count', 'page'],
    require_auth = True
)

""" statuses/retweets_of_me """
retweets_of_me = bind_api(
    path = '/statuses/retweets_of_me.json',
    payload_type = 'status', payload_list = True,
    allowed_param = ['since_id', 'max_id', 'count', 'page'],
    require_auth = True
)

""" statuses/show """
get_status = bind_api(
    path = '/statuses/show.json',
    payload_type = 'status',
    allowed_param = ['id']
)

""" statuses/update """
update_status = bind_api(
    path = '/statuses/update.json',
    method = 'POST',
    payload_type = 'status',
    allowed_param = ['status', 'lat', 'long', 'source'],
    require_auth = True
)
""" statuses/upload """
def upload(self, filename, status, lat=None, long=None, source=None):
    if source is None:
        source=self.source
    headers, post_data = API._pack_image(filename, 1024, source=source, status=status, lat=lat, long=long, contentname="pic")
    args = [status]
    allowed_param = ['status']

    if lat is not None:
        args.append(lat)
        allowed_param.append('lat')

    if long is not None:
        args.append(long)
        allowed_param.append('long')

    if source is not None:
        args.append(source)
        allowed_param.append('source')

    ad = {'post_data':post_data, 'headers':headers}
    return bind_api(
        path = '/statuses/upload.json',
        method = 'POST',
        payload_type = 'status',
        require_auth = True,
        allowed_param = allowed_param
    )(self, *args, **ad)

</t>
<t tx="newlife.20110117110751.1574">""" statuses/reply """
reply = bind_api(
    path = '/statuses/reply.json',
    method = 'POST',
    payload_type = 'status',
    allowed_param = ['id', 'cid','comment'],
    require_auth = True
)

""" statuses/repost """
repost = bind_api(
    path = '/statuses/repost.json',
    method = 'POST',
    payload_type = 'status',
    allowed_param = ['id', 'status'],
    require_auth = True
)

""" statuses/destroy """
destroy_status = bind_api(
    path = '/statuses/destroy/{id}.json',
    method = 'DELETE',
    payload_type = 'status',
    allowed_param = ['id'],
    require_auth = True
)

""" statuses/retweet """
retweet = bind_api(
    path = '/statuses/retweet/{id}.json',
    method = 'POST',
    payload_type = 'status',
    allowed_param = ['id'],
    require_auth = True
)

""" statuses/retweets """
retweets = bind_api(
    path = '/statuses/retweets/{id}.json',
    payload_type = 'status', payload_list = True,
    allowed_param = ['id', 'count'],
    require_auth = True
)

""" users/show """
get_user = bind_api(
    path = '/users/show.json',
    payload_type = 'user',
    allowed_param = ['id', 'user_id', 'screen_name']
)

""" Get the authenticated user """
def me(self):
    return self.get_user(screen_name=self.auth.get_username())

</t>
<t tx="newlife.20110117110751.1575">""" users/search """
search_users = bind_api(
    path = '/users/search.json',
    payload_type = 'user', payload_list = True,
    require_auth = True,
    allowed_param = ['q', 'per_page', 'page']
)

""" statuses/friends """
friends = bind_api(
    path = '/statuses/friends.json',
    payload_type = 'user', payload_list = True,
    allowed_param = ['id', 'user_id', 'screen_name', 'page', 'cursor']
)

""" statuses/followers """
followers = bind_api(
    path = '/statuses/followers.json',
    payload_type = 'user', payload_list = True,
    allowed_param = ['id', 'user_id', 'screen_name', 'page', 'cursor']
)

""" direct_messages """
direct_messages = bind_api(
    path = '/direct_messages.json',
    payload_type = 'direct_message', payload_list = True,
    allowed_param = ['since_id', 'max_id', 'count', 'page'],
    require_auth = True
)

""" direct_messages/sent """
sent_direct_messages = bind_api(
    path = '/direct_messages/sent.json',
    payload_type = 'direct_message', payload_list = True,
    allowed_param = ['since_id', 'max_id', 'count', 'page'],
    require_auth = True
)
""" direct_messages/new """
new_direct_message = bind_api(
    path = '/direct_messages/new.json',
    method = 'POST',
    payload_type = 'direct_message',
    allowed_param = ['id', 'screen_name', 'user_id', 'text'],
    require_auth = True
)

""" direct_messages/destroy """
destroy_direct_message = bind_api(
    path = '/direct_messages/destroy/{id}.json',
    method = 'DELETE',
    payload_type = 'direct_message',
    allowed_param = ['id'],
    require_auth = True
)

""" friendships/create """
create_friendship = bind_api(
    path = '/friendships/create.json',
    method = 'POST',
    payload_type = 'user',
    allowed_param = ['id', 'user_id', 'screen_name', 'follow'],
    require_auth = True
)

""" friendships/destroy """
destroy_friendship = bind_api(
    path = '/friendships/destroy.json',
    method = 'DELETE',
    payload_type = 'user',
    allowed_param = ['id', 'user_id', 'screen_name'],
    require_auth = True
)

""" friendships/exists """
exists_friendship = bind_api(
    path = '/friendships/exists.json',
    payload_type = 'json',
    allowed_param = ['user_a', 'user_b']
)

""" friendships/show """
show_friendship = bind_api(
    path = '/friendships/show.json',
    payload_type = 'friendship',
    allowed_param = ['source_id', 'source_screen_name',
                      'target_id', 'target_screen_name']
)

""" friends/ids """
friends_ids = bind_api(
    path = '/friends/ids.json',
    payload_type = 'user',
    allowed_param = ['id', 'user_id', 'screen_name', 'cursor', 'count'],
    require_auth = True
)

""" followers/ids """
followers_ids = bind_api(        
    path = '/followers/ids.json',
    payload_type = 'json',
    allowed_param = ['id', 'page'],
)

""" account/verify_credentials """
def verify_credentials(self):
    try:
        return bind_api(
            path = '/account/verify_credentials.json',
            payload_type = 'user',
            require_auth = True
        )(self)
    except WeibopError:
        return False

</t>
<t tx="newlife.20110117110751.1576">""" account/rate_limit_status """
rate_limit_status = bind_api(
    path = '/account/rate_limit_status.json',
    payload_type = 'json'
)

""" account/update_delivery_device """
set_delivery_device = bind_api(
    path = '/account/update_delivery_device.json',
    method = 'POST',
    allowed_param = ['device'],
    payload_type = 'user',
    require_auth = True
)

""" account/update_profile_colors """
update_profile_colors = bind_api(
    path = '/account/update_profile_colors.json',
    method = 'POST',
    payload_type = 'user',
    allowed_param = ['profile_background_color', 'profile_text_color',
                      'profile_link_color', 'profile_sidebar_fill_color',
                      'profile_sidebar_border_color'],
    require_auth = True
)

""" account/update_profile_image """
def update_profile_image(self, filename):
    headers, post_data = API._pack_image(filename=filename, max_size=700, source=self.source)
    return bind_api(
        path = '/account/update_profile_image.json',
        method = 'POST',
        payload_type = 'user',
        require_auth = True
    )(self, post_data=post_data, headers=headers)

</t>
<t tx="newlife.20110117110751.1577">""" account/update_profile_background_image """
def update_profile_background_image(self, filename, *args, **kargs):
    headers, post_data = API._pack_image(filename, 800)
    bind_api(
        path = '/account/update_profile_background_image.json',
        method = 'POST',
        payload_type = 'user',
        allowed_param = ['tile'],
        require_auth = True
    )(self, post_data=post_data, headers=headers)

</t>
<t tx="newlife.20110117110751.1578">""" account/update_profile """
update_profile = bind_api(
    path = '/account/update_profile.json',
    method = 'POST',
    payload_type = 'user',
    allowed_param = ['name', 'url', 'location', 'description'],
    require_auth = True
)

""" favorites """
favorites = bind_api(
    path = '/favorites/{id}.json',
    payload_type = 'status', payload_list = True,
    allowed_param = ['id', 'page']
)

""" favorites/create """
create_favorite = bind_api(
    path = '/favorites/create/{id}.json',
    method = 'POST',
    payload_type = 'status',
    allowed_param = ['id'],
    require_auth = True
)

""" favorites/destroy """
destroy_favorite = bind_api(
    path = '/favorites/destroy/{id}.json',
    method = 'DELETE',
    payload_type = 'status',
    allowed_param = ['id'],
    require_auth = True
)

""" notifications/follow """
enable_notifications = bind_api(
    path = '/notifications/follow.json',
    method = 'POST',
    payload_type = 'user',
    allowed_param = ['id', 'user_id', 'screen_name'],
    require_auth = True
)

""" notifications/leave """
disable_notifications = bind_api(
    path = '/notifications/leave.json',
    method = 'POST',
    payload_type = 'user',
    allowed_param = ['id', 'user_id', 'screen_name'],
    require_auth = True
)

""" blocks/create """
create_block = bind_api(
    path = '/blocks/create.json',
    method = 'POST',
    payload_type = 'user',
    allowed_param = ['id', 'user_id', 'screen_name'],
    require_auth = True
)

""" blocks/destroy """
destroy_block = bind_api(
    path = '/blocks/destroy.json',
    method = 'DELETE',
    payload_type = 'user',
    allowed_param = ['id', 'user_id', 'screen_name'],
    require_auth = True
)

""" blocks/exists """
def exists_block(self, *args, **kargs):
    try:
        bind_api(
            path = '/blocks/exists.json',
            allowed_param = ['id', 'user_id', 'screen_name'],
            require_auth = True
        )(self, *args, **kargs)
    except WeibopError:
        return False
    return True

</t>
<t tx="newlife.20110117110751.1579">""" blocks/blocking """
blocks = bind_api(
    path = '/blocks/blocking.json',
    payload_type = 'user', payload_list = True,
    allowed_param = ['page'],
    require_auth = True
)

""" blocks/blocking/ids """
blocks_ids = bind_api(
    path = '/blocks/blocking/ids.json',
    payload_type = 'json',
    require_auth = True
)

""" statuses/repost """
report_spam = bind_api(
    path = '/report_spam.json',
    method = 'POST',
    payload_type = 'user',
    allowed_param = ['id', 'user_id', 'screen_name'],
    require_auth = True
)

""" saved_searches """
saved_searches = bind_api(
    path = '/saved_searches.json',
    payload_type = 'saved_search', payload_list = True,
    require_auth = True
)

""" saved_searches/show """
get_saved_search = bind_api(
    path = '/saved_searches/show/{id}.json',
    payload_type = 'saved_search',
    allowed_param = ['id'],
    require_auth = True
)

""" saved_searches/create """
create_saved_search = bind_api(
    path = '/saved_searches/create.json',
    method = 'POST',
    payload_type = 'saved_search',
    allowed_param = ['query'],
    require_auth = True
)

""" saved_searches/destroy """
destroy_saved_search = bind_api(
    path = '/saved_searches/destroy/{id}.json',
    method = 'DELETE',
    payload_type = 'saved_search',
    allowed_param = ['id'],
    require_auth = True
)

""" help/test """
def test(self):
    try:
        bind_api(
            path = '/help/test.json',
        )(self)
    except WeibopError:
        return False
    return True

</t>
<t tx="newlife.20110117110751.1580">def create_list(self, *args, **kargs):
    return bind_api(
        path = '/%s/lists.json' % self.auth.get_username(),
        method = 'POST',
        payload_type = 'list',
        allowed_param = ['name', 'mode', 'description'],
        require_auth = True
    )(self, *args, **kargs)

</t>
<t tx="newlife.20110117110751.1581">def destroy_list(self, slug):
    return bind_api(
        path = '/%s/lists/%s.json' % (self.auth.get_username(), slug),
        method = 'DELETE',
        payload_type = 'list',
        require_auth = True
    )(self)

</t>
<t tx="newlife.20110117110751.1582">def update_list(self, slug, *args, **kargs):
    return bind_api(
        path = '/%s/lists/%s.json' % (self.auth.get_username(), slug),
        method = 'POST',
        payload_type = 'list',
        allowed_param = ['name', 'mode', 'description'],
        require_auth = True
    )(self, *args, **kargs)

</t>
<t tx="newlife.20110117110751.1583">lists = bind_api(
    path = '/{user}/lists.json',
    payload_type = 'list', payload_list = True,
    allowed_param = ['user', 'cursor'],
    require_auth = True
)

lists_memberships = bind_api(
    path = '/{user}/lists/memberships.json',
    payload_type = 'list', payload_list = True,
    allowed_param = ['user', 'cursor'],
    require_auth = True
)

lists_subscriptions = bind_api(
    path = '/{user}/lists/subscriptions.json',
    payload_type = 'list', payload_list = True,
    allowed_param = ['user', 'cursor'],
    require_auth = True
)

list_timeline = bind_api(
    path = '/{owner}/lists/{slug}/statuses.json',
    payload_type = 'status', payload_list = True,
    allowed_param = ['owner', 'slug', 'since_id', 'max_id', 'count', 'page']
)

get_list = bind_api(
    path = '/{owner}/lists/{slug}.json',
    payload_type = 'list',
    allowed_param = ['owner', 'slug']
)

def add_list_member(self, slug, *args, **kargs):
    return bind_api(
        path = '/%s/%s/members.json' % (self.auth.get_username(), slug),
        method = 'POST',
        payload_type = 'list',
        allowed_param = ['id'],
        require_auth = True
    )(self, *args, **kargs)

</t>
<t tx="newlife.20110117110751.1584">def remove_list_member(self, slug, *args, **kargs):
    return bind_api(
        path = '/%s/%s/members.json' % (self.auth.get_username(), slug),
        method = 'DELETE',
        payload_type = 'list',
        allowed_param = ['id'],
        require_auth = True
    )(self, *args, **kargs)

</t>
<t tx="newlife.20110117110751.1585">list_members = bind_api(
    path = '/{owner}/{slug}/members.json',
    payload_type = 'user', payload_list = True,
    allowed_param = ['owner', 'slug', 'cursor']
)

def is_list_member(self, owner, slug, user_id):
    try:
        return bind_api(
            path = '/%s/%s/members/%s.json' % (owner, slug, user_id),
            payload_type = 'user'
        )(self)
    except WeibopError:
        return False

</t>
<t tx="newlife.20110117110751.1586">subscribe_list = bind_api(
    path = '/{owner}/{slug}/subscribers.json',
    method = 'POST',
    payload_type = 'list',
    allowed_param = ['owner', 'slug'],
    require_auth = True
)

unsubscribe_list = bind_api(
    path = '/{owner}/{slug}/subscribers.json',
    method = 'DELETE',
    payload_type = 'list',
    allowed_param = ['owner', 'slug'],
    require_auth = True
)

list_subscribers = bind_api(
    path = '/{owner}/{slug}/subscribers.json',
    payload_type = 'user', payload_list = True,
    allowed_param = ['owner', 'slug', 'cursor']
)

def is_subscribed_list(self, owner, slug, user_id):
    try:
        return bind_api(
            path = '/%s/%s/subscribers/%s.json' % (owner, slug, user_id),
            payload_type = 'user'
        )(self)
    except WeibopError:
        return False

</t>
<t tx="newlife.20110117110751.1587">""" trends/available """
trends_available = bind_api(
    path = '/trends/available.json',
    payload_type = 'json',
    allowed_param = ['lat', 'long']
)

""" trends/location """
trends_location = bind_api(
    path = '/trends/{woeid}.json',
    payload_type = 'json',
    allowed_param = ['woeid']
)

""" search """
search = bind_api(
    search_api = True,
    path = '/search.json',
    payload_type = 'search_result', payload_list = True,
    allowed_param = ['q', 'lang', 'locale', 'rpp', 'page', 'since_id', 'geocode', 'show_user']
)
search.pagination_mode = 'page'

""" trends """
trends = bind_api(
    search_api = True,
    path = '/trends.json',
    payload_type = 'json'
)

""" trends/current """
trends_current = bind_api(
    search_api = True,
    path = '/trends/current.json',
    payload_type = 'json',
    allowed_param = ['exclude']
)

""" trends/daily """
trends_daily = bind_api(
    search_api = True,
    path = '/trends/daily.json',
    payload_type = 'json',
    allowed_param = ['date', 'exclude']
)

""" trends/weekly """
trends_weekly = bind_api(
    search_api = True,
    path = '/trends/weekly.json',
    payload_type = 'json',
    allowed_param = ['date', 'exclude']
)
""" Internal use only """
@staticmethod
def _pack_image(filename, max_size, source=None, status=None, lat=None, long=None, contentname="image"):
    """Pack image from file into multipart-formdata post body"""
    # image must be less than 700kb in size
    try:
        if os.path.getsize(filename) &gt; (max_size * 1024):
            raise WeibopError('File is too big, must be less than 700kb.')
    #except os.error, e:
    except os.error:
        raise WeibopError('Unable to access file')

    # image must be gif, jpeg, or png
    file_type = mimetypes.guess_type(filename)
    if file_type is None:
        raise WeibopError('Could not determine file type')
    file_type = file_type[0]
    if file_type not in ['image/gif', 'image/jpeg', 'image/png']:
        raise WeibopError('Invalid file type for image: %s' % file_type)

    # build the mulitpart-formdata body
    fp = open(filename, 'rb')
    BOUNDARY = 'Tw3ePy'
    body = []
    if status is not None:
        body.append('--' + BOUNDARY)
        body.append('Content-Disposition: form-data; name="status"')
        body.append('Content-Type: text/plain; charset=US-ASCII')
        body.append('Content-Transfer-Encoding: 8bit')
        body.append('')
        body.append(status)
    if source is not None:
        body.append('--' + BOUNDARY)
        body.append('Content-Disposition: form-data; name="source"')
        body.append('Content-Type: text/plain; charset=US-ASCII')
        body.append('Content-Transfer-Encoding: 8bit')
        body.append('')
        body.append(source)
    if lat is not None:
        body.append('--' + BOUNDARY)
        body.append('Content-Disposition: form-data; name="lat"')
        body.append('Content-Type: text/plain; charset=US-ASCII')
        body.append('Content-Transfer-Encoding: 8bit')
        body.append('')
        body.append(lat)
    if long is not None:
        body.append('--' + BOUNDARY)
        body.append('Content-Disposition: form-data; name="long"')
        body.append('Content-Type: text/plain; charset=US-ASCII')
        body.append('Content-Transfer-Encoding: 8bit')
        body.append('')
        body.append(long)
    body.append('--' + BOUNDARY)
    body.append('Content-Disposition: form-data; name="'+ contentname +'"; filename="%s"' % filename)
    body.append('Content-Type: %s' % file_type)
    body.append('Content-Transfer-Encoding: binary')
    body.append('')
    pic_data = fp.read()
    body.append(pic_data)
    body.append('--' + BOUNDARY + '--')
    body.append('')
    fp.close()
    body.append('--' + BOUNDARY + '--')
    body.append('')
    body = [str(data) for data in body]
    body = '\r\n'.join(body)
    # build headers
    headers = {
        'Content-Type': 'multipart/form-data; boundary=Tw3ePy',
        'Content-Length': str(len(body))
    }

    return headers, body

</t>
<t tx="newlife.20110117110751.1588">@language python
@tabwidth -4
@others
@ignore</t>
<t tx="newlife.20110117110751.1589">
# Copyright 2009-2010 Joshua Roesslein
# See LICENSE for details.

from urllib2 import Request, urlopen
import base64

from weibopy import oauth
from weibopy.error import WeibopError
from weibopy.api import API


</t>
<t tx="newlife.20110117110751.1590">class AuthHandler(object):
    @others
</t>
<t tx="newlife.20110117110751.1591">
def apply_auth(self, url, method, headers, parameters):
    """Apply authentication headers to request"""
    raise NotImplementedError

</t>
<t tx="newlife.20110117110751.1592">def get_username(self):
    """Return the username of the authenticated user"""
    raise NotImplementedError


</t>
<t tx="newlife.20110117110751.1593">class BasicAuthHandler(AuthHandler):
    @others
</t>
<t tx="newlife.20110117110751.1594">
def __init__(self, username, password):
    self.username = username
    self._b64up = base64.b64encode('%s:%s' % (username, password))

</t>
<t tx="newlife.20110117110751.1595">def apply_auth(self, url, method, headers, parameters):
    headers['Authorization'] = 'Basic %s' % self._b64up

</t>
<t tx="newlife.20110117110751.1596">def get_username(self):
    return self.username


</t>
<t tx="newlife.20110117110751.1597">class OAuthHandler(AuthHandler):
    """OAuth authentication handler"""

    OAUTH_HOST = 'api.t.sina.com.cn'
    OAUTH_ROOT = '/oauth/'

    @others
</t>
<t tx="newlife.20110117110751.1598">def __init__(self, consumer_key, consumer_secret, callback=None, secure=False):
    self._consumer = oauth.OAuthConsumer(consumer_key, consumer_secret)
    self._sigmethod = oauth.OAuthSignatureMethod_HMAC_SHA1()
    self.request_token = None
    self.access_token = None
    self.callback = callback
    self.username = None
    self.secure = secure

</t>
<t tx="newlife.20110117110751.1599">def _get_oauth_url(self, endpoint):
    if self.secure:
        prefix = 'https://'
    else:
        prefix = 'http://'

    return prefix + self.OAUTH_HOST + self.OAUTH_ROOT + endpoint

</t>
<t tx="newlife.20110117110751.1600">def apply_auth(self, url, method, headers, parameters):
    request = oauth.OAuthRequest.from_consumer_and_token(
        self._consumer, http_url=url, http_method=method,
        token=self.access_token, parameters=parameters
    )
    request.sign_request(self._sigmethod, self._consumer, self.access_token)
    headers.update(request.to_header())

</t>
<t tx="newlife.20110117110751.1601">def _get_request_token(self):
    try:
        url = self._get_oauth_url('request_token')
        request = oauth.OAuthRequest.from_consumer_and_token(
            self._consumer, http_url=url, callback=self.callback
        )
        request.sign_request(self._sigmethod, self._consumer, None)
        resp = urlopen(Request(url, headers=request.to_header()))
        return oauth.OAuthToken.from_string(resp.read())
    except Exception, e:
        raise WeibopError(e)

</t>
<t tx="newlife.20110117110751.1602">def set_request_token(self, key, secret):
    self.request_token = oauth.OAuthToken(key, secret)

</t>
<t tx="newlife.20110117110751.1603">def set_access_token(self, key, secret):
    self.access_token = oauth.OAuthToken(key, secret)

</t>
<t tx="newlife.20110117110751.1604">def get_authorization_url(self, signin_with_twitter=False):
    """Get the authorization URL to redirect the user"""
    try:
        # get the request token
        self.request_token = self._get_request_token()

        # build auth request and return as url
        if signin_with_twitter:
            url = self._get_oauth_url('authenticate')
        else:
            url = self._get_oauth_url('authorize')
        request = oauth.OAuthRequest.from_token_and_callback(
            token=self.request_token, http_url=url
        )

        return request.to_url()
    except Exception, e:
        raise WeibopError(e)

</t>
<t tx="newlife.20110117110751.1605">def get_access_token(self, verifier=None):
    """
    After user has authorized the request token, get access token
    with user supplied verifier.
    """
    try:
        url = self._get_oauth_url('access_token')

        # build request
        request = oauth.OAuthRequest.from_consumer_and_token(
            self._consumer,
            token=self.request_token, http_url=url,
            verifier=str(verifier)
        )
        request.sign_request(self._sigmethod, self._consumer, self.request_token)

        # send request                        
        resp = urlopen(Request(url, headers=request.to_header()))
        self.access_token = oauth.OAuthToken.from_string(resp.read())

        print 'Access token key: '+ str(self.access_token.key)
        print 'Access token secret: '+ str(self.access_token.secret)

        return self.access_token
    except Exception, e:
        raise WeibopError(e)

</t>
<t tx="newlife.20110117110751.1606">def setToken(self, token, tokenSecret):
    self.access_token = oauth.OAuthToken(token, tokenSecret)

</t>
<t tx="newlife.20110117110751.1607">def get_username(self):
    if self.username is None:
        api = API(self)
        user = api.verify_credentials()
        if user:
            self.username = user.screen_name
        else:
            raise WeibopError("Unable to get username, invalid oauth token!")
    return self.username</t>
<t tx="newlife.20110117110751.1608">@language python
@tabwidth -4
@others
@ignore</t>
<t tx="newlife.20110117110751.1609">
# Copyright 2009-2010 Joshua Roesslein
# See LICENSE for details.

import httplib
import urllib
import time
import re
from weibopy.error import WeibopError
from weibopy.utils import convert_to_utf8_str

re_path_template = re.compile('{\w+}')


</t>
<t tx="newlife.20110117110751.1610">def bind_api(**config):

    class APIMethod(object):

        path = config['path']
        payload_type = config.get('payload_type', None)
        payload_list = config.get('payload_list', False)
        allowed_param = config.get('allowed_param', [])
        method = config.get('method', 'GET')
        require_auth = config.get('require_auth', False)
        search_api = config.get('search_api', False)

        def __init__(self, api, args, kargs):
            # If authentication is required and no credentials
            # are provided, throw an error.
            if self.require_auth and not api.auth:
                raise WeibopError('Authentication required!')

            self.api = api
            self.post_data = kargs.pop('post_data', None)
            self.retry_count = kargs.pop('retry_count', api.retry_count)
            self.retry_delay = kargs.pop('retry_delay', api.retry_delay)
            self.retry_errors = kargs.pop('retry_errors', api.retry_errors)
            self.headers = kargs.pop('headers', {})
            self.build_parameters(args, kargs)
            # Pick correct URL root to use
            if self.search_api:
                self.api_root = api.search_root
            else:
                self.api_root = api.api_root

            # Perform any path variable substitution
            self.build_path()

            if api.secure:
                self.scheme = 'https://'
            else:
                self.scheme = 'http://'

            if self.search_api:
                self.host = api.search_host
            else:
                self.host = api.host

            # Manually set Host header to fix an issue in python 2.5
            # or older where Host is set including the 443 port.
            # This causes Twitter to issue 301 redirect.
            # See Issue http://github.com/joshthecoder/tweepy/issues/#issue/12
            self.headers['Host'] = self.host

        def build_parameters(self, args, kargs):
            self.parameters = {}
            for idx, arg in enumerate(args):
                try:
                    self.parameters[self.allowed_param[idx]] = convert_to_utf8_str(arg)
                except IndexError:
                    raise WeibopError('Too many parameters supplied!')

            for k, arg in kargs.items():
                if arg is None:
                    continue
                if k in self.parameters:
                    raise WeibopError('Multiple values for parameter %s supplied!' % k)

                self.parameters[k] = convert_to_utf8_str(arg)

        def build_path(self):
            for variable in re_path_template.findall(self.path):
                name = variable.strip('{}')

                if name == 'user' and self.api.auth:
                    value = self.api.auth.get_username()
                else:
                    try:
                        value = urllib.quote(self.parameters[name])
                    except KeyError:
                        raise WeibopError('No parameter value found for path variable: %s' % name)
                    del self.parameters[name]

                self.path = self.path.replace(variable, value)

        def execute(self):
            # Build the request URL
            url = self.api_root + self.path
            if self.api.source is not None:
                self.parameters.setdefault('source',self.api.source)

            if len(self.parameters):
                if self.method == 'GET':
                    url = '%s?%s' % (url, urllib.urlencode(self.parameters))
                else:
                    self.headers.setdefault("User-Agent","python")
                    if self.post_data is None:
                        self.headers.setdefault("Accept","text/html")                        
                        self.headers.setdefault("Content-Type","application/x-www-form-urlencoded")
                        self.post_data = urllib.urlencode(self.parameters)
            # Query the cache if one is available
            # and this request uses a GET method.
            if self.api.cache and self.method == 'GET':
                cache_result = self.api.cache.get(url)
                # if cache result found and not expired, return it
                if cache_result:
                    # must restore api reference
                    if isinstance(cache_result, list):
                        for result in cache_result:
                            result._api = self.api
                    else:
                        cache_result._api = self.api
                    return cache_result
                #urllib.urlencode(self.parameters)
            # Continue attempting request until successful
            # or maximum number of retries is reached.
            sTime = time.time()
            retries_performed = 0
            while retries_performed &lt; self.retry_count + 1:
                # Open connection
                # FIXME: add timeout
                if self.api.secure:
                    conn = httplib.HTTPSConnection(self.host)
                else:
                    conn = httplib.HTTPConnection(self.host)
                # Apply authentication
                if self.api.auth:
                    self.api.auth.apply_auth(
                            self.scheme + self.host + url,
                            self.method, self.headers, self.parameters
                    )
                # Execute request
                try:
                    conn.request(self.method, url, headers=self.headers, body=self.post_data)
                    resp = conn.getresponse()
                except Exception, e:
                    raise WeibopError('Failed to send request: %s' % e + "url=" + str(url) +",self.headers="+ str(self.headers))

                # Exit request loop if non-retry error code
                if self.retry_errors:
                    if resp.status not in self.retry_errors: break
                else:
                    if resp.status == 200: break

                # Sleep before retrying request again
                time.sleep(self.retry_delay)
                retries_performed += 1

            # If an error was returned, throw an exception
            body = resp.read()
            self.api.last_response = resp
            if self.api.log is not None:
                requestUrl = "URL:http://"+ self.host + url
                eTime = '%.0f' % ((time.time() - sTime) * 1000)
                postData = ""
                if self.post_data is not None:
                    postData = ",post:"+ self.post_data[0:500]
                self.api.log.debug(requestUrl +",time:"+ str(eTime)+ postData+",result:"+ body )
            if resp.status != 200:
                try:
                    json = self.api.parser.parse_error(self, body)
                    error_code =  json['error_code']
                    error =  json['error']
                    error_msg = 'error_code:' + error_code +','+ error
                except Exception:
                    error_msg = "Twitter error response: status code = %s" % resp.status
                raise WeibopError(error_msg)

            # Parse the response payload
            result = self.api.parser.parse(self, body)
            conn.close()

            # Store result into cache if one is available.
            if self.api.cache and self.method == 'GET' and result:
                self.api.cache.store(url, result)
            return result

    def _call(api, *args, **kargs):

        method = APIMethod(api, args, kargs)
        return method.execute()


    # Set pagination mode
    if 'cursor' in APIMethod.allowed_param:
        _call.pagination_mode = 'cursor'
    elif 'page' in APIMethod.allowed_param:
        _call.pagination_mode = 'page'

    return _call

</t>
<t tx="newlife.20110117110751.1611">@language python
@tabwidth -4
@others
@ignore</t>
<t tx="newlife.20110117110751.1612">
# Copyright 2009-2010 Joshua Roesslein
# See LICENSE for details.

import time
import threading
import os
import cPickle as pickle

try:
    import hashlib
except ImportError:
    # python 2.4
    import md5 as hashlib

try:
    import fcntl
except ImportError:
    # Probably on a windows system
    # TODO: use win32file
    pass


</t>
<t tx="newlife.20110117110751.1613">class Cache(object):
    """Cache interface"""
    @others
</t>
<t tx="newlife.20110117110751.1614">
def __init__(self, timeout=60):
    """Initialize the cache
        timeout: number of seconds to keep a cached entry
    """
    self.timeout = timeout

</t>
<t tx="newlife.20110117110751.1615">def store(self, key, value):
    """Add new record to cache
        key: entry key
        value: data of entry
    """
    raise NotImplementedError

</t>
<t tx="newlife.20110117110751.1616">def get(self, key, timeout=None):
    """Get cached entry if exists and not expired
        key: which entry to get
        timeout: override timeout with this value [optional]
    """
    raise NotImplementedError

</t>
<t tx="newlife.20110117110751.1617">def count(self):
    """Get count of entries currently stored in cache"""
    raise NotImplementedError

</t>
<t tx="newlife.20110117110751.1618">def cleanup(self):
    """Delete any expired entries in cache."""
    raise NotImplementedError

</t>
<t tx="newlife.20110117110751.1619">def flush(self):
    """Delete all cached entries"""
    raise NotImplementedError


</t>
<t tx="newlife.20110117110751.1620">class MemoryCache(Cache):
    """In-memory cache"""
    @others
</t>
<t tx="newlife.20110117110751.1621">
def __init__(self, timeout=60):
    Cache.__init__(self, timeout)
    self._entries = {}
    self.lock = threading.Lock()

</t>
<t tx="newlife.20110117110751.1622">def __getstate__(self):
    # pickle
    return {'entries': self._entries, 'timeout': self.timeout}

</t>
<t tx="newlife.20110117110751.1623">def __setstate__(self, state):
    # unpickle
    self.lock = threading.Lock()
    self._entries = state['entries']
    self.timeout = state['timeout']

</t>
<t tx="newlife.20110117110751.1624">def _is_expired(self, entry, timeout):
    return timeout &gt; 0 and (time.time() - entry[0]) &gt;= timeout

</t>
<t tx="newlife.20110117110751.1625">def store(self, key, value):
    self.lock.acquire()
    self._entries[key] = (time.time(), value)
    self.lock.release()

</t>
<t tx="newlife.20110117110751.1626">def get(self, key, timeout=None):
    self.lock.acquire()
    try:
        # check to see if we have this key
        entry = self._entries.get(key)
        if not entry:
            # no hit, return nothing
            return None

        # use provided timeout in arguments if provided
        # otherwise use the one provided during init.
        if timeout is None:
            timeout = self.timeout

        # make sure entry is not expired
        if self._is_expired(entry, timeout):
            # entry expired, delete and return nothing
            del self._entries[key]
            return None

        # entry found and not expired, return it
        return entry[1]
    finally:
        self.lock.release()

</t>
<t tx="newlife.20110117110751.1627">def count(self):
    return len(self._entries)

</t>
<t tx="newlife.20110117110751.1628">def cleanup(self):
    self.lock.acquire()
    try:
        for k, v in self._entries.items():
            if self._is_expired(v, self.timeout):
                del self._entries[k]
    finally:
        self.lock.release()

</t>
<t tx="newlife.20110117110751.1629">def flush(self):
    self.lock.acquire()
    self._entries.clear()
    self.lock.release()


</t>
<t tx="newlife.20110117110751.1630">class FileCache(Cache):
    """File-based cache"""

    # locks used to make cache thread-safe
    cache_locks = {}

    @others
</t>
<t tx="newlife.20110117110751.1631">def __init__(self, cache_dir, timeout=60):
    Cache.__init__(self, timeout)
    if os.path.exists(cache_dir) is False:
        os.mkdir(cache_dir)
    self.cache_dir = cache_dir
    if cache_dir in FileCache.cache_locks:
        self.lock = FileCache.cache_locks[cache_dir]
    else:
        self.lock = threading.Lock()
        FileCache.cache_locks[cache_dir] = self.lock

    if os.name == 'posix':
        self._lock_file = self._lock_file_posix
        self._unlock_file = self._unlock_file_posix
    elif os.name == 'nt':
        self._lock_file = self._lock_file_win32
        self._unlock_file = self._unlock_file_win32
    else:
        print 'Warning! FileCache locking not supported on this system!'
        self._lock_file = self._lock_file_dummy
        self._unlock_file = self._unlock_file_dummy

</t>
<t tx="newlife.20110117110751.1632">def _get_path(self, key):
    md5 = hashlib.md5()
    md5.update(key)
    return os.path.join(self.cache_dir, md5.hexdigest())

</t>
<t tx="newlife.20110117110751.1633">def _lock_file_dummy(self, path, exclusive=True):
    return None

</t>
<t tx="newlife.20110117110751.1634">def _unlock_file_dummy(self, lock):
    return

</t>
<t tx="newlife.20110117110751.1635">def _lock_file_posix(self, path, exclusive=True):
    lock_path = path + '.lock'
    if exclusive is True:
        f_lock = open(lock_path, 'w')
        fcntl.lockf(f_lock, fcntl.LOCK_EX)
    else:
        f_lock = open(lock_path, 'r')
        fcntl.lockf(f_lock, fcntl.LOCK_SH)
    if os.path.exists(lock_path) is False:
        f_lock.close()
        return None
    return f_lock

</t>
<t tx="newlife.20110117110751.1636">def _unlock_file_posix(self, lock):
    lock.close()

</t>
<t tx="newlife.20110117110751.1637">def _lock_file_win32(self, path, exclusive=True):
    # TODO: implement
    return None

</t>
<t tx="newlife.20110117110751.1638">def _unlock_file_win32(self, lock):
    # TODO: implement
    return

</t>
<t tx="newlife.20110117110751.1639">def _delete_file(self, path):
    os.remove(path)
    if os.path.exists(path + '.lock'):
        os.remove(path + '.lock')

</t>
<t tx="newlife.20110117110751.1640">def store(self, key, value):
    path = self._get_path(key)
    self.lock.acquire()
    try:
        # acquire lock and open file
        f_lock = self._lock_file(path)
        datafile = open(path, 'wb')

        # write data
        pickle.dump((time.time(), value), datafile)

        # close and unlock file
        datafile.close()
        self._unlock_file(f_lock)
    finally:
        self.lock.release()

</t>
<t tx="newlife.20110117110751.1641">def get(self, key, timeout=None):
    return self._get(self._get_path(key), timeout)

</t>
<t tx="newlife.20110117110751.1642">def _get(self, path, timeout):
    if os.path.exists(path) is False:
        # no record
        return None
    self.lock.acquire()
    try:
        # acquire lock and open
        f_lock = self._lock_file(path, False)
        datafile = open(path, 'rb')

        # read pickled object
        created_time, value = pickle.load(datafile)
        datafile.close()

        # check if value is expired
        if timeout is None:
            timeout = self.timeout
        if timeout &gt; 0 and (time.time() - created_time) &gt;= timeout:
            # expired! delete from cache
            value = None
            self._delete_file(path)

        # unlock and return result
        self._unlock_file(f_lock)
        return value
    finally:
        self.lock.release()

</t>
<t tx="newlife.20110117110751.1643">def count(self):
    c = 0
    for entry in os.listdir(self.cache_dir):
        if entry.endswith('.lock'):
            continue
        c += 1
    return c

</t>
<t tx="newlife.20110117110751.1644">def cleanup(self):
    for entry in os.listdir(self.cache_dir):
        if entry.endswith('.lock'):
            continue
        self._get(os.path.join(self.cache_dir, entry), None)

</t>
<t tx="newlife.20110117110751.1645">def flush(self):
    for entry in os.listdir(self.cache_dir):
        if entry.endswith('.lock'):
            continue
        self._delete_file(os.path.join(self.cache_dir, entry))

</t>
<t tx="newlife.20110117110751.1646">@language python
@tabwidth -4
@others
@ignore</t>
<t tx="newlife.20110117110751.1647">
# Copyright 2009-2010 Joshua Roesslein
# See LICENSE for details.

from weibopy.error import WeibopError

</t>
<t tx="newlife.20110117110751.1648">class Cursor(object):
    """Pagination helper class"""
    @others
</t>
<t tx="newlife.20110117110751.1649">
def __init__(self, method, *args, **kargs):
    if hasattr(method, 'pagination_mode'):
        if method.pagination_mode == 'cursor':
            self.iterator = CursorIterator(method, args, kargs)
        else:
            self.iterator = PageIterator(method, args, kargs)
    else:
        raise WeibopError('This method does not perform pagination')

</t>
<t tx="newlife.20110117110751.1650">def pages(self, limit=0):
    """Return iterator for pages"""
    if limit &gt; 0:
        self.iterator.limit = limit
    return self.iterator

</t>
<t tx="newlife.20110117110751.1651">def items(self, limit=0):
    """Return iterator for items in each page"""
    i = ItemIterator(self.iterator)
    i.limit = limit
    return i

</t>
<t tx="newlife.20110117110751.1652">class BaseIterator(object):
    @others
</t>
<t tx="newlife.20110117110751.1653">
def __init__(self, method, args, kargs):
    self.method = method
    self.args = args
    self.kargs = kargs
    self.limit = 0

</t>
<t tx="newlife.20110117110751.1654">def next(self):
    raise NotImplementedError

</t>
<t tx="newlife.20110117110751.1655">def prev(self):
    raise NotImplementedError

</t>
<t tx="newlife.20110117110751.1656">def __iter__(self):
    return self

</t>
<t tx="newlife.20110117110751.1657">class CursorIterator(BaseIterator):
    @others
</t>
<t tx="newlife.20110117110751.1658">
def __init__(self, method, args, kargs):
    BaseIterator.__init__(self, method, args, kargs)
    self.next_cursor = -1
    self.prev_cursor = 0
    self.count = 0

</t>
<t tx="newlife.20110117110751.1659">def next(self):
    if self.next_cursor == 0 or (self.limit and self.count == self.limit):
        raise StopIteration
    data, cursors = self.method(
            cursor=self.next_cursor, *self.args, **self.kargs
    )
    self.prev_cursor, self.next_cursor = cursors
    if len(data) == 0:
        raise StopIteration
    self.count += 1
    return data

</t>
<t tx="newlife.20110117110751.1660">def prev(self):
    if self.prev_cursor == 0:
        raise WeibopError('Can not page back more, at first page')
    data, self.next_cursor, self.prev_cursor = self.method(
            cursor=self.prev_cursor, *self.args, **self.kargs
    )
    self.count -= 1
    return data

</t>
<t tx="newlife.20110117110751.1661">class PageIterator(BaseIterator):
    @others
</t>
<t tx="newlife.20110117110751.1662">
def __init__(self, method, args, kargs):
    BaseIterator.__init__(self, method, args, kargs)
    self.current_page = 0

</t>
<t tx="newlife.20110117110751.1663">def next(self):
    self.current_page += 1
    items = self.method(page=self.current_page, *self.args, **self.kargs)
    if len(items) == 0 or (self.limit &gt; 0 and self.current_page &gt; self.limit):
        raise StopIteration
    return items

</t>
<t tx="newlife.20110117110751.1664">def prev(self):
    if (self.current_page == 1):
        raise WeibopError('Can not page back more, at first page')
    self.current_page -= 1
    return self.method(page=self.current_page, *self.args, **self.kargs)

</t>
<t tx="newlife.20110117110751.1665">class ItemIterator(BaseIterator):
    @others
</t>
<t tx="newlife.20110117110751.1666">
def __init__(self, page_iterator):
    self.page_iterator = page_iterator
    self.limit = 0
    self.current_page = None
    self.page_index = -1
    self.count = 0

</t>
<t tx="newlife.20110117110751.1667">def next(self):
    if self.limit &gt; 0 and self.count == self.limit:
        raise StopIteration
    if self.current_page is None or self.page_index == len(self.current_page) - 1:
        # Reached end of current page, get the next page...
        self.current_page = self.page_iterator.next()
        self.page_index = -1
    self.page_index += 1
    self.count += 1
    return self.current_page[self.page_index]

</t>
<t tx="newlife.20110117110751.1668">def prev(self):
    if self.current_page is None:
        raise WeibopError('Can not go back more, at first page')
    if self.page_index == 0:
        # At the beginning of the current page, move to next...
        self.current_page = self.page_iterator.prev()
        self.page_index = len(self.current_page)
        if self.page_index == 0:
            raise WeibopError('No more items')
    self.page_index -= 1
    self.count -= 1
    return self.current_page[self.page_index]

</t>
<t tx="newlife.20110117110751.1669">@language python
@tabwidth -4
@others
@ignore</t>
<t tx="newlife.20110117110751.1670">
# Copyright 2009-2010 Joshua Roesslein
# See LICENSE for details.

class WeibopError(Exception):
    """Weibopy exception"""
    @others
</t>
<t tx="newlife.20110117110751.1671">
def __init__(self, reason):
    self.reason = reason.encode('utf-8')
    print self.reason

</t>
<t tx="newlife.20110117110751.1672">def __str__(self):
    return self.reason

</t>
<t tx="newlife.20110117110751.1673">@language python
@tabwidth -4
@others
@ignore</t>
<t tx="newlife.20110117110751.1674">
# Copyright 2009-2010 Joshua Roesslein
# See LICENSE for details.

"""
weibo API library
"""
__version__ = '1.5'
__author__ = 'Joshua Roesslein'
__license__ = 'MIT'

from weibopy.models import Status, User, DirectMessage, Friendship, SavedSearch, SearchResult, ModelFactory, IDSModel
from weibopy.error import WeibopError
from weibopy.api import API
from weibopy.cache import Cache, MemoryCache, FileCache
from weibopy.auth import BasicAuthHandler, OAuthHandler
from weibopy.streaming import Stream, StreamListener
from weibopy.cursor import Cursor

# Global, unauthenticated instance of API
api = API()

</t>
<t tx="newlife.20110117110751.1675">def debug(enable=True, level=1):

    import httplib
    httplib.HTTPConnection.debuglevel = level

</t>
<t tx="newlife.20110117110751.1676">@language python
@tabwidth -4
@others
@ignore</t>
<t tx="newlife.20110117110751.1677">
# Copyright 2009-2010 Joshua Roesslein
# See LICENSE for details.

from weibopy.utils import parse_datetime, parse_html_value, parse_a_href, \
        parse_search_datetime, unescape_html

</t>
<t tx="newlife.20110117110751.1678">class ResultSet(list):
    """A list like object that holds results from a Twitter API query."""


</t>
<t tx="newlife.20110117110751.1679">class Model(object):
    @others
</t>
<t tx="newlife.20110117110751.1680">
def __init__(self, api=None):
    self._api = api

</t>
<t tx="newlife.20110117110751.1681">def __getstate__(self):
    # pickle
    pickle = dict(self.__dict__)
    del pickle['_api']  # do not pickle the API reference
    return pickle

</t>
<t tx="newlife.20110117110751.1682">@classmethod
def parse(cls, api, json):
    """Parse a JSON object into a model instance."""
    raise NotImplementedError

</t>
<t tx="newlife.20110117110751.1683">@classmethod
def parse_list(cls, api, json_list):
    """Parse a list of JSON objects into a result set of model instances."""
    results = ResultSet()
    for obj in json_list:
        results.append(cls.parse(api, obj))
    return results


</t>
<t tx="newlife.20110117110751.1684">class Status(Model):
    @others
</t>
<t tx="newlife.20110117110751.1685">
@classmethod
def parse(cls, api, json):
    status = cls(api)
    for k, v in json.items():
        if k == 'user':
            user = User.parse(api, v)
            setattr(status, 'author', user)
            setattr(status, 'user', user)  # DEPRECIATED
        elif k == 'screen_name':
            setattr(status, k, v)
        elif k == 'created_at':
            setattr(status, k, parse_datetime(v))
        elif k == 'source':
            if '&lt;' in v:
                setattr(status, k, parse_html_value(v))
                setattr(status, 'source_url', parse_a_href(v))
            else:
                setattr(status, k, v)
        elif k == 'retweeted_status':
            setattr(status, k, User.parse(api, v))
        elif k == 'geo':
            setattr(status, k, Geo.parse(api, v))
        else:
            setattr(status, k, v)
    return status

</t>
<t tx="newlife.20110117110751.1686">def destroy(self):
    return self._api.destroy_status(self.id)

</t>
<t tx="newlife.20110117110751.1687">def retweet(self):
    return self._api.retweet(self.id)

</t>
<t tx="newlife.20110117110751.1688">def retweets(self):
    return self._api.retweets(self.id)

</t>
<t tx="newlife.20110117110751.1689">def favorite(self):
    return self._api.create_favorite(self.id)
</t>
<t tx="newlife.20110117110751.1690">class Geo(Model):
    @others
</t>
<t tx="newlife.20110117110751.1691">
@classmethod
def parse(cls, api, json):
    geo = cls(api)
    if json is not None:
        for k, v in json.items():
            setattr(geo, k, v)
    return geo

</t>
<t tx="newlife.20110117110751.1692">class Comments(Model):
    @others
</t>
<t tx="newlife.20110117110751.1693">
@classmethod
def parse(cls, api, json):
    comments = cls(api)
    for k, v in json.items():
        if k == 'user':
            user = User.parse(api, v)
            setattr(comments, 'author', user)
            setattr(comments, 'user', user)
        elif k == 'status':
            status = Status.parse(api, v)
            setattr(comments, 'user', status)
        elif k == 'created_at':
            setattr(comments, k, parse_datetime(v))
        elif k == 'reply_comment':
            setattr(comments, k, User.parse(api, v))
        else:
            setattr(comments, k, v)
    return comments

</t>
<t tx="newlife.20110117110751.1694">def destroy(self):
    return self._api.destroy_status(self.id)

</t>
<t tx="newlife.20110117110751.1695">def retweet(self):
    return self._api.retweet(self.id)

</t>
<t tx="newlife.20110117110751.1696">def retweets(self):
    return self._api.retweets(self.id)

</t>
<t tx="newlife.20110117110751.1697">def favorite(self):
    return self._api.create_favorite(self.id)

</t>
<t tx="newlife.20110117110751.1698">class User(Model):
    @others
</t>
<t tx="newlife.20110117110751.1699">
@classmethod
def parse(cls, api, json):
    user = cls(api)
    for k, v in json.items():
        if k == 'created_at':
            setattr(user, k, parse_datetime(v))
        elif k == 'status':
            setattr(user, k, Status.parse(api, v))
        elif k == 'screen_name':
            setattr(user, k, v)
        elif k == 'following':
            # twitter sets this to null if it is false
            if v is True:
                setattr(user, k, True)
            else:
                setattr(user, k, False)
        else:
            setattr(user, k, v)
    return user

</t>
<t tx="newlife.20110117110751.1700">@classmethod
def parse_list(cls, api, json_list):
    if isinstance(json_list, list):
        item_list = json_list
    else:
        item_list = json_list['users']

    results = ResultSet()
    for obj in item_list:
        results.append(cls.parse(api, obj))
    return results

</t>
<t tx="newlife.20110117110751.1701">def timeline(self, **kargs):
    return self._api.user_timeline(user_id=self.id, **kargs)

</t>
<t tx="newlife.20110117110751.1702">def friends(self, **kargs):
    return self._api.friends(user_id=self.id, **kargs)

</t>
<t tx="newlife.20110117110751.1703">def followers(self, **kargs):
    return self._api.followers(user_id=self.id, **kargs)

</t>
<t tx="newlife.20110117110751.1704">def follow(self):
    self._api.create_friendship(user_id=self.id)
    self.following = True

</t>
<t tx="newlife.20110117110751.1705">def unfollow(self):
    self._api.destroy_friendship(user_id=self.id)
    self.following = False

</t>
<t tx="newlife.20110117110751.1706">def lists_memberships(self, *args, **kargs):
    return self._api.lists_memberships(user=self.screen_name, *args, **kargs)

</t>
<t tx="newlife.20110117110751.1707">def lists_subscriptions(self, *args, **kargs):
    return self._api.lists_subscriptions(user=self.screen_name, *args, **kargs)

</t>
<t tx="newlife.20110117110751.1708">def lists(self, *args, **kargs):
    return self._api.lists(user=self.screen_name, *args, **kargs)

</t>
<t tx="newlife.20110117110751.1709">def followers_ids(self, *args, **kargs):
    return self._api.followers_ids(user_id=self.id, *args, **kargs)




</t>
<t tx="newlife.20110117110751.1710">class DirectMessage(Model):
    @others
</t>
<t tx="newlife.20110117110751.1711">@classmethod
def parse(cls, api, json):
    dm = cls(api)
    for k, v in json.items():
        if k == 'sender' or k == 'recipient':
            setattr(dm, k, User.parse(api, v))
        elif k == 'created_at':
            setattr(dm, k, parse_datetime(v))
        else:
            setattr(dm, k, v)
    return dm

</t>
<t tx="newlife.20110117110751.1712">class Friendship(Model):
    @others
</t>
<t tx="newlife.20110117110751.1713">
@classmethod
def parse(cls, api, json):

    source = cls(api)
    for k, v in json['source'].items():
        setattr(source, k, v)

    # parse target
    target = cls(api)
    for k, v in json['target'].items():
        setattr(target, k, v)

    return source, target


</t>
<t tx="newlife.20110117110751.1714">class SavedSearch(Model):
    @others
</t>
<t tx="newlife.20110117110751.1715">
@classmethod
def parse(cls, api, json):
    ss = cls(api)
    for k, v in json.items():
        if k == 'created_at':
            setattr(ss, k, parse_datetime(v))
        else:
            setattr(ss, k, v)
    return ss

</t>
<t tx="newlife.20110117110751.1716">def destroy(self):
    return self._api.destroy_saved_search(self.id)


</t>
<t tx="newlife.20110117110751.1717">class SearchResult(Model):
    @others
</t>
<t tx="newlife.20110117110751.1718">
@classmethod
def parse(cls, api, json):
    result = cls()
    for k, v in json.items():
        if k == 'created_at':
            setattr(result, k, parse_search_datetime(v))
        elif k == 'source':
            setattr(result, k, parse_html_value(unescape_html(v)))
        else:
            setattr(result, k, v)
    return result

</t>
<t tx="newlife.20110117110751.1719">@classmethod
def parse_list(cls, api, json_list, result_set=None):
    results = ResultSet()
    results.max_id = json_list.get('max_id')
    results.since_id = json_list.get('since_id')
    results.refresh_url = json_list.get('refresh_url')
    results.next_page = json_list.get('next_page')
    results.results_per_page = json_list.get('results_per_page')
    results.page = json_list.get('page')
    results.completed_in = json_list.get('completed_in')
    results.query = json_list.get('query')

    for obj in json_list['results']:
        results.append(cls.parse(api, obj))
    return results

</t>
<t tx="newlife.20110117110751.1720">class List(Model):
    @others
</t>
<t tx="newlife.20110117110751.1721">
@classmethod
def parse(cls, api, json):
    lst = List(api)
    for k,v in json.items():
        if k == 'user':
            setattr(lst, k, User.parse(api, v))
        else:
            setattr(lst, k, v)
    return lst

</t>
<t tx="newlife.20110117110751.1722">@classmethod
def parse_list(cls, api, json_list, result_set=None):
    results = ResultSet()
    for obj in json_list['lists']:
        results.append(cls.parse(api, obj))
    return results

</t>
<t tx="newlife.20110117110751.1723">def update(self, **kargs):
    return self._api.update_list(self.slug, **kargs)

</t>
<t tx="newlife.20110117110751.1724">def destroy(self):
    return self._api.destroy_list(self.slug)

</t>
<t tx="newlife.20110117110751.1725">def timeline(self, **kargs):
    return self._api.list_timeline(self.user.screen_name, self.slug, **kargs)

</t>
<t tx="newlife.20110117110751.1726">def add_member(self, id):
    return self._api.add_list_member(self.slug, id)

</t>
<t tx="newlife.20110117110751.1727">def remove_member(self, id):
    return self._api.remove_list_member(self.slug, id)

</t>
<t tx="newlife.20110117110751.1728">def members(self, **kargs):
    return self._api.list_members(self.user.screen_name, self.slug, **kargs)

</t>
<t tx="newlife.20110117110751.1729">def is_member(self, id):
    return self._api.is_list_member(self.user.screen_name, self.slug, id)

</t>
<t tx="newlife.20110117110751.1730">def subscribe(self):
    return self._api.subscribe_list(self.user.screen_name, self.slug)

</t>
<t tx="newlife.20110117110751.1731">def unsubscribe(self):
    return self._api.unsubscribe_list(self.user.screen_name, self.slug)

</t>
<t tx="newlife.20110117110751.1732">def subscribers(self, **kargs):
    return self._api.list_subscribers(self.user.screen_name, self.slug, **kargs)

</t>
<t tx="newlife.20110117110751.1733">def is_subscribed(self, id):
    return self._api.is_subscribed_list(self.user.screen_name, self.slug, id)

</t>
<t tx="newlife.20110117110751.1734">class JSONModel(Model):
    @others
</t>
<t tx="newlife.20110117110751.1735">
@classmethod
def parse(cls, api, json):
    lst = JSONModel(api)
    for k,v in json.items():
        setattr(lst, k, v)
    return lst

</t>
<t tx="newlife.20110117110751.1736">class IDSModel(Model):
    @others
</t>
<t tx="newlife.20110117110751.1737">@classmethod
def parse(cls, api, json):
    ids = IDSModel(api)
    for k, v in json.items():            
        setattr(ids, k, v)
    return ids

</t>
<t tx="newlife.20110117110751.1738">class Counts(Model):
    @others
</t>
<t tx="newlife.20110117110751.1739">@classmethod
def parse(cls, api, json):
    ids = Counts(api)
    for k, v in json.items():            
        setattr(ids, k, v)
    return ids

</t>
<t tx="newlife.20110117110751.1740">class ModelFactory(object):
    """
    Used by parsers for creating instances
    of models. You may subclass this factory
    to add your own extended models.
    """

    status = Status
    comments = Comments
    user = User
    direct_message = DirectMessage
    friendship = Friendship
    saved_search = SavedSearch
    search_result = SearchResult
    list = List
    json = JSONModel
    ids_list = IDSModel
    counts = Counts
</t>
<t tx="newlife.20110117110751.1741">@language python
@tabwidth -4
@others
@ignore</t>
<t tx="newlife.20110117110751.1742">"""
The MIT License

Copyright (c) 2007 Leah Culver

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
"""

import cgi
import urllib
import time
import random
import urlparse
import hmac
import binascii


VERSION = '1.0' # Hi Blaine!
HTTP_METHOD = 'GET'
SIGNATURE_METHOD = 'PLAINTEXT'


</t>
<t tx="newlife.20110117110751.1743">class OAuthError(RuntimeError):
    """Generic exception class."""
    @others
</t>
<t tx="newlife.20110117110751.1744">def __init__(self, message='OAuth error occured.'):
    self.message = message

</t>
<t tx="newlife.20110117110751.1745">def build_authenticate_header(realm=''):
    """Optional WWW-Authenticate header (401 error)"""
    return {'WWW-Authenticate': 'OAuth realm="%s"' % realm}

</t>
<t tx="newlife.20110117110751.1746">def escape(s):
    """Escape a URL including any /."""
    return urllib.quote(s, safe='~')

</t>
<t tx="newlife.20110117110751.1747">def _utf8_str(s):
    """Convert unicode to utf-8."""
    if isinstance(s, unicode):
        return s.encode("utf-8")
    else:
        return str(s)

</t>
<t tx="newlife.20110117110751.1748">def generate_timestamp():
    """Get seconds since epoch (UTC)."""
    return int(time.time())

</t>
<t tx="newlife.20110117110751.1749">def generate_nonce(length=8):
    """Generate pseudorandom number."""
    return ''.join([str(random.randint(0, 9)) for i in range(length)])

</t>
<t tx="newlife.20110117110751.1750">def generate_verifier(length=8):
    """Generate pseudorandom number."""
    return ''.join([str(random.randint(0, 9)) for i in range(length)])


</t>
<t tx="newlife.20110117110751.1751">class OAuthConsumer(object):
    """Consumer of OAuth authentication.

    OAuthConsumer is a data type that represents the identity of the Consumer
    via its shared secret with the Service Provider.

    """
    key = None
    secret = None

    @others
</t>
<t tx="newlife.20110117110751.1752">def __init__(self, key, secret):
    self.key = key
    self.secret = secret


</t>
<t tx="newlife.20110117110751.1753">class OAuthToken(object):
    """OAuthToken is a data type that represents an End User via either an access
    or request token.

    key -- the token
    secret -- the token secret

    """
    key = None
    secret = None
    callback = None
    callback_confirmed = None
    verifier = None

    @others
</t>
<t tx="newlife.20110117110751.1754">def __init__(self, key, secret):
    self.key = key
    self.secret = secret

</t>
<t tx="newlife.20110117110751.1755">def set_callback(self, callback):
    self.callback = callback
    self.callback_confirmed = 'true'

</t>
<t tx="newlife.20110117110751.1756">def set_verifier(self, verifier=None):
    if verifier is not None:
        self.verifier = verifier
    else:
        self.verifier = generate_verifier()

</t>
<t tx="newlife.20110117110751.1757">def get_callback_url(self):
    if self.callback and self.verifier:
        # Append the oauth_verifier.
        parts = urlparse.urlparse(self.callback)
        scheme, netloc, path, params, query, fragment = parts[:6]
        if query:
            query = '%s&amp;oauth_verifier=%s' % (query, self.verifier)
        else:
            query = 'oauth_verifier=%s' % self.verifier
        return urlparse.urlunparse((scheme, netloc, path, params,
            query, fragment))
    return self.callback

</t>
<t tx="newlife.20110117110751.1758">def to_string(self):
    data = {
        'oauth_token': self.key,
        'oauth_token_secret': self.secret,
    }
    if self.callback_confirmed is not None:
        data['oauth_callback_confirmed'] = self.callback_confirmed
    return urllib.urlencode(data)

</t>
<t tx="newlife.20110117110751.1759">def from_string(s):
    """ Returns a token from something like:
    oauth_token_secret=xxx&amp;oauth_token=xxx
    """
    params = cgi.parse_qs(s, keep_blank_values=False)
    key = params['oauth_token'][0]
    secret = params['oauth_token_secret'][0]
    token = OAuthToken(key, secret)
    try:
        token.callback_confirmed = params['oauth_callback_confirmed'][0]
    except KeyError:
        pass # 1.0, no callback confirmed.
    return token
</t>
<t tx="newlife.20110117110751.1760">from_string = staticmethod(from_string)

def __str__(self):
    return self.to_string()


</t>
<t tx="newlife.20110117110751.1761">class OAuthRequest(object):
    """OAuthRequest represents the request and can be serialized.

    OAuth parameters:
        - oauth_consumer_key 
        - oauth_token
        - oauth_signature_method
        - oauth_signature 
        - oauth_timestamp 
        - oauth_nonce
        - oauth_version
        - oauth_verifier
        ... any additional parameters, as defined by the Service Provider.
    """
    parameters = None # OAuth parameters.
    http_method = HTTP_METHOD
    http_url = None
    version = VERSION

    @others
    _split_url_string = staticmethod(_split_url_string)

</t>
<t tx="newlife.20110117110751.1762">def __init__(self, http_method=HTTP_METHOD, http_url=None, parameters=None):
    self.http_method = http_method
    self.http_url = http_url
    self.parameters = parameters or {}
</t>
<t tx="newlife.20110117110751.1763">def set_parameter(self, parameter, value):
    self.parameters[parameter] = value

</t>
<t tx="newlife.20110117110751.1764">def get_parameter(self, parameter):
    try:
        return self.parameters[parameter]
    except:
        raise OAuthError('Parameter not found: %s' % parameter)

</t>
<t tx="newlife.20110117110751.1765">def _get_timestamp_nonce(self):
    return self.get_parameter('oauth_timestamp'), self.get_parameter(
        'oauth_nonce')

</t>
<t tx="newlife.20110117110751.1766">def get_nonoauth_parameters(self):
    """Get any non-OAuth parameters."""
    parameters = {}
    for k, v in self.parameters.iteritems():
        # Ignore oauth parameters.
        if k.find('oauth_') &lt; 0:
            parameters[k] = v
    return parameters

</t>
<t tx="newlife.20110117110751.1767">def to_header(self, realm=''):
    """Serialize as a header for an HTTPAuth request."""
    auth_header = 'OAuth realm="%s"' % realm
    # Add the oauth parameters.
    if self.parameters:
        for k, v in self.parameters.iteritems():
            if k[:6] == 'oauth_':
                auth_header += ', %s="%s"' % (k, escape(str(v)))
    return {'Authorization': auth_header}

</t>
<t tx="newlife.20110117110751.1768">def to_postdata(self):
    """Serialize as post data for a POST request."""
    return '&amp;'.join(['%s=%s' % (escape(str(k)), escape(str(v))) \
        for k, v in self.parameters.iteritems()])

</t>
<t tx="newlife.20110117110751.1769">def to_url(self):
    """Serialize as a URL for a GET request."""
    return '%s?%s' % (self.get_normalized_http_url(), self.to_postdata())

</t>
<t tx="newlife.20110117110751.1770">def get_normalized_parameters(self):
    """Return a string that contains the parameters that must be signed."""
    params = self.parameters
    try:
        # Exclude the signature if it exists.
        del params['oauth_signature']
    except:
        pass
    # Escape key values before sorting.
    key_values = [(escape(_utf8_str(k)), escape(_utf8_str(v))) \
        for k,v in params.items()]
    # Sort lexicographically, first after key, then after value.
    key_values.sort()
    # Combine key value pairs into a string.
    return '&amp;'.join(['%s=%s' % (k, v) for k, v in key_values])

</t>
<t tx="newlife.20110117110751.1771">def get_normalized_http_method(self):
    """Uppercases the http method."""
    return self.http_method.upper()

</t>
<t tx="newlife.20110117110751.1772">def get_normalized_http_url(self):
    """Parses the URL and rebuilds it to be scheme://host/path."""
    parts = urlparse.urlparse(self.http_url)
    scheme, netloc, path = parts[:3]
    # Exclude default port numbers.
    if scheme == 'http' and netloc[-3:] == ':80':
        netloc = netloc[:-3]
    elif scheme == 'https' and netloc[-4:] == ':443':
        netloc = netloc[:-4]
    return '%s://%s%s' % (scheme, netloc, path)

</t>
<t tx="newlife.20110117110751.1773">def sign_request(self, signature_method, consumer, token):
    """Set the signature parameter to the result of build_signature."""
    # Set the signature method.
    self.set_parameter('oauth_signature_method',
        signature_method.get_name())
    # Set the signature.
    self.set_parameter('oauth_signature',self.build_signature(signature_method, consumer, token))

</t>
<t tx="newlife.20110117110751.1774">def build_signature(self, signature_method, consumer, token):
    """Calls the build signature method within the signature method."""
    return signature_method.build_signature(self, consumer, token)

</t>
<t tx="newlife.20110117110751.1775">def from_request(http_method, http_url, headers=None, parameters=None,
        query_string=None):
    """Combines multiple parameter sources."""
    if parameters is None:
        parameters = {}

    # Headers
    if headers and 'Authorization' in headers:
        auth_header = headers['Authorization']
        # Check that the authorization header is OAuth.
        if auth_header[:6] == 'OAuth ':
            auth_header = auth_header[6:]
            try:
                # Get the parameters from the header.
                header_params = OAuthRequest._split_header(auth_header)
                parameters.update(header_params)
            except:
                raise OAuthError('Unable to parse OAuth parameters from '
                    'Authorization header.')

    # GET or POST query string.
    if query_string:
        query_params = OAuthRequest._split_url_string(query_string)
        parameters.update(query_params)

    # URL parameters.
    param_str = urlparse.urlparse(http_url)[4] # query
    url_params = OAuthRequest._split_url_string(param_str)
    parameters.update(url_params)

    if parameters:
        return OAuthRequest(http_method, http_url, parameters)

    return None
</t>
<t tx="newlife.20110117110751.1776">from_request = staticmethod(from_request)

def from_consumer_and_token(oauth_consumer, token=None,
        callback=None, verifier=None, http_method=HTTP_METHOD,
        http_url=None, parameters=None):
    if not parameters:
        parameters = {}

    defaults = {
        'oauth_consumer_key': oauth_consumer.key,
        'oauth_timestamp': generate_timestamp(),
        'oauth_nonce': generate_nonce(),
        'oauth_version': OAuthRequest.version,
    }

    defaults.update(parameters)
    parameters = defaults

    if token:
        parameters['oauth_token'] = token.key
        if token.callback:
            parameters['oauth_callback'] = token.callback
        # 1.0a support for verifier.
        if verifier:
            parameters['oauth_verifier'] = verifier
    elif callback:
        # 1.0a support for callback in the request token request.
        parameters['oauth_callback'] = callback

    return OAuthRequest(http_method, http_url, parameters)
</t>
<t tx="newlife.20110117110751.1777">from_consumer_and_token = staticmethod(from_consumer_and_token)

def from_token_and_callback(token, callback=None, http_method=HTTP_METHOD,
        http_url=None, parameters=None):
    if not parameters:
        parameters = {}

    parameters['oauth_token'] = token.key

    if callback:
        parameters['oauth_callback'] = callback

    return OAuthRequest(http_method, http_url, parameters)
</t>
<t tx="newlife.20110117110751.1778">from_token_and_callback = staticmethod(from_token_and_callback)

def _split_header(header):
    """Turn Authorization: header into parameters."""
    params = {}
    parts = header.split(',')
    for param in parts:
        # Ignore realm parameter.
        if param.find('realm') &gt; -1:
            continue
        # Remove whitespace.
        param = param.strip()
        # Split key-value.
        param_parts = param.split('=', 1)
        # Remove quotes and unescape the value.
        params[param_parts[0]] = urllib.unquote(param_parts[1].strip('\"'))
    return params
</t>
<t tx="newlife.20110117110751.1779">_split_header = staticmethod(_split_header)

def _split_url_string(param_str):
    """Turn URL string into parameters."""
    parameters = cgi.parse_qs(param_str, keep_blank_values=False)
    for k, v in parameters.iteritems():
        parameters[k] = urllib.unquote(v[0])
    return parameters
</t>
<t tx="newlife.20110117110751.1780">class OAuthServer(object):
    """A worker to check the validity of a request against a data store."""
    timestamp_threshold = 300 # In seconds, five minutes.
    version = VERSION
    signature_methods = None
    data_store = None

    @others
</t>
<t tx="newlife.20110117110751.1781">def __init__(self, data_store=None, signature_methods=None):
    self.data_store = data_store
    self.signature_methods = signature_methods or {}

</t>
<t tx="newlife.20110117110751.1782">def set_data_store(self, data_store):
    self.data_store = data_store

</t>
<t tx="newlife.20110117110751.1783">def get_data_store(self):
    return self.data_store

</t>
<t tx="newlife.20110117110751.1784">def add_signature_method(self, signature_method):
    self.signature_methods[signature_method.get_name()] = signature_method
    return self.signature_methods

</t>
<t tx="newlife.20110117110751.1785">def fetch_request_token(self, oauth_request):
    """Processes a request_token request and returns the
    request token on success.
    """
    try:
        # Get the request token for authorization.
        token = self._get_token(oauth_request, 'request')
    except OAuthError:
        # No token required for the initial token request.
        version = self._get_version(oauth_request)
        consumer = self._get_consumer(oauth_request)
        try:
            callback = self.get_callback(oauth_request)
        except OAuthError:
            callback = None # 1.0, no callback specified.
        self._check_signature(oauth_request, consumer, None)
        # Fetch a new token.
        token = self.data_store.fetch_request_token(consumer, callback)
    return token

</t>
<t tx="newlife.20110117110751.1786">def fetch_access_token(self, oauth_request):
    """Processes an access_token request and returns the
    access token on success.
    """
    version = self._get_version(oauth_request)
    consumer = self._get_consumer(oauth_request)
    try:
        verifier = self._get_verifier(oauth_request)
    except OAuthError:
        verifier = None
    # Get the request token.
    token = self._get_token(oauth_request, 'request')
    self._check_signature(oauth_request, consumer, token)
    new_token = self.data_store.fetch_access_token(consumer, token, verifier)
    return new_token

</t>
<t tx="newlife.20110117110751.1787">def verify_request(self, oauth_request):
    """Verifies an api call and checks all the parameters."""
    # -&gt; consumer and token
    version = self._get_version(oauth_request)
    consumer = self._get_consumer(oauth_request)
    # Get the access token.
    token = self._get_token(oauth_request, 'access')
    self._check_signature(oauth_request, consumer, token)
    parameters = oauth_request.get_nonoauth_parameters()
    return consumer, token, parameters

</t>
<t tx="newlife.20110117110751.1788">def authorize_token(self, token, user):
    """Authorize a request token."""
    return self.data_store.authorize_request_token(token, user)

</t>
<t tx="newlife.20110117110751.1789">def get_callback(self, oauth_request):
    """Get the callback URL."""
    return oauth_request.get_parameter('oauth_callback')

</t>
<t tx="newlife.20110117110751.1790">def build_authenticate_header(self, realm=''):
    """Optional support for the authenticate header."""
    return {'WWW-Authenticate': 'OAuth realm="%s"' % realm}

</t>
<t tx="newlife.20110117110751.1791">def _get_version(self, oauth_request):
    """Verify the correct version request for this server."""
    try:
        version = oauth_request.get_parameter('oauth_version')
    except:
        version = VERSION
    if version and version != self.version:
        raise OAuthError('OAuth version %s not supported.' % str(version))
    return version

</t>
<t tx="newlife.20110117110751.1792">def _get_signature_method(self, oauth_request):
    """Figure out the signature with some defaults."""
    try:
        signature_method = oauth_request.get_parameter(
            'oauth_signature_method')
    except:
        signature_method = SIGNATURE_METHOD
    try:
        # Get the signature method object.
        signature_method = self.signature_methods[signature_method]
    except:
        signature_method_names = ', '.join(self.signature_methods.keys())
        raise OAuthError('Signature method %s not supported try one of the '
            'following: %s' % (signature_method, signature_method_names))

    return signature_method

</t>
<t tx="newlife.20110117110751.1793">def _get_consumer(self, oauth_request):
    consumer_key = oauth_request.get_parameter('oauth_consumer_key')
    consumer = self.data_store.lookup_consumer(consumer_key)
    if not consumer:
        raise OAuthError('Invalid consumer.')
    return consumer

</t>
<t tx="newlife.20110117110751.1794">def _get_token(self, oauth_request, token_type='access'):
    """Try to find the token for the provided request token key."""
    token_field = oauth_request.get_parameter('oauth_token')
    token = self.data_store.lookup_token(token_type, token_field)
    if not token:
        raise OAuthError('Invalid %s token: %s' % (token_type, token_field))
    return token

</t>
<t tx="newlife.20110117110751.1795">def _get_verifier(self, oauth_request):
    return oauth_request.get_parameter('oauth_verifier')

</t>
<t tx="newlife.20110117110751.1796">def _check_signature(self, oauth_request, consumer, token):
    timestamp, nonce = oauth_request._get_timestamp_nonce()
    self._check_timestamp(timestamp)
    self._check_nonce(consumer, token, nonce)
    signature_method = self._get_signature_method(oauth_request)
    try:
        signature = oauth_request.get_parameter('oauth_signature')
    except:
        raise OAuthError('Missing signature.')
    # Validate the signature.
    valid_sig = signature_method.check_signature(oauth_request, consumer,
        token, signature)
    if not valid_sig:
        key, base = signature_method.build_signature_base_string(
            oauth_request, consumer, token)
        raise OAuthError('Invalid signature. Expected signature base '
            'string: %s' % base)
    built = signature_method.build_signature(oauth_request, consumer, token)

</t>
<t tx="newlife.20110117110751.1797">def _check_timestamp(self, timestamp):
    """Verify that timestamp is recentish."""
    timestamp = int(timestamp)
    now = int(time.time())
    lapsed = abs(now - timestamp)
    if lapsed &gt; self.timestamp_threshold:
        raise OAuthError('Expired timestamp: given %d and now %s has a '
            'greater difference than threshold %d' %
            (timestamp, now, self.timestamp_threshold))

</t>
<t tx="newlife.20110117110751.1798">def _check_nonce(self, consumer, token, nonce):
    """Verify that the nonce is uniqueish."""
    nonce = self.data_store.lookup_nonce(consumer, token, nonce)
    if nonce:
        raise OAuthError('Nonce already used: %s' % str(nonce))


</t>
<t tx="newlife.20110117110751.1799">class OAuthClient(object):
    """OAuthClient is a worker to attempt to execute a request."""
    consumer = None
    token = None

    @others
</t>
<t tx="newlife.20110117110751.1800">def __init__(self, oauth_consumer, oauth_token):
    self.consumer = oauth_consumer
    self.token = oauth_token

</t>
<t tx="newlife.20110117110751.1801">def get_consumer(self):
    return self.consumer

</t>
<t tx="newlife.20110117110751.1802">def get_token(self):
    return self.token

</t>
<t tx="newlife.20110117110751.1803">def fetch_request_token(self, oauth_request):
    """-&gt; OAuthToken."""
    raise NotImplementedError

</t>
<t tx="newlife.20110117110751.1804">def fetch_access_token(self, oauth_request):
    """-&gt; OAuthToken."""
    raise NotImplementedError

</t>
<t tx="newlife.20110117110751.1805">def access_resource(self, oauth_request):
    """-&gt; Some protected resource."""
    raise NotImplementedError


</t>
<t tx="newlife.20110117110751.1806">class OAuthDataStore(object):
    """A database abstraction used to lookup consumers and tokens."""
    @others
</t>
<t tx="newlife.20110117110751.1807">
def lookup_consumer(self, key):
    """-&gt; OAuthConsumer."""
    raise NotImplementedError

</t>
<t tx="newlife.20110117110751.1808">def lookup_token(self, oauth_consumer, token_type, token_token):
    """-&gt; OAuthToken."""
    raise NotImplementedError

</t>
<t tx="newlife.20110117110751.1809">def lookup_nonce(self, oauth_consumer, oauth_token, nonce):
    """-&gt; OAuthToken."""
    raise NotImplementedError

</t>
<t tx="newlife.20110117110751.1810">def fetch_request_token(self, oauth_consumer, oauth_callback):
    """-&gt; OAuthToken."""
    raise NotImplementedError

</t>
<t tx="newlife.20110117110751.1811">def fetch_access_token(self, oauth_consumer, oauth_token, oauth_verifier):
    """-&gt; OAuthToken."""
    raise NotImplementedError

</t>
<t tx="newlife.20110117110751.1812">def authorize_request_token(self, oauth_token, user):
    """-&gt; OAuthToken."""
    raise NotImplementedError


</t>
<t tx="newlife.20110117110751.1813">class OAuthSignatureMethod(object):
    """A strategy class that implements a signature method."""
    @others
</t>
<t tx="newlife.20110117110751.1814">def get_name(self):
    """-&gt; str."""
    raise NotImplementedError

</t>
<t tx="newlife.20110117110751.1815">def build_signature_base_string(self, oauth_request, oauth_consumer, oauth_token):
    """-&gt; str key, str raw."""
    raise NotImplementedError

</t>
<t tx="newlife.20110117110751.1816">def build_signature(self, oauth_request, oauth_consumer, oauth_token):
    """-&gt; str."""
    raise NotImplementedError

</t>
<t tx="newlife.20110117110751.1817">def check_signature(self, oauth_request, consumer, token, signature):
    built = self.build_signature(oauth_request, consumer, token)
    return built == signature


</t>
<t tx="newlife.20110117110751.1818">class OAuthSignatureMethod_HMAC_SHA1(OAuthSignatureMethod):
    @others
</t>
<t tx="newlife.20110117110751.1819">
def get_name(self):
    return 'HMAC-SHA1'

</t>
<t tx="newlife.20110117110751.1820">def build_signature_base_string(self, oauth_request, consumer, token):
    sig = (
        escape(oauth_request.get_normalized_http_method()),
        escape(oauth_request.get_normalized_http_url()),
        escape(oauth_request.get_normalized_parameters()),
    )

    key = '%s&amp;' % escape(consumer.secret)
    if token:
        key += escape(token.secret)
    #print "OAuth base string:" + str(sig)
    raw = '&amp;'.join(sig)
    return key, raw

</t>
<t tx="newlife.20110117110751.1821">def build_signature(self, oauth_request, consumer, token):
    """Builds the base signature string."""
    key, raw = self.build_signature_base_string(oauth_request, consumer,
        token)

    # HMAC object.
    try:
        import hashlib # 2.5
        hashed = hmac.new(key, raw, hashlib.sha1)
    except:
        import sha # Deprecated
        hashed = hmac.new(key, raw, sha)

    # Calculate the digest base 64.
    return binascii.b2a_base64(hashed.digest())[:-1]


</t>
<t tx="newlife.20110117110751.1822">class OAuthSignatureMethod_PLAINTEXT(OAuthSignatureMethod):
    @others
</t>
<t tx="newlife.20110117110751.1823">
def get_name(self):
    return 'PLAINTEXT'

</t>
<t tx="newlife.20110117110751.1824">def build_signature_base_string(self, oauth_request, consumer, token):
    """Concatenates the consumer key and secret."""
    sig = '%s&amp;' % escape(consumer.secret)
    if token:
        sig = sig + escape(token.secret)
    return sig, sig

</t>
<t tx="newlife.20110117110751.1825">def build_signature(self, oauth_request, consumer, token):
    key, raw = self.build_signature_base_string(oauth_request, consumer,
        token)
    return key</t>
<t tx="newlife.20110117110751.1826">@language python
@tabwidth -4
@others
@ignore</t>
<t tx="newlife.20110117110751.1827">
# Copyright 2009-2010 Joshua Roesslein
# See LICENSE for details.

from weibopy.models import ModelFactory
from weibopy.utils import import_simplejson
from weibopy.error import WeibopError

</t>
<t tx="newlife.20110117110751.1828">class Parser(object):
    @others
</t>
<t tx="newlife.20110117110751.1829">
def parse(self, method, payload):
    """
    Parse the response payload and return the result.
    Returns a tuple that contains the result data and the cursors
    (or None if not present).
    """
    raise NotImplementedError

</t>
<t tx="newlife.20110117110751.1830">def parse_error(self, method, payload):
    """
    Parse the error message from payload.
    If unable to parse the message, throw an exception
    and default error message will be used.
    """
    raise NotImplementedError


</t>
<t tx="newlife.20110117110751.1831">class JSONParser(Parser):

    payload_format = 'json'

    @others
</t>
<t tx="newlife.20110117110751.1832">def __init__(self):
    self.json_lib = import_simplejson()

</t>
<t tx="newlife.20110117110751.1833">def parse(self, method, payload):
    try:
        json = self.json_lib.loads(payload)
    except Exception, e:
        print "Failed to parse JSON payload:"+ str(payload)
        raise WeibopError('Failed to parse JSON payload: %s' % e)

    #if isinstance(json, dict) and 'previous_cursor' in json and 'next_cursor' in json:
    #    cursors = json['previous_cursor'], json['next_cursor']
    #    return json, cursors
    #else:
    return json

</t>
<t tx="newlife.20110117110751.1834">def parse_error(self, method, payload):
    return self.json_lib.loads(payload)


</t>
<t tx="newlife.20110117110751.1835">class ModelParser(JSONParser):
    @others
</t>
<t tx="newlife.20110117110751.1836">
def __init__(self, model_factory=None):
    JSONParser.__init__(self)
    self.model_factory = model_factory or ModelFactory

</t>
<t tx="newlife.20110117110751.1837">def parse(self, method, payload):
    try:
        if method.payload_type is None: return
        model = getattr(self.model_factory, method.payload_type)
    except AttributeError:
        raise WeibopError('No model for this payload type: %s' % method.payload_type)

    json = JSONParser.parse(self, method, payload)
    if isinstance(json, tuple):
        json, cursors = json
    else:
        cursors = None

    if method.payload_list:
        result = model.parse_list(method.api, json)
    else:
        result = model.parse(method.api, json)
    if cursors:
        return result, cursors
    else:
        return result

</t>
<t tx="newlife.20110117110751.1838">@language python
@tabwidth -4
@others
@ignore</t>
<t tx="newlife.20110117110751.1839">
# Copyright 2009-2010 Joshua Roesslein
# See LICENSE for details.

import httplib
from socket import timeout
from threading import Thread
from time import sleep
import urllib

from weibopy.auth import BasicAuthHandler
from weibopy.models import Status
from weibopy.api import API
from weibopy.error import WeibopError

from weibopy.utils import import_simplejson
json = import_simplejson()

STREAM_VERSION = 1


</t>
<t tx="newlife.20110117110751.1840">class StreamListener(object):
    @others
</t>
<t tx="newlife.20110117110751.1841">
def __init__(self, api=None):
    self.api = api or API()

</t>
<t tx="newlife.20110117110751.1842">def on_data(self, data):
    """Called when raw data is received from connection.

    Override this method if you wish to manually handle
    the stream data. Return False to stop stream and close connection.
    """

    if 'in_reply_to_status_id' in data:
        status = Status.parse(self.api, json.loads(data))
        if self.on_status(status) is False:
            return False
    elif 'delete' in data:
        delete = json.loads(data)['delete']['status']
        if self.on_delete(delete['id'], delete['user_id']) is False:
            return False
    elif 'limit' in data:
        if self.on_limit(json.loads(data)['limit']['track']) is False:
            return False

</t>
<t tx="newlife.20110117110751.1843">def on_status(self, status):
    """Called when a new status arrives"""
    return

</t>
<t tx="newlife.20110117110751.1844">def on_delete(self, status_id, user_id):
    """Called when a delete notice arrives for a status"""
    return

</t>
<t tx="newlife.20110117110751.1845">def on_limit(self, track):
    """Called when a limitation notice arrvies"""
    return

</t>
<t tx="newlife.20110117110751.1846">def on_error(self, status_code):
    """Called when a non-200 status code is returned"""
    return False

</t>
<t tx="newlife.20110117110751.1847">def on_timeout(self):
    """Called when stream connection times out"""
    return


</t>
<t tx="newlife.20110117110751.1848">class Stream(object):

    host = 'stream.twitter.com'

    @others
</t>
<t tx="newlife.20110117110751.1849">def __init__(self, username, password, listener, timeout=5.0, retry_count = None,
                retry_time = 10.0, snooze_time = 5.0, buffer_size=1500, headers=None):
    self.auth = BasicAuthHandler(username, password)
    self.running = False
    self.timeout = timeout
    self.retry_count = retry_count
    self.retry_time = retry_time
    self.snooze_time = snooze_time
    self.buffer_size = buffer_size
    self.listener = listener
    self.api = API()
    self.headers = headers or {}
    self.body = None

</t>
<t tx="newlife.20110117110751.1850">def _run(self):
    # setup
    self.auth.apply_auth(None, None, self.headers, None)

    # enter loop
    error_counter = 0
    conn = None
    while self.running:
        if self.retry_count and error_counter &gt; self.retry_count:
            # quit if error count greater than retry count
            break
        try:
            conn = httplib.HTTPConnection(self.host)
            conn.connect()
            conn.sock.settimeout(self.timeout)
            conn.request('POST', self.url, self.body, headers=self.headers)
            resp = conn.getresponse()
            if resp.status != 200:
                if self.listener.on_error(resp.status) is False:
                    break
                error_counter += 1
                sleep(self.retry_time)
            else:
                error_counter = 0
                self._read_loop(resp)
        except timeout:
            if self.listener.on_timeout() == False:
                break
            if self.running is False:
                break
            conn.close()
            sleep(self.snooze_time)
        except Exception:
            # any other exception is fatal, so kill loop
            break

    # cleanup
    self.running = False
    if conn:
        conn.close()

</t>
<t tx="newlife.20110117110751.1851">def _read_loop(self, resp):
    data = ''
    while self.running:
        if resp.isclosed():
            break

        # read length
        length = ''
        while True:
            c = resp.read(1)
            if c == '\n':
                break
            length += c
        length = length.strip()
        if length.isdigit():
            length = int(length)
        else:
            continue

        # read data and pass into listener
        data = resp.read(length)
        if self.listener.on_data(data) is False:
            self.running = False

</t>
<t tx="newlife.20110117110751.1852">def _start(self, async):
    self.running = True
    if async:
        Thread(target=self._run).start()
    else:
        self._run()

</t>
<t tx="newlife.20110117110751.1853">def firehose(self, count=None, async=False):
    if self.running:
        raise WeibopError('Stream object already connected!')
    self.url = '/%i/statuses/firehose.json?delimited=length' % STREAM_VERSION
    if count:
        self.url += '&amp;count=%s' % count
    self._start(async)

</t>
<t tx="newlife.20110117110751.1854">def retweet(self, async=False):
    if self.running:
        raise WeibopError('Stream object already connected!')
    self.url = '/%i/statuses/retweet.json?delimited=length' % STREAM_VERSION
    self._start(async)

</t>
<t tx="newlife.20110117110751.1855">def sample(self, count=None, async=False):
    if self.running:
        raise WeibopError('Stream object already connected!')
    self.url = '/%i/statuses/sample.json?delimited=length' % STREAM_VERSION
    if count:
        self.url += '&amp;count=%s' % count
    self._start(async)

</t>
<t tx="newlife.20110117110751.1856">def filter(self, follow=None, track=None, async=False):
    params = {}
    self.headers['Content-type'] = "application/x-www-form-urlencoded"
    if self.running:
        raise WeibopError('Stream object already connected!')
    self.url = '/%i/statuses/filter.json?delimited=length' % STREAM_VERSION
    if follow:
        params['follow'] = ','.join(map(str, follow))
    if track:
        params['track'] = ','.join(map(str, track))
    self.body = urllib.urlencode(params)
    self._start(async)

</t>
<t tx="newlife.20110117110751.1857">def disconnect(self):
    if self.running is False:
        return
    self.running = False

</t>
<t tx="newlife.20110117110751.1858">@language python
@tabwidth -4
@others
@ignore</t>
<t tx="newlife.20110117110751.1859">
# Copyright 2010 Joshua Roesslein
# See LICENSE for details.

from datetime import datetime
import time
import htmlentitydefs
import re


</t>
<t tx="newlife.20110117110751.1860">def parse_datetime(str):

    # We must parse datetime this way to work in python 2.4
    return datetime(*(time.strptime(str, '%a %b %d %H:%M:%S +0800 %Y')[0:6]))


</t>
<t tx="newlife.20110117110751.1861">def parse_html_value(html):

    return html[html.find('&gt;')+1:html.rfind('&lt;')]


</t>
<t tx="newlife.20110117110751.1862">def parse_a_href(atag):

    start = atag.find('"') + 1
    end = atag.find('"', start)
    return atag[start:end]


</t>
<t tx="newlife.20110117110751.1863">def parse_search_datetime(str):

    # python 2.4
    return datetime(*(time.strptime(str, '%a, %d %b %Y %H:%M:%S +0000')[0:6]))


</t>
<t tx="newlife.20110117110751.1864">def unescape_html(text):
    """Created by Fredrik Lundh (http://effbot.org/zone/re-sub.htm#unescape-html)"""
    def fixup(m):
        text = m.group(0)
        if text[:2] == "&amp;#":
            # character reference
            try:
                if text[:3] == "&amp;#x":
                    return unichr(int(text[3:-1], 16))
                else:
                    return unichr(int(text[2:-1]))
            except ValueError:
                pass
        else:
            # named entity
            try:
                text = unichr(htmlentitydefs.name2codepoint[text[1:-1]])
            except KeyError:
                pass
        return text # leave as is
    return re.sub("&amp;#?\w+;", fixup, text)


</t>
<t tx="newlife.20110117110751.1865">def convert_to_utf8_str(arg):
    # written by Michael Norton (http://docondev.blogspot.com/)
    if isinstance(arg, unicode):
        arg = arg.encode('utf-8')
    elif not isinstance(arg, str):
        arg = str(arg)
    return arg



</t>
<t tx="newlife.20110117110751.1866">def import_simplejson():
    try:
        import simplejson as json
    except ImportError:
        try:
            import json  # Python 2.6+
        except ImportError:
            try:
                from django.utils import simplejson as json  # Google App Engine
            except ImportError:
                raise ImportError, "Can't load a json library"

    return json

</t>
<t tx="newlife.20110117110751.1867"></t>
<t tx="newlife.20110117110751.1868">@language python
@tabwidth -4
@others
@ignore</t>
<t tx="newlife.20110117110751.1869"># -*- coding: utf-8 -*-

import hashlib, time
import urllib, urllib2,httplib
import pickle

from django.conf import settings
from django.core.cache import cache
from django.http import HttpResponseRedirect, HttpResponse
from django.contrib.auth import login, logout, authenticate
from django.contrib.auth.decorators import login_required
from django.contrib.auth.models import User
from apps.members.cache import get_member_by_sns_id
from apps.members.helper import register_member
from users.models import *
from users.cache import *

from thirdparty.weibopy.api import API
from thirdparty.weibopy import oauth
from thirdparty.weibopy.auth import OAuthHandler
from thirdparty.weibopy.error import WeibopError

APP_KEY = '2803109225'
APP_SECRET = 'ca9d9587ce4cce614f93efb44da0a90c'
#APP_KEY = '923681121'
#APP_SECRET = 'b1fe311ebb599dc2092c996a838f4d65'

REQUEST_TOKEN_URL = 'http://api.t.sina.com.cn/oauth/request_token'
AUTHORIZATION_URL = 'http://api.t.sina.com.cn/oauth/authorize'
ACCESS_TOKEN_URL = 'http://api.t.sina.com.cn/oauth/access_token'
POST_NEW_FEED_URL = 'http://api.t.sina.com.cn/statuses/upload.json'

</t>
<t tx="newlife.20110117110751.1870">#保存access_token
def update_sina_accesstoken(user_id, sina_id, access_token, must_save=False):
    try:
        ats = pickle.dumps({'key':access_token.key, 'secret':access_token.secret})
        bb, created = BindBlog.objects.get_or_create(user_id=user_id, blog_type='sina')
        bb.access_token = ats
        bb.blog_id = sina_id
        if created or must_save:
            bb.allowed = True
        bb.save()
    except:
        pass


</t>
<t tx="newlife.20110117110751.1871">def is_send_feed(sns_id):
    bbinfo = get_member_bindblog_info(sns_id)
    if not bbinfo:
        return False
    if bbinfo.allowed:
        return True
    else:
        return False

</t>
<t tx="newlife.20110117110751.1872">def send_user_feed(sns_id, content='', image=None):
    if not content:
        return HttpResponse('no content')

    bbinfo = get_member_bindblog_info(sns_id)
    if not bbinfo:
        return HttpResponse('no bbinfo')
    if not bbinfo.allowed:
        return('disabled feed')

    try:
        at = str(bbinfo.access_token)
        access_token = pickle.loads(at)
    except:
        return HttpResponse('access_token error')
    try:
        content = content.encode('utf-8')
        auth = OAuthHandler(APP_KEY, APP_SECRET)
        auth.setToken(access_token.get('key',''), access_token.get('secret',''))
        api = API(auth)
        if image:
            real_img = '%s%s' % (settings.MEDIA_ROOT, image)
            ret = api.upload(real_img, content)
        else:
            ret = api.update_status(content)

        r = HttpResponse('success')
        return r
    except WeibopError,ex:
        return HttpResponse('send error:%s' % str(ex))
    except:
        import sys
        return HttpResponse('send error:%s' % str(sys.exc_info()))

</t>
<t tx="newlife.20110117110751.1873">def get_request_token():
    consumer = oauth.OAuthConsumer(APP_KEY, APP_SECRET)
    sigmethod = oauth.OAuthSignatureMethod_PLAINTEXT()
    oauth_request = oauth.OAuthRequest.from_consumer_and_token(
                    oauth_consumer = consumer,
                    callback = '%s/sina_login/authorize' % (settings.SITE_URL),
                    http_url= REQUEST_TOKEN_URL
                    )
    oauth_request.sign_request(sigmethod, consumer, None)

    resp = urllib2.urlopen(urllib2.Request(REQUEST_TOKEN_URL, headers=oauth_request.to_header()))
    ret = resp.read()
    result = str(oauth.OAuthToken.from_string(ret))
    if result[:18] == 'oauth_token_secret':
        token = {'oauth_token':result[-32:],
                 'oauth_token_secret':result[19:51]}
    else:
        token = {'oauth_token':result[12:44],
                 'oauth_token_secret':result[-32:]}

    return token

</t>
<t tx="newlife.20110117110751.1874">#下面是 url 使用的方法
def get_user_authorize(request, sync=False):
    token = get_request_token()
    is_sync = request.GET.get('sync_sina', None)
    cache.set(token['oauth_token'],token['oauth_token_secret'])
    oauth_callback = '%s/sina_login/authorize/' % (settings.SITE_URL)
    if is_sync or sync:
        oauth_callback += '?sync_sina=' + is_sync

    params = {
              'oauth_token':token['oauth_token'],
              'oauth_token_secret':token['oauth_token_secret'],
              'oauth_callback': oauth_callback
             }
    data = urllib.urlencode(params)
    url = '%s?%s'%(AUTHORIZATION_URL,data)

    return HttpResponseRedirect(url)

</t>
<t tx="newlife.20110117110751.1875">def get_access_token(request):
    verifier = request.GET['oauth_verifier']
    oauth_token = request.GET['oauth_token']
    is_sync = request.GET.get('sync_sina', None)
    oauth_token_secret = cache.get(oauth_token)
    cache.delete(oauth_token)

    consumer = oauth.OAuthConsumer(APP_KEY, APP_SECRET)
    request_token = oauth.OAuthToken(key=oauth_token, secret=str(oauth_token_secret))
    url = ACCESS_TOKEN_URL

    oauth_request = oauth.OAuthRequest.from_consumer_and_token(
                oauth_consumer = consumer,
                token = request_token, http_url=url,
                verifier = str(verifier)
                )
    sigmethod = oauth.OAuthSignatureMethod_HMAC_SHA1()
    oauth_request.sign_request(sigmethod, consumer, request_token)

    resp = urllib2.urlopen(urllib2.Request(url, headers=oauth_request.to_header()))
    ret = resp.read()
    access_token = oauth.OAuthToken.from_string(ret)

    auth = OAuthHandler(APP_KEY, APP_SECRET)
    auth.setToken(access_token.key, access_token.secret)
    api = API(auth)
    sina_user_info = api.verify_credentials()
    if not is_sync:
        ppy_user = 'sina_%s' % sina_user_info.id
        user = User.objects.filter(username=ppy_user)
        if user: #login for sina users
            user = authenticate(username=ppy_user, password=hashlib.md5(ppy_user).hexdigest())
            if user.is_active:
                login(request, user)
        else:
            # is bind blog user, go to login page.
            BindedSinaIds = BindBlog.objects.filter(blog_id=str(sina_user_info.id), blog_type='sina')
            if BindedSinaIds:
                return HttpResponseRedirect('/game/')

            #add new user
            ppy_realname = sina_user_info.name
            user = User(username=ppy_user, is_active=True)
            user.set_password(hashlib.md5(ppy_user).hexdigest())
            user.save()

            profile = UserProfile(user_id=user.id, nickname=ppy_realname, true_name=ppy_realname,
                                  identity_card_code='22222222')
            profile.save()

            user = authenticate(username=ppy_user, password=hashlib.md5(ppy_user).hexdigest())
            if user.is_active:
                login(request, user)
    else:
        user = User.objects.get(id=request.user.id)

    if sina_user_info.id:
        update_sina_accesstoken(user.id, sina_user_info.id, access_token, bool(is_sync))

    if is_sync:
        return HttpResponseRedirect('/users/sync')
    # 获取用户
    member = get_member_by_sns_id(user.id)
    if member is None:
        member = register_member('', user.id)

    return HttpResponseRedirect('/game/')

</t>
<t tx="newlife.20110117110751.1876">@login_required
def sina_bind_newfeed(request):
    flag = request.POST.get('e', None)
    if flag is None:
        return HttpResponse('data error')

    bbinfo = get_member_bindblog_info(request.user.id)
    if not bbinfo:
        return HttpResponse('no bbinfo')

    flag = (flag=='True')
    if flag != bbinfo.allowed:
        bbinfo.allowed = flag
        bbinfo.save()

    return HttpResponse('success')

</t>
<t tx="newlife.20110117110751.1877">@login_required
def sina_upload(request):
    content = request.POST.get('content', None)
    image = request.POST.get('image', None)

    return send_user_feed(request.user.id, content, image)
</t>
<t tx="newlife.20110117110751.1879">    (r'^sina_login/$','users.helper_sina.get_user_authorize'),
    
    (r'^sina_login/authorize/','users.helper_sina.get_access_token'),
    
    (r'^sina_upload/','users.helper_sina.sina_upload'),
    
    (r'^sina_feedstatus/','users.helper_sina.sina_bind_newfeed'),</t>
<t tx="newlife.20110117110751.1880">#目标网站这里是指sina微博

1，用户登录触发的函数：
users.helper_sina.get_user_authorize
这个函数最后重定向到一个url，就是目标网站的认证页面，组建的是一个很长很长的url

2，经过目标网站的处理

返回处理的页面

users.helper_sina.get_access_token</t>
<t tx="wjl.20110117235658.1869"></t>
<t tx="wjl.20110119224651.1871">@language python
@tabwidth -4
@others
@ignore
</t>
<t tx="wjl.20110119224651.1872"># -*- coding: utf-8 -*-

import hashlib, time
import urllib, urllib2,httplib
import pickle

from django.conf import settings
from django.core.cache import cache
from django.utils import simplejson
from django.http import HttpResponseRedirect, HttpResponse
from django.contrib.auth import login, logout, authenticate
from django.contrib.auth.decorators import login_required
from django.contrib.auth.models import User
from apps.members.cache import get_member_by_sns_id
from apps.members.helper import register_member
from users.models import *
from users.cache import *
from users.helper_sina import update_sina_accesstoken, is_send_feed

from thirdparty.weibopy import oauth

APP_KEY = '051cc73533344b74b234c4504fb8868d'
APP_SECRET = '1aae7458103e4ee3bb1bf740f6954aee'

REQUEST_TOKEN_URL = 'https://open.t.qq.com/cgi-bin/request_token'
AUTHORIZATION_URL = 'https://open.t.qq.com/cgi-bin/authorize'
ACCESS_TOKEN_URL = 'https://open.t.qq.com/cgi-bin/access_token'
USER_URL = 'http://open.t.qq.com/api/user/info'
POST_NEW_FEED_URL = 'http://open.t.qq.com/api/t/add_pic'

</t>
<t tx="wjl.20110119224651.1873">def get_request_token():
    consumer = oauth.OAuthConsumer(APP_KEY, APP_SECRET)
    sigmethod = oauth.OAuthSignatureMethod_HMAC_SHA1()
    oauth_request = oauth.OAuthRequest.from_consumer_and_token(
                    oauth_consumer = consumer,
                    callback = '%s/tencent_login/authorize' % (settings.SITE_URL),
                    http_url= REQUEST_TOKEN_URL,
    )
    oauth_request.sign_request(sigmethod, consumer, None)
    resp = urllib2.urlopen(oauth_request.to_url())
    ret = resp.read()
    fs = oauth.OAuthToken.from_string(ret)
    result = str(fs)
    ra = result.split('&amp;')
    token = {}
    for item in ra:
        key,value = item.split('=')
        if key in ['oauth_token_secret', 'oauth_token']:
            token[key] = value
    return token


</t>
<t tx="wjl.20110119224651.1874">#下面是 url 使用的方法
def get_user_authorize(request, sync=False):
    token = get_request_token()
    is_sync = request.GET.get('sync_tencent', None)
    cache.set(token['oauth_token'],token['oauth_token_secret'])
    oauth_callback = '%s/tencent_login/authorize/' % (settings.SITE_URL)
    if is_sync or sync:
        oauth_callback += '?sync_tencent=' + is_sync

    params = {'oauth_token':token['oauth_token'],
              'oauth_token_secret':token['oauth_token_secret'],
              'oauth_callback': oauth_callback
    }
    data = urllib.urlencode(params)
    url = '%s?%s'%(AUTHORIZATION_URL,data)

    return HttpResponseRedirect(url)


</t>
<t tx="wjl.20110119224651.1875">def get_access_token(request):
    verifier = request.GET['oauth_verifier']
    oauth_token = request.GET['oauth_token']

    is_sync = request.GET.get('sync_tencent', None)
    oauth_token_secret = cache.get(oauth_token)
    cache.delete(oauth_token)

    #取得 access token
    consumer = oauth.OAuthConsumer(APP_KEY, APP_SECRET)
    request_token = oauth.OAuthToken(key=oauth_token, secret=str(oauth_token_secret))
    oauth_request = oauth.OAuthRequest.from_consumer_and_token(
                oauth_consumer = consumer,
                token = request_token,
                http_url = ACCESS_TOKEN_URL,
                verifier = str(verifier),
    )
    sigmethod = oauth.OAuthSignatureMethod_HMAC_SHA1()
    oauth_request.sign_request(sigmethod, consumer, request_token)
    resp = urllib2.urlopen(oauth_request.to_url())
    ret = resp.read()
    access_token = oauth.OAuthToken.from_string(ret)

    #取用户id
    access_token = oauth.OAuthToken(access_token.key, access_token.secret)
    oauth_request = oauth.OAuthRequest.from_consumer_and_token(
                oauth_consumer = consumer,
                token = access_token,
                http_url = USER_URL,
                verifier = str(verifier),
                parameters = {'format':'json'},
    )
    sigmethod = oauth.OAuthSignatureMethod_HMAC_SHA1()
    oauth_request.sign_request(sigmethod, consumer, access_token)
    url = oauth_request.to_url()
    resp = urllib2.urlopen(url)
    ret = resp.read()
    result = simplejson.loads(ret)

    #检查返回结果
    if result.get('ret',-1) != 0:
        return HttpResponseRedirect('/')

    user_info = result.get('data',{})
    tencent_user_id = user_info.get('name','')
    tencent_user_nickname = user_info.get('nick','')
    tencent_user_avatar = user_info.get('head','')

    if not tencent_user_id:
        return HttpResponseRedirect('/')

    if not is_sync:
        ppy_user = 'qq_%s' % tencent_user_id
        user = User.objects.filter(username=ppy_user)
        if user: #login for sina users
            user = authenticate(username=ppy_user, password=hashlib.md5(ppy_user).hexdigest())
            if user.is_active:
                login(request, user)
        else:
            # is bind blog user, go to login page.
            BindedSinaIds = BindBlog.objects.filter(blog_id=str(tencent_user_id), blog_type='qq')
            if BindedSinaIds:
                return HttpResponseRedirect('/game/')

            #add new user
            ppy_realname = tencent_user_nickname
            user = User(username=ppy_user, is_active=True)
            user.set_password(hashlib.md5(ppy_user).hexdigest())
            user.save()

            profile = UserProfile(user_id=user.id, nickname=ppy_realname, true_name=ppy_realname,
                                  identity_card_code='5555555555')
            profile.save()

            user = authenticate(username=ppy_user, password=hashlib.md5(ppy_user).hexdigest())
            if user.is_active:
                login(request, user)
    else:
        user = User.objects.get(id=request.user.id)

    if tencent_user_id:
        update_sina_accesstoken(user.id, tencent_user_id, access_token, bool(is_sync))

    if is_sync:
        return HttpResponseRedirect('/users/sync')

    # 获取用户
    member = get_member_by_sns_id(user.id)
    if member is None:
        member = register_member('', user.id)

    return HttpResponseRedirect('/game/')


</t>
<t tx="wjl.20110119224651.1876">#发tencent微博
@login_required
def tencent_upload(request):
    content = request.POST.get('content', None)
    image = request.POST.get('image', None)
    if not content:
        return HttpResponse('no content')
    bbinfo = get_member_bindblog_info(sns_id)
    if not bbinfo:
        return HttpResponse('no bbinfo')
    if not bbinfo.allowed:
        return('disabled feed')

    try:
        at = str(bbinfo.access_token)
        access_token = pickle.loads(at)
    except:
        return HttpResponse('access_token error')
    try:
        content = content.encode('utf-8')
        auth = OAuthHandler(APP_KEY, APP_SECRET)
        auth.setToken(access_token.get('key',''), access_token.get('secret',''))
        api = API(auth)
        #整个流程就是这里，前面的是找到access_token,
        if image:
            real_img = '%s%s' % (settings.MEDIA_ROOT, image)
            ret = api.upload(real_img, content)
        else:
            ret = api.update_status(content)

        r = HttpResponse('success')
        return r
    except WeibopError,ex:
        return HttpResponse('send error:%s' % str(ex))
    except:
        import sys
        return HttpResponse('send error:%s' % str(sys.exc_info()))
    

</t>
<t tx="wjl.20110119224651.1877">@language python
@tabwidth -4
@others
@ignore</t>
<t tx="wjl.20110119224651.1878"># -*- coding: utf-8 -*-

import hashlib, time
import urllib, urllib2,httplib
import pickle

from django.conf import settings
from django.core.cache import cache
from django.http import HttpResponseRedirect, HttpResponse
from django.contrib.auth import login, logout, authenticate
from django.contrib.auth.decorators import login_required
from django.contrib.auth.models import User
from apps.members.cache import get_member_by_sns_id
from apps.members.helper import register_member
from users.models import *
from users.cache import *

from thirdparty.weibopy.api import API
from thirdparty.weibopy import oauth
from thirdparty.weibopy.auth import OAuthHandler
from thirdparty.weibopy.error import WeibopError

APP_KEY = '2803109225'
APP_SECRET = 'ca9d9587ce4cce614f93efb44da0a90c'
#APP_KEY = '923681121'
#APP_SECRET = 'b1fe311ebb599dc2092c996a838f4d65'

REQUEST_TOKEN_URL = 'http://api.t.sina.com.cn/oauth/request_token'
AUTHORIZATION_URL = 'http://api.t.sina.com.cn/oauth/authorize'
ACCESS_TOKEN_URL = 'http://api.t.sina.com.cn/oauth/access_token'
POST_NEW_FEED_URL = 'http://api.t.sina.com.cn/statuses/upload.json'

</t>
<t tx="wjl.20110119224651.1879">#保存access_token
def update_sina_accesstoken(user_id, sina_id, access_token, must_save=False):
    try:
        ats = pickle.dumps({'key':access_token.key, 'secret':access_token.secret})
        bb, created = BindBlog.objects.get_or_create(user_id=user_id, blog_type='sina')
        bb.access_token = ats
        bb.blog_id = sina_id
        if created or must_save:
            bb.allowed = True
        bb.save()
    except:
        pass


</t>
<t tx="wjl.20110119224651.1880">def is_send_feed(sns_id):
    bbinfo = get_member_bindblog_info(sns_id)
    if not bbinfo:
        return False
    if bbinfo.allowed:
        return True
    else:
        return False

</t>
<t tx="wjl.20110119224651.1881">def send_user_feed(sns_id, content='', image=None):
    if not content:
        return HttpResponse('no content')

    bbinfo = get_member_bindblog_info(sns_id)
    if not bbinfo:
        return HttpResponse('no bbinfo')
    if not bbinfo.allowed:
        return('disabled feed')

    try:
        at = str(bbinfo.access_token)
        access_token = pickle.loads(at)
    except:
        return HttpResponse('access_token error')
    try:
        content = content.encode('utf-8')
        auth = OAuthHandler(APP_KEY, APP_SECRET)
        auth.setToken(access_token.get('key',''), access_token.get('secret',''))
        api = API(auth)
        if image:
            real_img = '%s%s' % (settings.MEDIA_ROOT, image)
            ret = api.upload(real_img, content)
        else:
            ret = api.update_status(content)

        r = HttpResponse('success')
        return r
    except WeibopError,ex:
        return HttpResponse('send error:%s' % str(ex))
    except:
        import sys
        return HttpResponse('send error:%s' % str(sys.exc_info()))

</t>
<t tx="wjl.20110119224651.1882">def get_request_token():
    consumer = oauth.OAuthConsumer(APP_KEY, APP_SECRET)
    sigmethod = oauth.OAuthSignatureMethod_PLAINTEXT()
    oauth_request = oauth.OAuthRequest.from_consumer_and_token(
                    oauth_consumer = consumer,
                    callback = '%s/sina_login/authorize' % (settings.SITE_URL),
                    http_url= REQUEST_TOKEN_URL
                    )
    oauth_request.sign_request(sigmethod, consumer, None)

    resp = urllib2.urlopen(urllib2.Request(REQUEST_TOKEN_URL, headers=oauth_request.to_header()))
    ret = resp.read()
    result = str(oauth.OAuthToken.from_string(ret))
    if result[:18] == 'oauth_token_secret':
        token = {'oauth_token':result[-32:],
                 'oauth_token_secret':result[19:51]}
    else:
        token = {'oauth_token':result[12:44],
                 'oauth_token_secret':result[-32:]}

    return token

</t>
<t tx="wjl.20110119224651.1883">#下面是 url 使用的方法
def get_user_authorize(request, sync=False):
    token = get_request_token()
    is_sync = request.GET.get('sync_sina', None)
    cache.set(token['oauth_token'],token['oauth_token_secret'])
    oauth_callback = '%s/sina_login/authorize/' % (settings.SITE_URL)
    if is_sync or sync:
        oauth_callback += '?sync_sina=' + is_sync

    params = {
              'oauth_token':token['oauth_token'],
              'oauth_token_secret':token['oauth_token_secret'],
              'oauth_callback': oauth_callback
             }
    data = urllib.urlencode(params)
    url = '%s?%s'%(AUTHORIZATION_URL,data)

    return HttpResponseRedirect(url)

</t>
<t tx="wjl.20110119224651.1884">def get_access_token(request):
    verifier = request.GET['oauth_verifier']
    oauth_token = request.GET['oauth_token']
    is_sync = request.GET.get('sync_sina', None)
    oauth_token_secret = cache.get(oauth_token)
    cache.delete(oauth_token)

    consumer = oauth.OAuthConsumer(APP_KEY, APP_SECRET)
    request_token = oauth.OAuthToken(key=oauth_token, secret=str(oauth_token_secret))
    url = ACCESS_TOKEN_URL

    oauth_request = oauth.OAuthRequest.from_consumer_and_token(
                oauth_consumer = consumer,
                token = request_token, http_url=url,
                verifier = str(verifier)
                )
    sigmethod = oauth.OAuthSignatureMethod_HMAC_SHA1()
    oauth_request.sign_request(sigmethod, consumer, request_token)

    resp = urllib2.urlopen(urllib2.Request(url, headers=oauth_request.to_header()))
    ret = resp.read()
    access_token = oauth.OAuthToken.from_string(ret)

    auth = OAuthHandler(APP_KEY, APP_SECRET)
    auth.setToken(access_token.key, access_token.secret)
    api = API(auth)
    sina_user_info = api.verify_credentials()
    if not is_sync:
        ppy_user = 'sina_%s' % sina_user_info.id
        user = User.objects.filter(username=ppy_user)
        if user: #login for sina users
            user = authenticate(username=ppy_user, password=hashlib.md5(ppy_user).hexdigest())
            if user.is_active:
                login(request, user)
        else:
            # is bind blog user, go to login page.
            BindedSinaIds = BindBlog.objects.filter(blog_id=str(sina_user_info.id), blog_type='sina')
            if BindedSinaIds:
                return HttpResponseRedirect('/game/')

            #add new user
            ppy_realname = sina_user_info.name
            user = User(username=ppy_user, is_active=True)
            user.set_password(hashlib.md5(ppy_user).hexdigest())
            user.save()

            profile = UserProfile(user_id=user.id, nickname=ppy_realname, true_name=ppy_realname,
                                  identity_card_code='22222222')
            profile.save()

            user = authenticate(username=ppy_user, password=hashlib.md5(ppy_user).hexdigest())
            if user.is_active:
                login(request, user)
    else:
        user = User.objects.get(id=request.user.id)

    if sina_user_info.id:
        update_sina_accesstoken(user.id, sina_user_info.id, access_token, bool(is_sync))

    if is_sync:
        return HttpResponseRedirect('/users/sync')
    # 获取用户
    member = get_member_by_sns_id(user.id)
    if member is None:
        member = register_member('', user.id)

    return HttpResponseRedirect('/game/')

</t>
<t tx="wjl.20110119224651.1885">@login_required
def sina_bind_newfeed(request):
    flag = request.POST.get('e', None)
    if flag is None:
        return HttpResponse('data error')

    bbinfo = get_member_bindblog_info(request.user.id)
    if not bbinfo:
        return HttpResponse('no bbinfo')

    flag = (flag=='True')
    if flag != bbinfo.allowed:
        bbinfo.allowed = flag
        bbinfo.save()

    return HttpResponse('success')

</t>
<t tx="wjl.20110119224651.1886">@login_required
def sina_upload(request):
    content = request.POST.get('content', None)
    image = request.POST.get('image', None)

    return send_user_feed(request.user.id, content, image)
</t>
<t tx="wjl.20110119224651.1889">from users.constants import *

def get_member_bindblog_info(sns_id):
    key = CACHE_SINA_USER_INFO % (sns_id)
    bb = cache.get(key)

    if bb is None:
        bbs = BindBlog.objects.filter(user_id=sns_id, blog_type='sina')
        if bbs:
            bb = bbs[0]
            cache.set(key, bb)
        else:
            return None

    return bb

</t>
<t tx="wjl.20110119224651.1890"></t>
<t tx="wjl.20110119224651.1891">post提交数据，
就是urlencode，，</t>
<t tx="wjl.20110119224651.1892">flash里触发send_user_feeds
根据用户的id判断要调用的url，
这个还是在js里，，
</t>
</tnodes>
</leo_file>
