<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
<?xml-stylesheet ekr_test?>
<leo_file xmlns:leo="http://www.leo-editor.org/2011/leo" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="newlife.20111118115344.1125" a="E"><vh>root</vh>
<v t="newlife.20111118115344.1123"><vh>route</vh></v>
<v t="newlife.20111118115344.1124"><vh>view</vh></v>
<v t="newlife.20111118115344.1126"><vh>reply from kevin</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="newlife.20111118115344.1123">Usage

For a route creation RESTAS uses macro restas:define-route e.g.:

(restas:define-route article ("articles/:author/:item"
                              :method :get
                              :content-type "text/plain")
  (format nil "Author: ~A~Article: ~A" author item))


In other words, we define an URL template and its handler, meanwhile the handler body have immediate access to the variables defined in the URL template. Embedded handler by default may return string or "octets array", or integer number (which will be interpreted as a code of request status), or pathname (in this case hunchentoot:handle-static-file is called, which, contrary to Ruby- and Python-based systems, works fast enough and usually there is no need for additional servers for static content, such as the nginx server.

;;换句话说，我们定义了一个url模板和他的处理器，同时处理器直接访问了定义在url模板里的变量。内置的处理器默认返回string或者位组数组，或者整数（这个会被解释为请求状态码，比如404），或是路径名

When you define a route with restas:define-route you need to specify symbol (in cited example it is 'article), which will became the route name. Firstly, it gives you the possibility to redefine the route (including the URL template, just keep the same name for it) at any moment you want, just send the code to REPL (for example, with M-C-x in SLIME). Secondly, it lets you use this symbol for URL generation:
;;
</t>
<t tx="newlife.20111118115344.1124">@doc
View

Separation of application logic from view logic is a powerful and useful technique, frequently used in web application development. RESTAS doesn't force you to use such separation, but, if desired, it is provided by the generic function
视图和逻辑分离是一项强大而且有用的技术，一般用于web开发，restas不强制你使用这种分离，但是如果你想用，generic function
restas:render-object 提供了这个功能。
(defgeneric restas:render-object (drawer object)
  (:documentation "Render object via drawer"))
  
It is always called for processing the data returned by route handlers (defined with restas:define-route). As you see here, two objects are used for content generation: a drawer and a data object, so one can speak about full-fledged logic and view separation, and CL multimethods make this approach quite powerful. 

这个函数调用是为了处理由router handler返回的数据，我们可以看出，2个对象用来生成内容：一个drawer和data，所以我们可以说
全面的逻辑和视图分离，并且cl multimethods 使这一过程十分强大

The drawer to use is specified in module variable *default-render-method* and is set to nil by default. 
drawer是通过模块变量*default-render-method*制定，并被默认设置为nil
RESTAS defines specialized restas:render-object methods, which can accept the following types:

string or array octets - data is sent to client without any additional processing.

pathname - file is sent to client by hunchentoot:handle-static-file

integer - result is treated as HTTP status and client receives corresponding special page.

Report error in other cases.

Also there are methods for functions passed as drawer:

pathname or integer - default handler is called (data is just sent to client without any processing)

以上无用，
In other cases supplied function is called with funcall for data processing and the result is sent to client.
在其他情况下，

Apart from this, there is a specialized method for accepting arbitrary package as drawer. This possibility has following basis:
除此之外，还有一个特殊的方法用来接受arbitrary包作为drawer。这种可能有以下基础，

Each route has its own name and is bound by symbol.
每个route有自己的名字，并且绑定一个symbol，

The author uses cl-closure-template for view logic almost always, and it compiles templates to functions and creates separate package for them.

If you follow a small agreement and give templates the same names as routes have, then you can specify as *default-render-method* the package containing template functions, and RESTAS for processing a data generated by a route handler will automatically call a template function with the same name as the route, but from package with templates.

Behold such a little magic implemented in quite simple and understandable way. As far as technically this is just a specializer for restas:render-object, you can use it in other ways, for example, restas-colorize (pastebin analogue, you can see it in work at http://lisper.ru/apps/format/) currently uses the following code for generating its layout:

(restas:define-default-render-method (obj)
  (closure-template.standard:xhtml-strict-frame
    (list :title (getf obj :title)
          :body (restas.colorize.view:with-main-menu
                  (list :href-all (restas:genurl 'list-pastes)
                        :href-create (restas:genurl 'create-paste)
                        :body (restas:render-object (find-package '#:restas.colorize.view)
                                                    obj)))
          :css (iter (for item in '("style.css" "colorize.css"))
                     (collect (restas:genurl 'css :file item))))))
Here we defined *default-render-method* as function (for simplicity, macro restas:define-default-render-method was used) which with aid of "package with templates" generates substantial part of page:

(restas:render-object (find-package '#:restas.colorize.view) obj)
and this part later is used for the generation of complete html code.

And, of course, a developer can define his own specializers of restas:render-object for his own drawer type.

The other way for separation of logic and view can be used, for example, when using *default-render-method* doesn't fits for a particular route, and it is :render-method parameter of restas:define-route. Example:

(restas:define-route api-method ("/path/to/method/:(param1)/:(param2)"
                                 :content-type "application/json"
                                 :render-method #'json:encode-json)
  (list :field1 (sql-query "select ...")
        :field2 (sql-query "select ..."))))</t>
<t tx="newlife.20111118115344.1125"></t>
<t tx="newlife.20111118115344.1126">@doc
定义了route后，route的返回值将被返回给浏览器。但这些结果需要经过一点加工。这个加工者就是http://restas.lisper.ru/en/manual/view.html#view这篇文档里描述的drawer。默认的drawer可以处理字符串、静态文件之类。如果需要进行更复杂的渲染，可以通过设置restas:*default-render-method*来重写这个规则，例如ext-blog里：

;; drawer-dispatch.lisp

(defmethod restas:render-object ((drawer drawer-dispatcher) (data list))
  (let* ((blog (getf data :blog))
         (theme (get-theme blog data)))
    (if theme
      (render-page blog theme (restas:route-symbol restas:*route*) (getf data :args))
      (car (getf data :args)))))

(setf *default-render-method* (make-instance 'drawer-dispatcher))


ext-blog里的每个route都返回的是一些数据，不是单纯的字符串。因为我要把ext-blog核心模块与具体的渲染隔离开（因为具体的渲染涉及到博客页面在浏览器端怎样显示），所以我把渲染工作交给所谓的theme去做。

总之，大概的流程就是：

[http client]   --http request--&gt;   [restas]  ----&gt; [your route function result] ---&gt; [drawer]  --http response --&gt; [http client]
 </t>
</tnodes>
</leo_file>
