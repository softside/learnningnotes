<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
<?xml-stylesheet ekr_test?>
<leo_file xmlns:leo="http://www.leo-editor.org/2011/leo" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="newlife.20110623165944.1112" a="E"><vh>django-model</vh>
<v t="newlife.20110623165944.1113"><vh>options.py</vh>
<v t="newlife.20110623165944.1114"><vh>options declarations</vh></v>
<v t="newlife.20110623165944.1115" a="E"><vh>class Options</vh>
<v t="newlife.20110623165944.1116"><vh>__init__</vh></v>
<v t="newlife.20110623165944.1117"><vh>contribute_to_class</vh></v>
<v t="newlife.20110623165944.1118"><vh>_prepare</vh></v>
<v t="newlife.20110623165944.1119"><vh>add_field</vh></v>
<v t="newlife.20110623165944.1120"><vh>add_virtual_field</vh></v>
<v t="newlife.20110623165944.1121"><vh>setup_pk</vh></v>
<v t="newlife.20110623165944.1122"><vh>setup_proxy</vh></v>
<v t="newlife.20110623165944.1123"><vh>__repr__</vh></v>
<v t="newlife.20110623165944.1124"><vh>__str__</vh></v>
<v t="newlife.20110623165944.1125"><vh>verbose_name_raw</vh></v>
<v t="newlife.20110623165944.1126"><vh>_fields</vh></v>
<v t="newlife.20110623165944.1127"><vh>get_fields_with_model</vh></v>
<v t="newlife.20110623165944.1128"><vh>_fill_fields_cache</vh></v>
<v t="newlife.20110623165944.1129"><vh>_many_to_many</vh></v>
<v t="newlife.20110623165944.1130"><vh>get_m2m_with_model</vh></v>
<v t="newlife.20110623165944.1131"><vh>_fill_m2m_cache</vh></v>
<v t="newlife.20110623165944.1132"><vh>get_field</vh></v>
<v t="newlife.20110623165944.1133"><vh>get_field_by_name</vh></v>
<v t="newlife.20110623165944.1134"><vh>get_all_field_names</vh></v>
<v t="newlife.20110623165944.1135"><vh>init_name_map</vh></v>
<v t="newlife.20110623165944.1136"><vh>get_add_permission</vh></v>
<v t="newlife.20110623165944.1137"><vh>get_change_permission</vh></v>
<v t="newlife.20110623165944.1138"><vh>get_delete_permission</vh></v>
<v t="newlife.20110623165944.1139"><vh>get_all_related_objects</vh></v>
<v t="newlife.20110623165944.1140"><vh>get_all_related_objects_with_model</vh></v>
<v t="newlife.20110623165944.1141"><vh>_fill_related_objects_cache</vh></v>
<v t="newlife.20110623165944.1142"><vh>get_all_related_many_to_many_objects</vh></v>
<v t="newlife.20110623165944.1143"><vh>get_all_related_m2m_objects_with_model</vh></v>
<v t="newlife.20110623165944.1144"><vh>_fill_related_many_to_many_cache</vh></v>
<v t="newlife.20110623165944.1145"><vh>get_base_chain</vh></v>
<v t="newlife.20110623165944.1146"><vh>get_parent_list</vh></v>
<v t="newlife.20110623165944.1147"><vh>get_ancestor_link</vh></v>
<v t="newlife.20110623165944.1148"><vh>get_ordered_objects</vh></v>
<v t="newlife.20110623165944.1149"><vh>pk_index</vh></v>
</v>
</v>
<v t="newlife.20110704161758.1190" a="E"><vh>base.py</vh>
<v t="newlife.20110704161758.1191"><vh>base declarations</vh></v>
<v t="newlife.20110704161758.1192" a="E"><vh>class ModelBase</vh>
<v t="newlife.20110704161758.1193"><vh>__new__</vh></v>
<v t="newlife.20110704161758.1194"><vh>copy_managers</vh></v>
<v t="newlife.20110704161758.1195"><vh>add_to_class</vh></v>
<v t="newlife.20110704161758.1196"><vh>_prepare</vh></v>
</v>
<v t="newlife.20110704161758.1197"><vh>class ModelState</vh>
<v t="newlife.20110704161758.1198"><vh>__init__</vh></v>
</v>
<v t="newlife.20110704161758.1199"><vh>class Model</vh>
<v t="newlife.20110704161758.1200"><vh>__init__</vh></v>
<v t="newlife.20110704161758.1201"><vh>__repr__</vh></v>
<v t="newlife.20110704161758.1202"><vh>__str__</vh></v>
<v t="newlife.20110704161758.1203"><vh>__eq__</vh></v>
<v t="newlife.20110704161758.1204"><vh>__ne__</vh></v>
<v t="newlife.20110704161758.1205"><vh>__hash__</vh></v>
<v t="newlife.20110704161758.1206"><vh>__reduce__</vh></v>
<v t="newlife.20110704161758.1207"><vh>_get_pk_val</vh></v>
<v t="newlife.20110704161758.1208"><vh>_set_pk_val</vh></v>
<v t="newlife.20110704161758.1209"><vh>serializable_value</vh></v>
<v t="newlife.20110704161758.1210"><vh>save</vh></v>
<v t="newlife.20110704161758.1211"><vh>save_base</vh></v>
<v t="newlife.20110704161758.1212"><vh>_collect_sub_objects</vh></v>
<v t="newlife.20110704161758.1213"><vh>delete</vh></v>
<v t="newlife.20110704161758.1214"><vh>_get_FIELD_display</vh></v>
<v t="newlife.20110704161758.1215"><vh>_get_next_or_previous_by_FIELD</vh></v>
<v t="newlife.20110704161758.1216"><vh>_get_next_or_previous_in_order</vh></v>
<v t="newlife.20110704161758.1217"><vh>prepare_database_save</vh></v>
<v t="newlife.20110704161758.1218"><vh>clean</vh></v>
<v t="newlife.20110704161758.1219"><vh>validate_unique</vh></v>
<v t="newlife.20110704161758.1220"><vh>_get_unique_checks</vh></v>
<v t="newlife.20110704161758.1221"><vh>_perform_unique_checks</vh></v>
<v t="newlife.20110704161758.1222"><vh>_perform_date_checks</vh></v>
<v t="newlife.20110704161758.1223"><vh>date_error_message</vh></v>
<v t="newlife.20110704161758.1224"><vh>unique_error_message</vh></v>
<v t="newlife.20110704161758.1225"><vh>full_clean</vh></v>
<v t="newlife.20110704161758.1226"><vh>clean_fields</vh></v>
</v>
<v t="newlife.20110704161758.1227"><vh>method_set_order</vh></v>
<v t="newlife.20110704161758.1228"><vh>method_get_order</vh></v>
<v t="newlife.20110704161758.1229"><vh>get_absolute_url</vh></v>
<v t="newlife.20110704161758.1230"><vh>class Empty</vh></v>
<v t="newlife.20110704161758.1231"><vh>simple_class_factory</vh></v>
<v t="newlife.20110704161758.1232"><vh>model_unpickle</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="newlife.20110623165944.1112"></t>
<t tx="newlife.20110623165944.1113">@language python
@tabwidth -4
@others
@ignore

@doc
首先要弄清楚这个类是做啥用的，</t>
<t tx="newlife.20110623165944.1114">import re
from bisect import bisect

from django.conf import settings
from django.db.models.related import RelatedObject
from django.db.models.fields.related import ManyToManyRel
from django.db.models.fields import AutoField, FieldDoesNotExist
from django.db.models.fields.proxy import OrderWrt
from django.db.models.loading import get_models, app_cache_ready
from django.utils.translation import activate, deactivate_all, get_language, string_concat
from django.utils.encoding import force_unicode, smart_str
from django.utils.datastructures import SortedDict

# Calculate the verbose_name by converting from InitialCaps to "lowercase with spaces".
get_verbose_name = lambda class_name: re.sub('(((?&lt;=[a-z])[A-Z])|([A-Z](?![A-Z]|$)))', ' \\1', class_name).lower().strip()

DEFAULT_NAMES = ('verbose_name', 'verbose_name_plural', 'db_table', 'ordering',
                 'unique_together', 'permissions', 'get_latest_by',
                 'order_with_respect_to', 'app_label', 'db_tablespace',
                 'abstract', 'managed', 'proxy', 'auto_created')

</t>
<t tx="newlife.20110623165944.1115">class Options(object):
    @others
</t>
<t tx="newlife.20110623165944.1116">def __init__(self, meta, app_label=None):
    self.local_fields, self.local_many_to_many = [], []
    self.virtual_fields = []
    self.module_name, self.verbose_name = None, None
    self.verbose_name_plural = None
    self.db_table = ''
    self.ordering = []
    self.unique_together =  []
    self.permissions =  []
    self.object_name, self.app_label = None, app_label
    self.get_latest_by = None
    self.order_with_respect_to = None
    self.db_tablespace = settings.DEFAULT_TABLESPACE
    self.admin = None
    self.meta = meta
    self.pk = None
    self.has_auto_field, self.auto_field = False, None
    self.abstract = False
    self.managed = True
    self.proxy = False
    self.proxy_for_model = None
    self.parents = SortedDict()
    self.duplicate_targets = {}
    self.auto_created = False

    # To handle various inheritance situations, we need to track where
    # managers came from (concrete or abstract base classes).
    self.abstract_managers = []
    self.concrete_managers = []

    # List of all lookups defined in ForeignKey 'limit_choices_to' options
    # from *other* models. Needed for some admin checks. Internal use only.
    self.related_fkey_lookups = []

</t>
<t tx="newlife.20110623165944.1117">def contribute_to_class(self, cls, name):
    from django.db import connection
    from django.db.backends.util import truncate_name

    cls._meta = self
    self.installed = re.sub('\.models$', '', cls.__module__) in settings.INSTALLED_APPS
    # First, construct the default values for these options.
    self.object_name = cls.__name__
    self.module_name = self.object_name.lower()
    self.verbose_name = get_verbose_name(self.object_name)

    # Next, apply any overridden values from 'class Meta'.
    if self.meta:
        meta_attrs = self.meta.__dict__.copy()
        for name in self.meta.__dict__:
            # Ignore any private attributes that Django doesn't care about.
            # NOTE: We can't modify a dictionary's contents while looping
            # over it, so we loop over the *original* dictionary instead.
            if name.startswith('_'):
                del meta_attrs[name]
        for attr_name in DEFAULT_NAMES:
            if attr_name in meta_attrs:
                setattr(self, attr_name, meta_attrs.pop(attr_name))
            elif hasattr(self.meta, attr_name):
                setattr(self, attr_name, getattr(self.meta, attr_name))

        # unique_together can be either a tuple of tuples, or a single
        # tuple of two strings. Normalize it to a tuple of tuples, so that
        # calling code can uniformly expect that.
        ut = meta_attrs.pop('unique_together', getattr(self, 'unique_together'))
        if ut and not isinstance(ut[0], (tuple, list)):
            ut = (ut,)
        setattr(self, 'unique_together', ut)

        # verbose_name_plural is a special case because it uses a 's'
        # by default.
        if self.verbose_name_plural is None:
            self.verbose_name_plural = string_concat(self.verbose_name, 's')

        # Any leftover attributes must be invalid.
        if meta_attrs != {}:
            raise TypeError("'class Meta' got invalid attribute(s): %s" % ','.join(meta_attrs.keys()))
    else:
        self.verbose_name_plural = string_concat(self.verbose_name, 's')
    del self.meta

    # If the db_table wasn't provided, use the app_label + module_name.
    if not self.db_table:
        self.db_table = "%s_%s" % (self.app_label, self.module_name)
        self.db_table = truncate_name(self.db_table, connection.ops.max_name_length())

</t>
<t tx="newlife.20110623165944.1118">def _prepare(self, model):
    if self.order_with_respect_to:
        self.order_with_respect_to = self.get_field(self.order_with_respect_to)
        self.ordering = ('_order',)
        model.add_to_class('_order', OrderWrt())
    else:
        self.order_with_respect_to = None

    if self.pk is None:
        if self.parents:
            # Promote the first parent link in lieu of adding yet another
            # field.
            field = self.parents.value_for_index(0)
            field.primary_key = True
            self.setup_pk(field)
        else:
            auto = AutoField(verbose_name='ID', primary_key=True,
                    auto_created=True)
            model.add_to_class('id', auto)

    # Determine any sets of fields that are pointing to the same targets
    # (e.g. two ForeignKeys to the same remote model). The query
    # construction code needs to know this. At the end of this,
    # self.duplicate_targets will map each duplicate field column to the
    # columns it duplicates.
    collections = {}
    for column, target in self.duplicate_targets.iteritems():
        try:
            collections[target].add(column)
        except KeyError:
            collections[target] = set([column])
    self.duplicate_targets = {}
    for elt in collections.itervalues():
        if len(elt) == 1:
            continue
        for column in elt:
            self.duplicate_targets[column] = elt.difference(set([column]))

</t>
<t tx="newlife.20110623165944.1119">def add_field(self, field):
    # Insert the given field in the order in which it was created, using
    # the "creation_counter" attribute of the field.
    # Move many-to-many related fields from self.fields into
    # self.many_to_many.
    if field.rel and isinstance(field.rel, ManyToManyRel):
        self.local_many_to_many.insert(bisect(self.local_many_to_many, field), field)
        if hasattr(self, '_m2m_cache'):
            del self._m2m_cache
    else:
        self.local_fields.insert(bisect(self.local_fields, field), field)
        self.setup_pk(field)
        if hasattr(self, '_field_cache'):
            del self._field_cache
            del self._field_name_cache

    if hasattr(self, '_name_map'):
        del self._name_map

</t>
<t tx="newlife.20110623165944.1120">def add_virtual_field(self, field):
    self.virtual_fields.append(field)

</t>
<t tx="newlife.20110623165944.1121">def setup_pk(self, field):
    if not self.pk and field.primary_key:
        self.pk = field
        field.serialize = False

</t>
<t tx="newlife.20110623165944.1122">def setup_proxy(self, target):
    """
    Does the internal setup so that the current model is a proxy for
    "target".
    """
    self.pk = target._meta.pk
    self.proxy_for_model = target
    self.db_table = target._meta.db_table

</t>
<t tx="newlife.20110623165944.1123">def __repr__(self):
    return '&lt;Options for %s&gt;' % self.object_name

</t>
<t tx="newlife.20110623165944.1124">def __str__(self):
    return "%s.%s" % (smart_str(self.app_label), smart_str(self.module_name))

</t>
<t tx="newlife.20110623165944.1125">def verbose_name_raw(self):
    """
    There are a few places where the untranslated verbose name is needed
    (so that we get the same value regardless of currently active
    locale).
    """
    lang = get_language()
    deactivate_all()
    raw = force_unicode(self.verbose_name)
    activate(lang)
    return raw
</t>
<t tx="newlife.20110623165944.1126">verbose_name_raw = property(verbose_name_raw)

def _fields(self):
    """
    The getter for self.fields. This returns the list of field objects
    available to this model (including through parent models).

    Callers are not permitted to modify this list, since it's a reference
    to this instance (not a copy).
    """
    try:
        self._field_name_cache
    except AttributeError:
        self._fill_fields_cache()
    return self._field_name_cache
</t>
<t tx="newlife.20110623165944.1127">fields = property(_fields)

def get_fields_with_model(self):
    """
    Returns a sequence of (field, model) pairs for all fields. The "model"
    element is None for fields on the current model. Mostly of use when
    constructing queries so that we know which model a field belongs to.
    """
    try:
        self._field_cache
    except AttributeError:
        self._fill_fields_cache()
    return self._field_cache

</t>
<t tx="newlife.20110623165944.1128">def _fill_fields_cache(self):
    cache = []
    for parent in self.parents:
        for field, model in parent._meta.get_fields_with_model():
            if model:
                cache.append((field, model))
            else:
                cache.append((field, parent))
    cache.extend([(f, None) for f in self.local_fields])
    self._field_cache = tuple(cache)
    self._field_name_cache = [x for x, _ in cache]

</t>
<t tx="newlife.20110623165944.1129">def _many_to_many(self):
    try:
        self._m2m_cache
    except AttributeError:
        self._fill_m2m_cache()
    return self._m2m_cache.keys()
</t>
<t tx="newlife.20110623165944.1130">many_to_many = property(_many_to_many)

def get_m2m_with_model(self):
    """
    The many-to-many version of get_fields_with_model().
    """
    try:
        self._m2m_cache
    except AttributeError:
        self._fill_m2m_cache()
    return self._m2m_cache.items()

</t>
<t tx="newlife.20110623165944.1131">def _fill_m2m_cache(self):
    cache = SortedDict()
    for parent in self.parents:
        for field, model in parent._meta.get_m2m_with_model():
            if model:
                cache[field] = model
            else:
                cache[field] = parent
    for field in self.local_many_to_many:
        cache[field] = None
    self._m2m_cache = cache

</t>
<t tx="newlife.20110623165944.1132">def get_field(self, name, many_to_many=True):
    """
    Returns the requested field by name. Raises FieldDoesNotExist on error.
    """
    to_search = many_to_many and (self.fields + self.many_to_many) or self.fields
    for f in to_search:
        if f.name == name:
            return f
    raise FieldDoesNotExist('%s has no field named %r' % (self.object_name, name))

</t>
<t tx="newlife.20110623165944.1133">def get_field_by_name(self, name):
    """
    Returns the (field_object, model, direct, m2m), where field_object is
    the Field instance for the given name, model is the model containing
    this field (None for local fields), direct is True if the field exists
    on this model, and m2m is True for many-to-many relations. When
    'direct' is False, 'field_object' is the corresponding RelatedObject
    for this field (since the field doesn't have an instance associated
    with it).

    Uses a cache internally, so after the first access, this is very fast.
    """
    try:
        try:
            return self._name_map[name]
        except AttributeError:
            cache = self.init_name_map()
            return cache[name]
    except KeyError:
        raise FieldDoesNotExist('%s has no field named %r'
                % (self.object_name, name))

</t>
<t tx="newlife.20110623165944.1134">def get_all_field_names(self):
    """
    Returns a list of all field names that are possible for this model
    (including reverse relation names). This is used for pretty printing
    debugging output (a list of choices), so any internal-only field names
    are not included.
    """
    try:
        cache = self._name_map
    except AttributeError:
        cache = self.init_name_map()
    names = cache.keys()
    names.sort()
    # Internal-only names end with "+" (symmetrical m2m related names being
    # the main example). Trim them.
    return [val for val in names if not val.endswith('+')]

</t>
<t tx="newlife.20110623165944.1135">def init_name_map(self):
    """
    Initialises the field name -&gt; field object mapping.
    """
    cache = {}
    # We intentionally handle related m2m objects first so that symmetrical
    # m2m accessor names can be overridden, if necessary.
    for f, model in self.get_all_related_m2m_objects_with_model():
        cache[f.field.related_query_name()] = (f, model, False, True)
    for f, model in self.get_all_related_objects_with_model():
        cache[f.field.related_query_name()] = (f, model, False, False)
    for f, model in self.get_m2m_with_model():
        cache[f.name] = (f, model, True, True)
    for f, model in self.get_fields_with_model():
        cache[f.name] = (f, model, True, False)
    if app_cache_ready():
        self._name_map = cache
    return cache

</t>
<t tx="newlife.20110623165944.1136">def get_add_permission(self):
    return 'add_%s' % self.object_name.lower()

</t>
<t tx="newlife.20110623165944.1137">def get_change_permission(self):
    return 'change_%s' % self.object_name.lower()

</t>
<t tx="newlife.20110623165944.1138">def get_delete_permission(self):
    return 'delete_%s' % self.object_name.lower()

</t>
<t tx="newlife.20110623165944.1139">def get_all_related_objects(self, local_only=False):
    try:
        self._related_objects_cache
    except AttributeError:
        self._fill_related_objects_cache()
    if local_only:
        return [k for k, v in self._related_objects_cache.items() if not v]
    return self._related_objects_cache.keys()

</t>
<t tx="newlife.20110623165944.1140">def get_all_related_objects_with_model(self):
    """
    Returns a list of (related-object, model) pairs. Similar to
    get_fields_with_model().
    """
    try:
        self._related_objects_cache
    except AttributeError:
        self._fill_related_objects_cache()
    return self._related_objects_cache.items()

</t>
<t tx="newlife.20110623165944.1141">def _fill_related_objects_cache(self):
    cache = SortedDict()
    parent_list = self.get_parent_list()
    for parent in self.parents:
        for obj, model in parent._meta.get_all_related_objects_with_model():
            if (obj.field.creation_counter &lt; 0 or obj.field.rel.parent_link) and obj.model not in parent_list:
                continue
            if not model:
                cache[obj] = parent
            else:
                cache[obj] = model
    for klass in get_models():
        for f in klass._meta.local_fields:
            if f.rel and not isinstance(f.rel.to, str) and self == f.rel.to._meta:
                cache[RelatedObject(f.rel.to, klass, f)] = None
    self._related_objects_cache = cache

</t>
<t tx="newlife.20110623165944.1142">def get_all_related_many_to_many_objects(self, local_only=False):
    try:
        cache = self._related_many_to_many_cache
    except AttributeError:
        cache = self._fill_related_many_to_many_cache()
    if local_only:
        return [k for k, v in cache.items() if not v]
    return cache.keys()

</t>
<t tx="newlife.20110623165944.1143">def get_all_related_m2m_objects_with_model(self):
    """
    Returns a list of (related-m2m-object, model) pairs. Similar to
    get_fields_with_model().
    """
    try:
        cache = self._related_many_to_many_cache
    except AttributeError:
        cache = self._fill_related_many_to_many_cache()
    return cache.items()

</t>
<t tx="newlife.20110623165944.1144">def _fill_related_many_to_many_cache(self):
    cache = SortedDict()
    parent_list = self.get_parent_list()
    for parent in self.parents:
        for obj, model in parent._meta.get_all_related_m2m_objects_with_model():
            if obj.field.creation_counter &lt; 0 and obj.model not in parent_list:
                continue
            if not model:
                cache[obj] = parent
            else:
                cache[obj] = model
    for klass in get_models():
        for f in klass._meta.local_many_to_many:
            if f.rel and not isinstance(f.rel.to, str) and self == f.rel.to._meta:
                cache[RelatedObject(f.rel.to, klass, f)] = None
    if app_cache_ready():
        self._related_many_to_many_cache = cache
    return cache

</t>
<t tx="newlife.20110623165944.1145">def get_base_chain(self, model):
    """
    Returns a list of parent classes leading to 'model' (order from closet
    to most distant ancestor). This has to handle the case were 'model' is
    a granparent or even more distant relation.
    """
    if not self.parents:
        return
    if model in self.parents:
        return [model]
    for parent in self.parents:
        res = parent._meta.get_base_chain(model)
        if res:
            res.insert(0, parent)
            return res
    raise TypeError('%r is not an ancestor of this model'
            % model._meta.module_name)

</t>
<t tx="newlife.20110623165944.1146">def get_parent_list(self):
    """
    Returns a list of all the ancestor of this model as a list. Useful for
    determining if something is an ancestor, regardless of lineage.
    """
    result = set()
    for parent in self.parents:
        result.add(parent)
        result.update(parent._meta.get_parent_list())
    return result

</t>
<t tx="newlife.20110623165944.1147">def get_ancestor_link(self, ancestor):
    """
    Returns the field on the current model which points to the given
    "ancestor". This is possible an indirect link (a pointer to a parent
    model, which points, eventually, to the ancestor). Used when
    constructing table joins for model inheritance.

    Returns None if the model isn't an ancestor of this one.
    """
    if ancestor in self.parents:
        return self.parents[ancestor]
    for parent in self.parents:
        # Tries to get a link field from the immediate parent
        parent_link = parent._meta.get_ancestor_link(ancestor)
        if parent_link:
            # In case of a proxied model, the first link
            # of the chain to the ancestor is that parent
            # links
            return self.parents[parent] or parent_link

</t>
<t tx="newlife.20110623165944.1148">def get_ordered_objects(self):
    "Returns a list of Options objects that are ordered with respect to this object."
    if not hasattr(self, '_ordered_objects'):
        objects = []
        # TODO
        #for klass in get_models(get_app(self.app_label)):
        #    opts = klass._meta
        #    if opts.order_with_respect_to and opts.order_with_respect_to.rel \
        #        and self == opts.order_with_respect_to.rel.to._meta:
        #        objects.append(opts)
        self._ordered_objects = objects
    return self._ordered_objects

</t>
<t tx="newlife.20110623165944.1149">def pk_index(self):
    """
    Returns the index of the primary key field in the self.fields list.
    """
    return self.fields.index(self.pk)
</t>
<t tx="newlife.20110704161758.1190">@language python
@tabwidth -4
@others
@ignore
model_unpickle.__safe_for_unpickle__ = True

if sys.version_info &lt; (2, 5):
    # Prior to Python 2.5, Exception was an old-style class
    def subclass_exception(name, parents, unused):
        return types.ClassType(name, parents, {})
else:
    def subclass_exception(name, parents, module):
        return type(name, parents, {'__module__': module})

@doc　
真正的分析这个东西，</t>
<t tx="newlife.20110704161758.1191">import types
import sys
from itertools import izip

import django.db.models.manager     # Imported to register signal handler.
from django.core.exceptions import ObjectDoesNotExist, MultipleObjectsReturned, FieldError, ValidationError, NON_FIELD_ERRORS
from django.core import validators
from django.db.models.fields import AutoField, FieldDoesNotExist
from django.db.models.fields.related import (OneToOneRel, ManyToOneRel,OneToOneField, add_lazy_relation)
from django.db.models.query import delete_objects, Q
from django.db.models.query_utils import CollectedObjects, DeferredAttribute
from django.db.models.options import Options
from django.db import connections, router, transaction, DatabaseError, DEFAULT_DB_ALIAS
from django.db.models import signals
from django.db.models.loading import register_models, get_model
from django.utils.translation import ugettext_lazy as _
import django.utils.copycompat as copy
from django.utils.functional import curry, update_wrapper
from django.utils.encoding import smart_str, force_unicode
from django.utils.text import get_text_list, capfirst
from django.conf import settings

</t>
<t tx="newlife.20110704161758.1192">class ModelBase(type):
    """
    Metaclass for all models.
    这是所有model的元类
    """
    @others
</t>
<t tx="newlife.20110704161758.1193"># 这就是一个__new__就这么多东西，或许别的类的__new__更多吧，没看过，
#
def __new__(cls, name, bases, attrs):
    super_new = super(ModelBase, cls).__new__
    parents = [b for b in bases if isinstance(b, ModelBase)]
    if not parents:
        # If this isn't a subclass of Model, don't do anything special.
        return super_new(cls, name, bases, attrs)

    # Create the class.
    module = attrs.pop('__module__')
    new_class = super_new(cls, name, bases, {'__module__': module})
    attr_meta = attrs.pop('Meta', None)
    abstract = getattr(attr_meta, 'abstract', False)
    if not attr_meta:
        meta = getattr(new_class, 'Meta', None)
    else:
        meta = attr_meta
    base_meta = getattr(new_class, '_meta', None)

    if getattr(meta, 'app_label', None) is None:
        # Figure out the app_label by looking one level up.
        # For 'django.contrib.sites.models', this would be 'sites'.
        model_module = sys.modules[new_class.__module__]
        kwargs = {"app_label": model_module.__name__.split('.')[-2]}
    else:
        kwargs = {}

    new_class.add_to_class('_meta', Options(meta, **kwargs))
    if not abstract:
        new_class.add_to_class('DoesNotExist', subclass_exception('DoesNotExist',
                tuple(x.DoesNotExist
                        for x in parents if hasattr(x, '_meta') and not x._meta.abstract)
                                or (ObjectDoesNotExist,), module))
        new_class.add_to_class('MultipleObjectsReturned', subclass_exception('MultipleObjectsReturned',
                tuple(x.MultipleObjectsReturned
                        for x in parents if hasattr(x, '_meta') and not x._meta.abstract)
                                or (MultipleObjectsReturned,), module))
        if base_meta and not base_meta.abstract:
            # Non-abstract child classes inherit some attributes from their
            # non-abstract parent (unless an ABC comes before it in the
            # method resolution order).
            if not hasattr(meta, 'ordering'):
                new_class._meta.ordering = base_meta.ordering
            if not hasattr(meta, 'get_latest_by'):
                new_class._meta.get_latest_by = base_meta.get_latest_by

    is_proxy = new_class._meta.proxy

    if getattr(new_class, '_default_manager', None):
        if not is_proxy:
            # Multi-table inheritance doesn't inherit default manager from
            # parents.
            new_class._default_manager = None
            new_class._base_manager = None
        else:
            # Proxy classes do inherit parent's default manager, if none is
            # set explicitly.
            new_class._default_manager = new_class._default_manager._copy_to_model(new_class)
            new_class._base_manager = new_class._base_manager._copy_to_model(new_class)

    # Bail out early if we have already created this class.
    m = get_model(new_class._meta.app_label, name, False)
    if m is not None:
        return m

    # Add all attributes to the class.
    for obj_name, obj in attrs.items():
        new_class.add_to_class(obj_name, obj)

    # All the fields of any type declared on this model
    new_fields = new_class._meta.local_fields + \
                 new_class._meta.local_many_to_many + \
                 new_class._meta.virtual_fields
    field_names = set([f.name for f in new_fields])

    # Basic setup for proxy models.
    if is_proxy:
        base = None
        for parent in [cls for cls in parents if hasattr(cls, '_meta')]:
            if parent._meta.abstract:
                if parent._meta.fields:
                    raise TypeError("Abstract base class containing model fields not permitted for proxy model '%s'." % name)
                else:
                    continue
            if base is not None:
                raise TypeError("Proxy model '%s' has more than one non-abstract model base class." % name)
            else:
                base = parent
        if base is None:
                raise TypeError("Proxy model '%s' has no non-abstract model base class." % name)
        if (new_class._meta.local_fields or
                new_class._meta.local_many_to_many):
            raise FieldError("Proxy model '%s' contains model fields." % name)
        while base._meta.proxy:
            base = base._meta.proxy_for_model
        new_class._meta.setup_proxy(base)

    # Do the appropriate setup for any model parents.
    o2o_map = dict([(f.rel.to, f) for f in new_class._meta.local_fields
            if isinstance(f, OneToOneField)])

    for base in parents:
        original_base = base
        if not hasattr(base, '_meta'):
            # Things without _meta aren't functional models, so they're
            # uninteresting parents.
            continue

        parent_fields = base._meta.local_fields + base._meta.local_many_to_many
        # Check for clashes between locally declared fields and those
        # on the base classes (we cannot handle shadowed fields at the
        # moment).
        for field in parent_fields:
            if field.name in field_names:
                raise FieldError('Local field %r in class %r clashes '
                                 'with field of similar name from '
                                 'base class %r' %
                                    (field.name, name, base.__name__))
        if not base._meta.abstract:
            # Concrete classes...
            while base._meta.proxy:
                # Skip over a proxy class to the "real" base it proxies.
                base = base._meta.proxy_for_model
            if base in o2o_map:
                field = o2o_map[base]
            elif not is_proxy:
                attr_name = '%s_ptr' % base._meta.module_name
                field = OneToOneField(base, name=attr_name,
                        auto_created=True, parent_link=True)
                new_class.add_to_class(attr_name, field)
            else:
                field = None
            new_class._meta.parents[base] = field
        else:
            # .. and abstract ones.
            for field in parent_fields:
                new_class.add_to_class(field.name, copy.deepcopy(field))

            # Pass any non-abstract parent classes onto child.
            new_class._meta.parents.update(base._meta.parents)

        # Inherit managers from the abstract base classes.
        new_class.copy_managers(base._meta.abstract_managers)

        # Proxy models inherit the non-abstract managers from their base,
        # unless they have redefined any of them.
        if is_proxy:
            new_class.copy_managers(original_base._meta.concrete_managers)

        # Inherit virtual fields (like GenericForeignKey) from the parent
        # class
        for field in base._meta.virtual_fields:
            if base._meta.abstract and field.name in field_names:
                raise FieldError('Local field %r in class %r clashes '\
                                 'with field of similar name from '\
                                 'abstract base class %r' % \
                                    (field.name, name, base.__name__))
            new_class.add_to_class(field.name, copy.deepcopy(field))

    if abstract:
        # Abstract base models can't be instantiated and don't appear in
        # the list of models for an app. We do the final setup for them a
        # little differently from normal models.
        attr_meta.abstract = False
        new_class.Meta = attr_meta
        return new_class

    new_class._prepare()
    register_models(new_class._meta.app_label, new_class)

    # Because of the way imports happen (recursively), we may or may not be
    # the first time this model tries to register with the framework. There
    # should only be one class for each model, so we always return the
    # registered version.
    return get_model(new_class._meta.app_label, name, False)

</t>
<t tx="newlife.20110704161758.1194">def copy_managers(cls, base_managers):
    # This is in-place sorting of an Options attribute, but that's fine.
    base_managers.sort()
    for _, mgr_name, manager in base_managers:
        val = getattr(cls, mgr_name, None)
        if not val or val is manager:
            new_manager = manager._copy_to_model(cls)
            cls.add_to_class(mgr_name, new_manager)

</t>
<t tx="newlife.20110704161758.1195">def add_to_class(cls, name, value):
    if hasattr(value, 'contribute_to_class'):
        value.contribute_to_class(cls, name)
    else:
        setattr(cls, name, value)

</t>
<t tx="newlife.20110704161758.1196">def _prepare(cls):
    """
    Creates some methods once self._meta has been populated.
    """
    opts = cls._meta
    opts._prepare(cls)

    if opts.order_with_respect_to:
        cls.get_next_in_order = curry(cls._get_next_or_previous_in_order, is_next=True)
        cls.get_previous_in_order = curry(cls._get_next_or_previous_in_order, is_next=False)
        # defer creating accessors on the foreign class until we are
        # certain it has been created
        def make_foreign_order_accessors(field, model, cls):
            setattr(
                field.rel.to,
                'get_%s_order' % cls.__name__.lower(),
                curry(method_get_order, cls)
            )
            setattr(
                field.rel.to,
                'set_%s_order' % cls.__name__.lower(),
                curry(method_set_order, cls)
            )
        add_lazy_relation(
            cls,
            opts.order_with_respect_to,
            opts.order_with_respect_to.rel.to,
            make_foreign_order_accessors
        )

    # Give the class a docstring -- its definition.
    if cls.__doc__ is None:
        cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join([f.attname for f in opts.fields]))

    if hasattr(cls, 'get_absolute_url'):
        cls.get_absolute_url = update_wrapper(curry(get_absolute_url, opts, cls.get_absolute_url),
                                              cls.get_absolute_url)

    signals.class_prepared.send(sender=cls)

</t>
<t tx="newlife.20110704161758.1197">class ModelState(object):
    """
    A class for storing instance state
    这个存储对象装提案？
    """
    @others
</t>
<t tx="newlife.20110704161758.1198">def __init__(self, db=None):
    self.db = db
    # If true, uniqueness validation checks will consider this a new, as-yet-unsaved object.
    # Necessary for correct validation of new instances of objects with explicit (non-auto) PKs.
    # This impacts validation only; it has no effect on the actual save.
    self.adding = True

</t>
<t tx="newlife.20110704161758.1199">class Model(object):
    __metaclass__ = ModelBase
    _deferred = False

    @others
</t>
<t tx="newlife.20110704161758.1200">def __init__(self, *args, **kwargs):
    signals.pre_init.send(sender=self.__class__, args=args, kwargs=kwargs)

    # Set up the storage for instance state
    self._state = ModelState()

    # There is a rather weird disparity here; if kwargs, it's set, then args
    # overrides it. It should be one or the other; don't duplicate the work
    # The reason for the kwargs check is that standard iterator passes in by
    # args, and instantiation for iteration is 33% faster.
    args_len = len(args)
    if args_len &gt; len(self._meta.fields):
        # Daft, but matches old exception sans the err msg.
        raise IndexError("Number of args exceeds number of fields")

    fields_iter = iter(self._meta.fields)
    if not kwargs:
        # The ordering of the izip calls matter - izip throws StopIteration
        # when an iter throws it. So if the first iter throws it, the second
        # is *not* consumed. We rely on this, so don't change the order
        # without changing the logic.
        for val, field in izip(args, fields_iter):
            setattr(self, field.attname, val)
    else:
        # Slower, kwargs-ready version.
        for val, field in izip(args, fields_iter):
            setattr(self, field.attname, val)
            kwargs.pop(field.name, None)
            # Maintain compatibility with existing calls.
            if isinstance(field.rel, ManyToOneRel):
                kwargs.pop(field.attname, None)

    # Now we're left with the unprocessed fields that *must* come from
    # keywords, or default.

    for field in fields_iter:
        is_related_object = False
        # This slightly odd construct is so that we can access any
        # data-descriptor object (DeferredAttribute) without triggering its
        # __get__ method.
        if (field.attname not in kwargs and
                isinstance(self.__class__.__dict__.get(field.attname), DeferredAttribute)):
            # This field will be populated on request.
            continue
        if kwargs:
            if isinstance(field.rel, ManyToOneRel):
                try:
                    # Assume object instance was passed in.
                    rel_obj = kwargs.pop(field.name)
                    is_related_object = True
                except KeyError:
                    try:
                        # Object instance wasn't passed in -- must be an ID.
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        val = field.get_default()
                else:
                    # Object instance was passed in. Special case: You can
                    # pass in "None" for related objects if it's allowed.
                    if rel_obj is None and field.null:
                        val = None
            else:
                try:
                    val = kwargs.pop(field.attname)
                except KeyError:
                    # This is done with an exception rather than the
                    # default argument on pop because we don't want
                    # get_default() to be evaluated, and then not used.
                    # Refs #12057.
                    val = field.get_default()
        else:
            val = field.get_default()
        if is_related_object:
            # If we are passed a related instance, set it using the
            # field.name instead of field.attname (e.g. "user" instead of
            # "user_id") so that the object gets properly cached (and type
            # checked) by the RelatedObjectDescriptor.
            setattr(self, field.name, rel_obj)
        else:
            setattr(self, field.attname, val)

    if kwargs:
        for prop in kwargs.keys():
            try:
                if isinstance(getattr(self.__class__, prop), property):
                    setattr(self, prop, kwargs.pop(prop))
            except AttributeError:
                pass
        if kwargs:
            raise TypeError("'%s' is an invalid keyword argument for this function" % kwargs.keys()[0])
    super(Model, self).__init__()
    signals.post_init.send(sender=self.__class__, instance=self)

</t>
<t tx="newlife.20110704161758.1201">def __repr__(self):
    try:
        u = unicode(self)
    except (UnicodeEncodeError, UnicodeDecodeError):
        u = '[Bad Unicode data]'
    return smart_str(u'&lt;%s: %s&gt;' % (self.__class__.__name__, u))

</t>
<t tx="newlife.20110704161758.1202">def __str__(self):
    if hasattr(self, '__unicode__'):
        return force_unicode(self).encode('utf-8')
    return '%s object' % self.__class__.__name__

</t>
<t tx="newlife.20110704161758.1203">def __eq__(self, other):
    return isinstance(other, self.__class__) and self._get_pk_val() == other._get_pk_val()

</t>
<t tx="newlife.20110704161758.1204">def __ne__(self, other):
    return not self.__eq__(other)

</t>
<t tx="newlife.20110704161758.1205">def __hash__(self):
    return hash(self._get_pk_val())

</t>
<t tx="newlife.20110704161758.1206">def __reduce__(self):
    """
    Provide pickling support. Normally, this just dispatches to Python's
    standard handling. However, for models with deferred field loading, we
    need to do things manually, as they're dynamically created classes and
    only module-level classes can be pickled by the default path.
    """
    data = self.__dict__
    model = self.__class__
    # The obvious thing to do here is to invoke super().__reduce__()
    # for the non-deferred case. Don't do that.
    # On Python 2.4, there is something wierd with __reduce__,
    # and as a result, the super call will cause an infinite recursion.
    # See #10547 and #12121.
    defers = []
    pk_val = None
    if self._deferred:
        from django.db.models.query_utils import deferred_class_factory
        factory = deferred_class_factory
        for field in self._meta.fields:
            if isinstance(self.__class__.__dict__.get(field.attname),
                    DeferredAttribute):
                defers.append(field.attname)
                if pk_val is None:
                    # The pk_val and model values are the same for all
                    # DeferredAttribute classes, so we only need to do this
                    # once.
                    obj = self.__class__.__dict__[field.attname]
                    model = obj.model_ref()
    else:
        factory = simple_class_factory
    return (model_unpickle, (model, defers, factory), data)

</t>
<t tx="newlife.20110704161758.1207">def _get_pk_val(self, meta=None):
    if not meta:
        meta = self._meta
    return getattr(self, meta.pk.attname)

</t>
<t tx="newlife.20110704161758.1208">def _set_pk_val(self, value):
    return setattr(self, self._meta.pk.attname, value)

</t>
<t tx="newlife.20110704161758.1209">pk = property(_get_pk_val, _set_pk_val)
#这是为啥每个model都有pk这个属性。
def serializable_value(self, field_name):
    """
    Returns the value of the field name for this instance. If the field is
    a foreign key, returns the id value, instead of the object. If there's
    no Field object with this name on the model, the model attribute's
    value is returned directly.

    Used to serialize a field's value (in the serializer, or form output,
    for example). Normally, you would just access the attribute directly
    and not use this method.
    """
    try:
        field = self._meta.get_field_by_name(field_name)[0]
    except FieldDoesNotExist:
        return getattr(self, field_name)
    return getattr(self, field.attname)

</t>
<t tx="newlife.20110704161758.1210">def save(self, force_insert=False, force_update=False, using=None):
    """
    Saves the current instance. Override this in a subclass if you want to
    control the saving process.

    The 'force_insert' and 'force_update' parameters can be used to insist
    that the "save" must be an SQL insert or update (or equivalent for
    non-SQL backends), respectively. Normally, they should not be set.
    """
    if force_insert and force_update:
        raise ValueError("Cannot force both insert and updating in model saving.")
    self.save_base(using=using, force_insert=force_insert, force_update=force_update)

</t>
<t tx="newlife.20110704161758.1211">save.alters_data = True

def save_base(self, raw=False, cls=None, origin=None, force_insert=False,
        force_update=False, using=None):
    """
    Does the heavy-lifting involved in saving. Subclasses shouldn't need to
    override this method. It's separate from save() in order to hide the
    need for overrides of save() to pass around internal-only parameters
    ('raw', 'cls', and 'origin').
    """
    using = using or router.db_for_write(self.__class__, instance=self)
    connection = connections[using]
    assert not (force_insert and force_update)
    if cls is None:
        cls = self.__class__
        meta = cls._meta
        if not meta.proxy:
            origin = cls
    else:
        meta = cls._meta

    if origin and not meta.auto_created:
        signals.pre_save.send(sender=origin, instance=self, raw=raw)

    # If we are in a raw save, save the object exactly as presented.
    # That means that we don't try to be smart about saving attributes
    # that might have come from the parent class - we just save the
    # attributes we have been given to the class we have been given.
    # We also go through this process to defer the save of proxy objects
    # to their actual underlying model.
    if not raw or meta.proxy:
        if meta.proxy:
            org = cls
        else:
            org = None
        for parent, field in meta.parents.items():
            # At this point, parent's primary key field may be unknown
            # (for example, from administration form which doesn't fill
            # this field). If so, fill it.
            if field and getattr(self, parent._meta.pk.attname) is None and getattr(self, field.attname) is not None:
                setattr(self, parent._meta.pk.attname, getattr(self, field.attname))

            self.save_base(cls=parent, origin=org, using=using)

            if field:
                setattr(self, field.attname, self._get_pk_val(parent._meta))
        if meta.proxy:
            return

    if not meta.proxy:
        non_pks = [f for f in meta.local_fields if not f.primary_key]

        # First, try an UPDATE. If that doesn't update anything, do an INSERT.
        pk_val = self._get_pk_val(meta)
        pk_set = pk_val is not None
        record_exists = True
        manager = cls._base_manager
        if pk_set:
            # Determine whether a record with the primary key already exists.
            if (force_update or (not force_insert and
                    manager.using(using).filter(pk=pk_val).exists())):
                # It does already exist, so do an UPDATE.
                if force_update or non_pks:
                    values = [(f, None, (raw and getattr(self, f.attname) or f.pre_save(self, False))) for f in non_pks]
                    rows = manager.using(using).filter(pk=pk_val)._update(values)
                    if force_update and not rows:
                        raise DatabaseError("Forced update did not affect any rows.")
            else:
                record_exists = False
        if not pk_set or not record_exists:
            if meta.order_with_respect_to:
                # If this is a model with an order_with_respect_to
                # autopopulate the _order field
                field = meta.order_with_respect_to
                order_value = manager.using(using).filter(**{field.name: getattr(self, field.attname)}).count()
                setattr(self, '_order', order_value)

            if not pk_set:
                if force_update:
                    raise ValueError("Cannot force an update in save() with no primary key.")
                values = [(f, f.get_db_prep_save(raw and getattr(self, f.attname) or f.pre_save(self, True), connection=connection))
                    for f in meta.local_fields if not isinstance(f, AutoField)]
            else:
                values = [(f, f.get_db_prep_save(raw and getattr(self, f.attname) or f.pre_save(self, True), connection=connection))
                    for f in meta.local_fields]

            record_exists = False

            update_pk = bool(meta.has_auto_field and not pk_set)
            if values:
                # Create a new record.
                result = manager._insert(values, return_id=update_pk, using=using)
            else:
                # Create a new record with defaults for everything.
                result = manager._insert([(meta.pk, connection.ops.pk_default_value())], return_id=update_pk, raw_values=True, using=using)

            if update_pk:
                setattr(self, meta.pk.attname, result)
        transaction.commit_unless_managed(using=using)

    # Store the database on which the object was saved
    self._state.db = using
    # Once saved, this is no longer a to-be-added instance.
    self._state.adding = False

    # Signal that the save is complete
    if origin and not meta.auto_created:
        signals.post_save.send(sender=origin, instance=self,
            created=(not record_exists), raw=raw)


</t>
<t tx="newlife.20110704161758.1212">save_base.alters_data = True

def _collect_sub_objects(self, seen_objs, parent=None, nullable=False):
    """
    Recursively populates seen_objs with all objects related to this
    object.

    When done, seen_objs.items() will be in the format:
        [(model_class, {pk_val: obj, pk_val: obj, ...}),
         (model_class, {pk_val: obj, pk_val: obj, ...}), ...]
    """
    pk_val = self._get_pk_val()
    if seen_objs.add(self.__class__, pk_val, self,
                     type(parent), parent, nullable):
        return

    for related in self._meta.get_all_related_objects():
        rel_opts_name = related.get_accessor_name()
        if not related.field.rel.multiple:
            try:
                sub_obj = getattr(self, rel_opts_name)
            except ObjectDoesNotExist:
                pass
            else:
                sub_obj._collect_sub_objects(seen_objs, self, related.field.null)
        else:
            # To make sure we can access all elements, we can't use the
            # normal manager on the related object. So we work directly
            # with the descriptor object.
            for cls in self.__class__.mro():
                if rel_opts_name in cls.__dict__:
                    rel_descriptor = cls.__dict__[rel_opts_name]
                    break
            else:
                # in the case of a hidden fkey just skip it, it'll get
                # processed as an m2m
                if not related.field.rel.is_hidden():
                    raise AssertionError("Should never get here.")
                else:
                    continue
            delete_qs = rel_descriptor.delete_manager(self).all()
            for sub_obj in delete_qs:
                sub_obj._collect_sub_objects(seen_objs, self, related.field.null)

    for related in self._meta.get_all_related_many_to_many_objects():
        if related.field.rel.through:
            db = router.db_for_write(related.field.rel.through, instance=self)
            opts = related.field.rel.through._meta
            reverse_field_name = related.field.m2m_reverse_field_name()
            nullable = opts.get_field(reverse_field_name).null
            filters = {reverse_field_name: self}
            for sub_obj in related.field.rel.through._base_manager.using(db).filter(**filters):
                sub_obj._collect_sub_objects(seen_objs, self, nullable)

    for f in self._meta.many_to_many:
        if f.rel.through:
            db = router.db_for_write(f.rel.through, instance=self)
            opts = f.rel.through._meta
            field_name = f.m2m_field_name()
            nullable = opts.get_field(field_name).null
            filters = {field_name: self}
            for sub_obj in f.rel.through._base_manager.using(db).filter(**filters):
                sub_obj._collect_sub_objects(seen_objs, self, nullable)
        else:
            # m2m-ish but with no through table? GenericRelation: cascade delete
            for sub_obj in f.value_from_object(self).all():
                # Generic relations not enforced by db constraints, thus we can set
                # nullable=True, order does not matter
                sub_obj._collect_sub_objects(seen_objs, self, True)

    # Handle any ancestors (for the model-inheritance case). We do this by
    # traversing to the most remote parent classes -- those with no parents
    # themselves -- and then adding those instances to the collection. That
    # will include all the child instances down to "self".
    parent_stack = [p for p in self._meta.parents.values() if p is not None]
    while parent_stack:
        link = parent_stack.pop()
        parent_obj = getattr(self, link.name)
        if parent_obj._meta.parents:
            parent_stack.extend(parent_obj._meta.parents.values())
            continue
        # At this point, parent_obj is base class (no ancestor models). So
        # delete it and all its descendents.
        parent_obj._collect_sub_objects(seen_objs)

</t>
<t tx="newlife.20110704161758.1213">def delete(self, using=None):
    using = using or router.db_for_write(self.__class__, instance=self)
    assert self._get_pk_val() is not None, "%s object can't be deleted because its %s attribute is set to None." % (self._meta.object_name, self._meta.pk.attname)

    # Find all the objects than need to be deleted.
    seen_objs = CollectedObjects()
    self._collect_sub_objects(seen_objs)

    # Actually delete the objects.
    delete_objects(seen_objs, using)

</t>
<t tx="newlife.20110704161758.1214">delete.alters_data = True

def _get_FIELD_display(self, field):
    value = getattr(self, field.attname)
    return force_unicode(dict(field.flatchoices).get(value, value), strings_only=True)

</t>
<t tx="newlife.20110704161758.1215">def _get_next_or_previous_by_FIELD(self, field, is_next, **kwargs):
    op = is_next and 'gt' or 'lt'
    order = not is_next and '-' or ''
    param = smart_str(getattr(self, field.attname))
    q = Q(**{'%s__%s' % (field.name, op): param})
    q = q|Q(**{field.name: param, 'pk__%s' % op: self.pk})
    qs = self.__class__._default_manager.using(self._state.db).filter(**kwargs).filter(q).order_by('%s%s' % (order, field.name), '%spk' % order)
    try:
        return qs[0]
    except IndexError:
        raise self.DoesNotExist("%s matching query does not exist." % self.__class__._meta.object_name)

</t>
<t tx="newlife.20110704161758.1216">def _get_next_or_previous_in_order(self, is_next):
    cachename = "__%s_order_cache" % is_next
    if not hasattr(self, cachename):
        op = is_next and 'gt' or 'lt'
        order = not is_next and '-_order' or '_order'
        order_field = self._meta.order_with_respect_to
        obj = self._default_manager.filter(**{
            order_field.name: getattr(self, order_field.attname)
        }).filter(**{
            '_order__%s' % op: self._default_manager.values('_order').filter(**{
                self._meta.pk.name: self.pk
            })
        }).order_by(order)[:1].get()
        setattr(self, cachename, obj)
    return getattr(self, cachename)

</t>
<t tx="newlife.20110704161758.1217">def prepare_database_save(self, unused):
    return self.pk

</t>
<t tx="newlife.20110704161758.1218">def clean(self):
    """
    Hook for doing any extra model-wide validation after clean() has been
    called on every field by self.clean_fields. Any ValidationError raised
    by this method will not be associated with a particular field; it will
    have a special-case association with the field defined by NON_FIELD_ERRORS.
    """
    pass

</t>
<t tx="newlife.20110704161758.1219">def validate_unique(self, exclude=None):
    """
    Checks unique constraints on the model and raises ``ValidationError``
    if any failed.
    """
    unique_checks, date_checks = self._get_unique_checks(exclude=exclude)

    errors = self._perform_unique_checks(unique_checks)
    date_errors = self._perform_date_checks(date_checks)

    for k, v in date_errors.items():
        errors.setdefault(k, []).extend(v)

    if errors:
        raise ValidationError(errors)

</t>
<t tx="newlife.20110704161758.1220">def _get_unique_checks(self, exclude=None):
    """
    Gather a list of checks to perform. Since validate_unique could be
    called from a ModelForm, some fields may have been excluded; we can't
    perform a unique check on a model that is missing fields involved
    in that check.
    Fields that did not validate should also be excluded, but they need
    to be passed in via the exclude argument.
    """
    if exclude is None:
        exclude = []
    unique_checks = []

    unique_togethers = [(self.__class__, self._meta.unique_together)]
    for parent_class in self._meta.parents.keys():
        if parent_class._meta.unique_together:
            unique_togethers.append((parent_class, parent_class._meta.unique_together))

    for model_class, unique_together in unique_togethers:
        for check in unique_together:
            for name in check:
                # If this is an excluded field, don't add this check.
                if name in exclude:
                    break
            else:
                unique_checks.append((model_class, tuple(check)))

    # These are checks for the unique_for_&lt;date/year/month&gt;.
    date_checks = []

    # Gather a list of checks for fields declared as unique and add them to
    # the list of checks.

    fields_with_class = [(self.__class__, self._meta.local_fields)]
    for parent_class in self._meta.parents.keys():
        fields_with_class.append((parent_class, parent_class._meta.local_fields))

    for model_class, fields in fields_with_class:
        for f in fields:
            name = f.name
            if name in exclude:
                continue
            if f.unique:
                unique_checks.append((model_class, (name,)))
            if f.unique_for_date and f.unique_for_date not in exclude:
                date_checks.append((model_class, 'date', name, f.unique_for_date))
            if f.unique_for_year and f.unique_for_year not in exclude:
                date_checks.append((model_class, 'year', name, f.unique_for_year))
            if f.unique_for_month and f.unique_for_month not in exclude:
                date_checks.append((model_class, 'month', name, f.unique_for_month))
    return unique_checks, date_checks

</t>
<t tx="newlife.20110704161758.1221">def _perform_unique_checks(self, unique_checks):
    errors = {}

    for model_class, unique_check in unique_checks:
        # Try to look up an existing object with the same values as this
        # object's values for all the unique field.

        lookup_kwargs = {}
        for field_name in unique_check:
            f = self._meta.get_field(field_name)
            lookup_value = getattr(self, f.attname)
            if lookup_value is None:
                # no value, skip the lookup
                continue
            if f.primary_key and not self._state.adding:
                # no need to check for unique primary key when editing
                continue
            lookup_kwargs[str(field_name)] = lookup_value

        # some fields were skipped, no reason to do the check
        if len(unique_check) != len(lookup_kwargs.keys()):
            continue

        qs = model_class._default_manager.filter(**lookup_kwargs)

        # Exclude the current object from the query if we are editing an
        # instance (as opposed to creating a new one)
        if not self._state.adding and self.pk is not None:
            qs = qs.exclude(pk=self.pk)

        if qs.exists():
            if len(unique_check) == 1:
                key = unique_check[0]
            else:
                key = NON_FIELD_ERRORS
            errors.setdefault(key, []).append(self.unique_error_message(model_class, unique_check))

    return errors

</t>
<t tx="newlife.20110704161758.1222">def _perform_date_checks(self, date_checks):
    errors = {}
    for model_class, lookup_type, field, unique_for in date_checks:
        lookup_kwargs = {}
        # there's a ticket to add a date lookup, we can remove this special
        # case if that makes it's way in
        date = getattr(self, unique_for)
        if date is None:
            continue
        if lookup_type == 'date':
            lookup_kwargs['%s__day' % unique_for] = date.day
            lookup_kwargs['%s__month' % unique_for] = date.month
            lookup_kwargs['%s__year' % unique_for] = date.year
        else:
            lookup_kwargs['%s__%s' % (unique_for, lookup_type)] = getattr(date, lookup_type)
        lookup_kwargs[field] = getattr(self, field)

        qs = model_class._default_manager.filter(**lookup_kwargs)
        # Exclude the current object from the query if we are editing an
        # instance (as opposed to creating a new one)
        if not self._state.adding and self.pk is not None:
            qs = qs.exclude(pk=self.pk)

        if qs.exists():
            errors.setdefault(field, []).append(
                self.date_error_message(lookup_type, field, unique_for)
            )
    return errors

</t>
<t tx="newlife.20110704161758.1223">def date_error_message(self, lookup_type, field, unique_for):
    opts = self._meta
    return _(u"%(field_name)s must be unique for %(date_field)s %(lookup)s.") % {
        'field_name': unicode(capfirst(opts.get_field(field).verbose_name)),
        'date_field': unicode(capfirst(opts.get_field(unique_for).verbose_name)),
        'lookup': lookup_type,
    }

</t>
<t tx="newlife.20110704161758.1224">def unique_error_message(self, model_class, unique_check):
    opts = model_class._meta
    model_name = capfirst(opts.verbose_name)

    # A unique field
    if len(unique_check) == 1:
        field_name = unique_check[0]
        field_label = capfirst(opts.get_field(field_name).verbose_name)
        # Insert the error into the error dict, very sneaky
        return _(u"%(model_name)s with this %(field_label)s already exists.") %  {
            'model_name': unicode(model_name),
            'field_label': unicode(field_label)
        }
    # unique_together
    else:
        field_labels = map(lambda f: capfirst(opts.get_field(f).verbose_name), unique_check)
        field_labels = get_text_list(field_labels, _('and'))
        return _(u"%(model_name)s with this %(field_label)s already exists.") %  {
            'model_name': unicode(model_name),
            'field_label': unicode(field_labels)
        }

</t>
<t tx="newlife.20110704161758.1225">def full_clean(self, exclude=None):
    """
    Calls clean_fields, clean, and validate_unique, on the model,
    and raises a ``ValidationError`` for any errors that occured.
    """
    errors = {}
    if exclude is None:
        exclude = []

    try:
        self.clean_fields(exclude=exclude)
    except ValidationError, e:
        errors = e.update_error_dict(errors)

    # Form.clean() is run even if other validation fails, so do the
    # same with Model.clean() for consistency.
    try:
        self.clean()
    except ValidationError, e:
        errors = e.update_error_dict(errors)

    # Run unique checks, but only for fields that passed validation.
    for name in errors.keys():
        if name != NON_FIELD_ERRORS and name not in exclude:
            exclude.append(name)
    try:
        self.validate_unique(exclude=exclude)
    except ValidationError, e:
        errors = e.update_error_dict(errors)

    if errors:
        raise ValidationError(errors)

</t>
<t tx="newlife.20110704161758.1226">def clean_fields(self, exclude=None):
    """
    Cleans all fields and raises a ValidationError containing message_dict
    of all validation errors if any occur.
    """
    if exclude is None:
        exclude = []

    errors = {}
    for f in self._meta.fields:
        if f.name in exclude:
            continue
        # Skip validation for empty fields with blank=True. The developer
        # is responsible for making sure they have a valid value.
        raw_value = getattr(self, f.attname)
        if f.blank and raw_value in validators.EMPTY_VALUES:
            continue
        try:
            setattr(self, f.attname, f.clean(raw_value, self))
        except ValidationError, e:
            errors[f.name] = e.messages

    if errors:
        raise ValidationError(errors)


</t>
<t tx="newlife.20110704161758.1227">############################################
# HELPER FUNCTIONS (CURRIED MODEL METHODS) #
############################################

# ORDERING METHODS #########################

def method_set_order(ordered_obj, self, id_list, using=None):
    if using is None:
        using = DEFAULT_DB_ALIAS
    rel_val = getattr(self, ordered_obj._meta.order_with_respect_to.rel.field_name)
    order_name = ordered_obj._meta.order_with_respect_to.name
    # FIXME: It would be nice if there was an "update many" version of update
    # for situations like this.
    for i, j in enumerate(id_list):
        ordered_obj.objects.filter(**{'pk': j, order_name: rel_val}).update(_order=i)
    transaction.commit_unless_managed(using=using)


</t>
<t tx="newlife.20110704161758.1228">def method_get_order(ordered_obj, self):
    rel_val = getattr(self, ordered_obj._meta.order_with_respect_to.rel.field_name)
    order_name = ordered_obj._meta.order_with_respect_to.name
    pk_name = ordered_obj._meta.pk.name
    return [r[pk_name] for r in
            ordered_obj.objects.filter(**{order_name: rel_val}).values(pk_name)]


</t>
<t tx="newlife.20110704161758.1229">##############################################
# HELPER FUNCTIONS (CURRIED MODEL FUNCTIONS) #
##############################################

def get_absolute_url(opts, func, self, *args, **kwargs):
    return settings.ABSOLUTE_URL_OVERRIDES.get('%s.%s' % (opts.app_label, opts.module_name), func)(self, *args, **kwargs)


</t>
<t tx="newlife.20110704161758.1230">########
# MISC #
########

class Empty(object):
    pass

</t>
<t tx="newlife.20110704161758.1231">def simple_class_factory(model, attrs):
    """Used to unpickle Models without deferred fields.

    We need to do this the hard way, rather than just using
    the default __reduce__ implementation, because of a
    __deepcopy__ problem in Python 2.4
    """
    return model

</t>
<t tx="newlife.20110704161758.1232">def model_unpickle(model, attrs, factory):
    """
    Used to unpickle Model subclasses with deferred fields.
    """
    cls = factory(model, attrs)
    return cls.__new__(cls)
</t>
</tnodes>
</leo_file>
