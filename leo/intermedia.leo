<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="newlife.20101201170601.1255"><vh>@chapters</vh></v>
<v t="newlife.20101201170601.1477"><vh>introduction</vh></v>
<v t="newlife.20101201170601.1254" a="E"><vh>NewHeadline</vh>
<v t="newlife.20101201170601.1256"><vh>@file /home/newlife/bottle/bottle.py</vh>
<v t="newlife.20101201170601.1257"><vh>bottle declarations</vh></v>
<v t="newlife.20101201170601.1258"><vh>tob</vh></v>
<v t="newlife.20101201170601.1259"><vh>depr</vh></v>
<v t="newlife.20101201170601.1260"><vh>makelist</vh></v>
<v t="newlife.20101201170601.1261"><vh>class BottleException</vh></v>
<v t="newlife.20101201170601.1262"><vh>class HTTPResponse</vh>
<v t="newlife.20101201170601.1263"><vh>__init__</vh></v>
<v t="newlife.20101201170601.1264"><vh>apply</vh></v>
</v>
<v t="newlife.20101201170601.1265"><vh>class HTTPError</vh>
<v t="newlife.20101201170601.1266"><vh>__init__</vh></v>
<v t="newlife.20101201170601.1267"><vh>__repr__</vh></v>
</v>
<v t="newlife.20101201170601.1268"><vh>class RouteError</vh></v>
<v t="newlife.20101201170601.1269"><vh>class RouteSyntaxError</vh></v>
<v t="newlife.20101201170601.1270"><vh>class RouteBuildError</vh></v>
<v t="newlife.20101201170601.1271"><vh>class Route</vh>
<v t="newlife.20101201170601.1272"><vh>__init__</vh></v>
<v t="newlife.20101201170601.1273"><vh>group_re</vh></v>
<v t="newlife.20101201170601.1274"><vh>flat_re</vh></v>
<v t="newlife.20101201170601.1275"><vh>format_str</vh></v>
<v t="newlife.20101201170601.1276"><vh>static</vh></v>
<v t="newlife.20101201170601.1277"><vh>__repr__</vh></v>
<v t="newlife.20101201170601.1278"><vh>__eq__</vh></v>
</v>
<v t="newlife.20101201170601.1279"><vh>class Router</vh>
<v t="newlife.20101201170601.1280"><vh>__init__</vh></v>
<v t="newlife.20101201170601.1281"><vh>add</vh></v>
<v t="newlife.20101201170601.1282"><vh>get_route</vh></v>
<v t="newlife.20101201170601.1283"><vh>match</vh></v>
<v t="newlife.20101201170601.1284"><vh>build</vh></v>
<v t="newlife.20101201170601.1285"><vh>compile</vh></v>
<v t="newlife.20101201170601.1286"><vh>__eq__</vh></v>
</v>
<v t="newlife.20101201170601.1287"><vh>class Bottle</vh>
<v t="newlife.20101201170601.1288"><vh>__init__</vh></v>
<v t="newlife.20101201170601.1289"><vh>optimize</vh></v>
<v t="newlife.20101201170601.1290"><vh>mount</vh></v>
<v t="newlife.20101201170601.1291"><vh>add_filter</vh></v>
<v t="newlife.20101201170601.1292"><vh>match_url</vh></v>
<v t="newlife.20101201170601.1293"><vh>get_url</vh></v>
<v t="newlife.20101201170601.1294"><vh>route</vh></v>
<v t="newlife.20101201170601.1295"><vh>_add_hook_wrapper</vh></v>
<v t="newlife.20101201170601.1296"><vh>get</vh></v>
<v t="newlife.20101201170601.1297"><vh>post</vh></v>
<v t="newlife.20101201170601.1298"><vh>put</vh></v>
<v t="newlife.20101201170601.1299"><vh>delete</vh></v>
<v t="newlife.20101201170601.1300"><vh>error</vh></v>
<v t="newlife.20101201170601.1301"><vh>hook</vh></v>
<v t="newlife.20101201170601.1302"><vh>add_hook</vh></v>
<v t="newlife.20101201170601.1303"><vh>remove_hook</vh></v>
<v t="newlife.20101201170601.1304"><vh>handle</vh></v>
<v t="newlife.20101201170601.1305"><vh>_cast</vh></v>
<v t="newlife.20101201170601.1306"><vh>wsgi</vh></v>
<v t="newlife.20101201170601.1307"><vh>__call__</vh></v>
</v>
<v t="newlife.20101201170601.1308"><vh>class Request</vh>
<v t="newlife.20101201170601.1309"><vh>__init__</vh></v>
<v t="newlife.20101201170601.1310"><vh>bind</vh></v>
<v t="newlife.20101201170601.1311"><vh>_environ</vh></v>
<v t="newlife.20101201170601.1312"><vh>copy</vh></v>
<v t="newlife.20101201170601.1313"><vh>path_shift</vh></v>
<v t="newlife.20101201170601.1314"><vh>__getitem__</vh></v>
<v t="newlife.20101201170601.1315"><vh>__delitem__</vh></v>
<v t="newlife.20101201170601.1316"><vh>__iter__</vh></v>
<v t="newlife.20101201170601.1317"><vh>__len__</vh></v>
<v t="newlife.20101201170601.1318"><vh>keys</vh></v>
<v t="newlife.20101201170601.1319"><vh>__setitem__</vh></v>
<v t="newlife.20101201170601.1320"><vh>query_string</vh></v>
<v t="newlife.20101201170601.1321"><vh>fullpath</vh></v>
<v t="newlife.20101201170601.1322"><vh>url</vh></v>
<v t="newlife.20101201170601.1323"><vh>content_length</vh></v>
<v t="newlife.20101201170601.1324"><vh>header</vh></v>
<v t="newlife.20101201170601.1325"><vh>headers</vh></v>
<v t="newlife.20101201170601.1326"><vh>GET</vh></v>
<v t="newlife.20101201170601.1327"><vh>POST</vh></v>
<v t="newlife.20101201170601.1328"><vh>forms</vh></v>
<v t="newlife.20101201170601.1329"><vh>files</vh></v>
<v t="newlife.20101201170601.1330"><vh>params</vh></v>
<v t="newlife.20101201170601.1331"><vh>body</vh></v>
<v t="newlife.20101201170601.1332"><vh>auth</vh></v>
<v t="newlife.20101201170601.1333"><vh>COOKIES</vh></v>
<v t="newlife.20101201170601.1334"><vh>get_cookie</vh></v>
<v t="newlife.20101201170601.1335"><vh>is_ajax</vh></v>
</v>
<v t="newlife.20101201170601.1336"><vh>class Response</vh>
<v t="newlife.20101201170601.1337"><vh>__init__</vh></v>
<v t="newlife.20101201170601.1338"><vh>bind</vh></v>
<v t="newlife.20101201170601.1339"><vh>header</vh></v>
<v t="newlife.20101201170601.1340"><vh>copy</vh></v>
<v t="newlife.20101201170601.1341"><vh>wsgiheader</vh></v>
<v t="newlife.20101201170601.1342"><vh>charset</vh></v>
<v t="newlife.20101201170601.1343"><vh>COOKIES</vh></v>
<v t="newlife.20101201170601.1344"><vh>set_cookie</vh></v>
<v t="newlife.20101201170601.1345"><vh>delete_cookie</vh></v>
<v t="newlife.20101201170601.1346"><vh>get_content_type</vh></v>
<v t="newlife.20101201170601.1347"><vh>set_content_type</vh></v>
</v>
<v t="newlife.20101201170601.1348"><vh>class MultiDict</vh>
<v t="newlife.20101201170601.1349"><vh>__init__</vh></v>
<v t="newlife.20101201170601.1350"><vh>__len__</vh></v>
<v t="newlife.20101201170601.1351"><vh>__iter__</vh></v>
<v t="newlife.20101201170601.1352"><vh>__contains__</vh></v>
<v t="newlife.20101201170601.1353"><vh>__delitem__</vh></v>
<v t="newlife.20101201170601.1354"><vh>keys</vh></v>
<v t="newlife.20101201170601.1355"><vh>__getitem__</vh></v>
<v t="newlife.20101201170601.1356"><vh>__setitem__</vh></v>
<v t="newlife.20101201170601.1357"><vh>append</vh></v>
<v t="newlife.20101201170601.1358"><vh>replace</vh></v>
<v t="newlife.20101201170601.1359"><vh>getall</vh></v>
<v t="newlife.20101201170601.1360"><vh>get</vh></v>
<v t="newlife.20101201170601.1361"><vh>iterallitems</vh></v>
</v>
<v t="newlife.20101201170601.1362"><vh>class HeaderDict</vh>
<v t="newlife.20101201170601.1363"><vh>__contains__</vh></v>
<v t="newlife.20101201170601.1364"><vh>__getitem__</vh></v>
<v t="newlife.20101201170601.1365"><vh>__delitem__</vh></v>
<v t="newlife.20101201170601.1366"><vh>__setitem__</vh></v>
<v t="newlife.20101201170601.1367"><vh>get</vh></v>
<v t="newlife.20101201170601.1368"><vh>append</vh></v>
<v t="newlife.20101201170601.1369"><vh>replace</vh></v>
<v t="newlife.20101201170601.1370"><vh>getall</vh></v>
<v t="newlife.20101201170601.1371"><vh>httpkey</vh></v>
</v>
<v t="newlife.20101201170601.1372"><vh>class WSGIHeaderDict</vh>
<v t="newlife.20101201170601.1373"><vh>__init__</vh></v>
<v t="newlife.20101201170601.1374"><vh>__len__</vh></v>
<v t="newlife.20101201170601.1375"><vh>keys</vh></v>
<v t="newlife.20101201170601.1376"><vh>__iter__</vh></v>
<v t="newlife.20101201170601.1377"><vh>__contains__</vh></v>
<v t="newlife.20101201170601.1378"><vh>__delitem__</vh></v>
<v t="newlife.20101201170601.1379"><vh>__getitem__</vh></v>
<v t="newlife.20101201170601.1380"><vh>__setitem__</vh></v>
<v t="newlife.20101201170601.1381"><vh>raw</vh></v>
</v>
<v t="newlife.20101201170601.1382"><vh>class AppStack</vh>
<v t="newlife.20101201170601.1383"><vh>__call__</vh></v>
<v t="newlife.20101201170601.1384"><vh>push</vh></v>
</v>
<v t="newlife.20101201170601.1385"><vh>class WSGIFileWrapper</vh>
<v t="newlife.20101201170601.1386"><vh>__init__</vh></v>
<v t="newlife.20101201170601.1387"><vh>__iter__</vh></v>
</v>
<v t="newlife.20101201170601.1388"><vh>dict2json</vh></v>
<v t="newlife.20101201170601.1389"><vh>abort</vh></v>
<v t="newlife.20101201170601.1390"><vh>redirect</vh></v>
<v t="newlife.20101201170601.1391"><vh>send_file</vh></v>
<v t="newlife.20101201170601.1392"><vh>static_file</vh></v>
<v t="newlife.20101201170601.1393"><vh>debug</vh></v>
<v t="newlife.20101201170601.1394"><vh>parse_date</vh></v>
<v t="newlife.20101201170601.1395"><vh>parse_auth</vh></v>
<v t="newlife.20101201170601.1396"><vh>cookie_encode</vh></v>
<v t="newlife.20101201170601.1397"><vh>cookie_decode</vh></v>
<v t="newlife.20101201170601.1398"><vh>cookie_is_encoded</vh></v>
<v t="newlife.20101201170601.1399"><vh>yieldroutes</vh></v>
<v t="newlife.20101201170601.1400"><vh>path_shift</vh></v>
<v t="newlife.20101201170601.1401"><vh>validate</vh></v>
<v t="newlife.20101201170601.1402"><vh>make_default_app_wrapper</vh></v>
<v t="newlife.20101201170601.1403"><vh>default</vh></v>
<v t="newlife.20101201170601.1404"><vh>class ServerAdapter</vh>
<v t="newlife.20101201170601.1405"><vh>__init__</vh></v>
<v t="newlife.20101201170601.1406"><vh>run</vh></v>
<v t="newlife.20101201170601.1407"><vh>__repr__</vh></v>
</v>
<v t="newlife.20101201170601.1408"><vh>class CGIServer</vh>
<v t="newlife.20101201170601.1409"><vh>run</vh></v>
</v>
<v t="newlife.20101201170601.1410"><vh>class FlupFCGIServer</vh>
<v t="newlife.20101201170601.1411"><vh>run</vh></v>
</v>
<v t="newlife.20101201170601.1412"><vh>class WSGIRefServer</vh>
<v t="newlife.20101201170601.1413"><vh>run</vh></v>
</v>
<v t="newlife.20101201170601.1414"><vh>class CherryPyServer</vh>
<v t="newlife.20101201170601.1415"><vh>run</vh></v>
</v>
<v t="newlife.20101201170601.1416"><vh>class PasteServer</vh>
<v t="newlife.20101201170601.1417"><vh>run</vh></v>
</v>
<v t="newlife.20101201170601.1418"><vh>class MeinheldServer</vh>
<v t="newlife.20101201170601.1419"><vh>run</vh></v>
</v>
<v t="newlife.20101201170601.1420"><vh>class FapwsServer</vh>
<v t="newlife.20101201170601.1421"><vh>run</vh></v>
</v>
<v t="newlife.20101201170601.1422"><vh>class TornadoServer</vh>
<v t="newlife.20101201170601.1423"><vh>run</vh></v>
</v>
<v t="newlife.20101201170601.1424"><vh>class AppEngineServer</vh>
<v t="newlife.20101201170601.1425"><vh>run</vh></v>
</v>
<v t="newlife.20101201170601.1426"><vh>class TwistedServer</vh>
<v t="newlife.20101201170601.1427"><vh>run</vh></v>
</v>
<v t="newlife.20101201170601.1428"><vh>class DieselServer</vh>
<v t="newlife.20101201170601.1429"><vh>run</vh></v>
</v>
<v t="newlife.20101201170601.1430"><vh>class GeventServer</vh>
<v t="newlife.20101201170601.1431"><vh>run</vh></v>
</v>
<v t="newlife.20101201170601.1432"><vh>class GunicornServer</vh>
<v t="newlife.20101201170601.1433"><vh>run</vh></v>
</v>
<v t="newlife.20101201170601.1434"><vh>class EventletServer</vh>
<v t="newlife.20101201170601.1435"><vh>run</vh></v>
</v>
<v t="newlife.20101201170601.1436"><vh>class RocketServer</vh>
<v t="newlife.20101201170601.1437"><vh>run</vh></v>
</v>
<v t="newlife.20101201170601.1438"><vh>class AutoServer</vh>
<v t="newlife.20101201170601.1439"><vh>run</vh></v>
</v>
<v t="newlife.20101201170601.1440"><vh>_load</vh></v>
<v t="newlife.20101201170601.1441"><vh>load_app</vh></v>
<v t="newlife.20101201170601.1442"><vh>run</vh></v>
<v t="newlife.20101201170601.1443"><vh>class FileCheckerThread</vh>
<v t="newlife.20101201170601.1444"><vh>__init__</vh></v>
<v t="newlife.20101201170601.1445"><vh>run</vh></v>
</v>
<v t="newlife.20101201170601.1446"><vh>_reloader_child</vh></v>
<v t="newlife.20101201170601.1447"><vh>_reloader_observer</vh></v>
<v t="newlife.20101201170601.1448"><vh>class TemplateError</vh>
<v t="newlife.20101201170601.1449"><vh>__init__</vh></v>
</v>
<v t="newlife.20101201170601.1450"><vh>class BaseTemplate</vh>
<v t="newlife.20101201170601.1451"><vh>__init__</vh></v>
<v t="newlife.20101201170601.1452"><vh>search</vh></v>
<v t="newlife.20101201170601.1453"><vh>global_config</vh></v>
<v t="newlife.20101201170601.1454"><vh>prepare</vh></v>
<v t="newlife.20101201170601.1455"><vh>render</vh></v>
</v>
<v t="newlife.20101201170601.1456"><vh>class MakoTemplate</vh>
<v t="newlife.20101201170601.1457"><vh>prepare</vh></v>
<v t="newlife.20101201170601.1458"><vh>render</vh></v>
</v>
<v t="newlife.20101201170601.1459"><vh>class CheetahTemplate</vh>
<v t="newlife.20101201170601.1460"><vh>prepare</vh></v>
<v t="newlife.20101201170601.1461"><vh>render</vh></v>
</v>
<v t="newlife.20101201170601.1462"><vh>class Jinja2Template</vh>
<v t="newlife.20101201170601.1463"><vh>prepare</vh></v>
<v t="newlife.20101201170601.1464"><vh>render</vh></v>
<v t="newlife.20101201170601.1465"><vh>loader</vh></v>
</v>
<v t="newlife.20101201170601.1466"><vh>class SimpleTALTemplate</vh>
<v t="newlife.20101201170601.1467"><vh>prepare</vh></v>
<v t="newlife.20101201170601.1468"><vh>render</vh></v>
</v>
<v t="newlife.20101201170601.1469"><vh>class SimpleTemplate</vh>
<v t="newlife.20101201170601.1470"><vh>prepare</vh></v>
<v t="newlife.20101201170601.1471"><vh>translate</vh></v>
<v t="newlife.20101201170601.1472"><vh>subtemplate</vh></v>
<v t="newlife.20101201170601.1473"><vh>execute</vh></v>
<v t="newlife.20101201170601.1474"><vh>render</vh></v>
</v>
<v t="newlife.20101201170601.1475"><vh>template</vh></v>
<v t="newlife.20101201170601.1476"><vh>view</vh></v>
</v>
<v t="newlife.20101201170601.1478" a="E"><vh>@file /home/newlife/bottle/startbottle.py</vh>
<v t="newlife.20101201170601.1479"><vh>startbottle declarations</vh></v>
<v t="newlife.20101201170601.1480"><vh>terminate</vh></v>
<v t="newlife.20101201170601.1481"><vh>set_exit_handler</vh></v>
<v t="newlife.20101201170601.1482"><vh>class ModuleChecker</vh>
<v t="newlife.20101201170601.1483"><vh>__init__</vh></v>
<v t="newlife.20101201170601.1484"><vh>add</vh></v>
<v t="newlife.20101201170601.1485"><vh>mtime</vh></v>
<v t="newlife.20101201170601.1486"><vh>check</vh>
<v t="newlife.20101201170601.1492"><vh>&lt;&lt; test_change&gt;&gt;</vh></v>
</v>
<v t="newlife.20101201170601.1487"><vh>reset</vh></v>
<v t="newlife.20101201170601.1488"><vh>loop</vh></v>
</v>
<v t="newlife.20101201170601.1489"><vh>run_child</vh></v>
<v t="newlife.20101201170601.1490"><vh>run_observer</vh></v>
<v t="newlife.20101201170601.1491"><vh>main</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="newlife.20101201170601.1254"></t>
<t tx="newlife.20101201170601.1255"></t>
<t tx="newlife.20101201170601.1256">@language python
@tabwidth -4
@others
mako_view = functools.partial(view, template_adapter=MakoTemplate)
cheetah_view = functools.partial(view, template_adapter=CheetahTemplate)
jinja2_view = functools.partial(view, template_adapter=Jinja2Template)
simpletal_view = functools.partial(view, template_adapter=SimpleTALTemplate)





###############################################################################
# Constants and Globals ########################################################
###############################################################################

TEMPLATE_PATH = ['./', './views/']
TEMPLATES = {}
DEBUG = False
MEMFILE_MAX = 1024*100
HTTP_CODES = httplib.responses
HTTP_CODES[418] = "I'm a teapot" # RFC 2324

ERROR_PAGE_TEMPLATE = SimpleTemplate("""
%try:
    %from bottle import DEBUG, HTTP_CODES, request
    %status_name = HTTP_CODES.get(e.status, 'Unknown').title()
    &lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;
    &lt;html&gt;
        &lt;head&gt;
            &lt;title&gt;Error {{e.status}}: {{status_name}}&lt;/title&gt;
            &lt;style type="text/css"&gt;
              html {background-color: #eee; font-family: sans;}
              body {background-color: #fff; border: 1px solid #ddd; padding: 15px; margin: 15px;}
              pre {background-color: #eee; border: 1px solid #ddd; padding: 5px;}
            &lt;/style&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;h1&gt;Error {{e.status}}: {{status_name}}&lt;/h1&gt;
            &lt;p&gt;Sorry, the requested URL &lt;tt&gt;{{request.url}}&lt;/tt&gt; caused an error:&lt;/p&gt;
            &lt;pre&gt;{{str(e.output)}}&lt;/pre&gt;
            %if DEBUG and e.exception:
              &lt;h2&gt;Exception:&lt;/h2&gt;
              &lt;pre&gt;{{repr(e.exception)}}&lt;/pre&gt;
            %end
            %if DEBUG and e.traceback:
              &lt;h2&gt;Traceback:&lt;/h2&gt;
              &lt;pre&gt;{{e.traceback}}&lt;/pre&gt;
            %end
        &lt;/body&gt;
    &lt;/html&gt;
%except ImportError:
    &lt;b&gt;ImportError:&lt;/b&gt; Could not generate the error page. Please add bottle to sys.path
%end
""")
""" The HTML template used for error messages """

request = Request()
""" Whenever a page is requested, the :class:`Bottle` WSGI handler stores
metadata about the current request into this instance of :class:`Request`.
It is thread-safe and can be accessed from within handler functions. """

response = Response()
""" The :class:`Bottle` WSGI handler uses metadata assigned to this instance
of :class:`Response` to generate the WSGI response. """

local = threading.local()
""" Thread-local namespace. Not used by Bottle, but could get handy """

# Initialize app stack (create first empty Bottle app)
# BC: 0.6.4 and needed for run()
app = default_app = AppStack()
app.push()
</t>
<t tx="newlife.20101201170601.1257"># -*- coding: utf-8 -*-
"""
Bottle is a fast and simple micro-framework for small web applications. It
offers request dispatching (Routes) with url parameter support, templates,
a built-in HTTP Server and adapters for many third party WSGI/HTTP-server and
template engines - all in a single file and with no dependencies other than the
Python Standard Library.

Homepage and documentation: http://bottle.paws.de/

Copyright (c) 2010, Marcel Hellkamp.
License: MIT (see LICENSE.txt for details)
"""

from __future__ import with_statement

__author__ = 'Marcel Hellkamp'
__version__ = '0.9.dev'
__license__ = 'MIT'

import base64
import cgi
import email.utils
import functools
import hmac
import httplib
import inspect
import itertools
import mimetypes
import os
import re
import subprocess
import sys
import tempfile
import thread
import threading
import time
import tokenize
import warnings

from Cookie import SimpleCookie
from tempfile import TemporaryFile
from traceback import format_exc
from urllib import quote as urlquote
from urlparse import urlunsplit, urljoin

try: from collections import MutableMapping as DictMixin
except ImportError: # pragma: no cover
    from UserDict import DictMixin

try: from urlparse import parse_qs
except ImportError: # pragma: no cover
    from cgi import parse_qs

try: import cPickle as pickle
except ImportError: # pragma: no cover
    import pickle

try: from json import dumps as json_dumps
except ImportError: # pragma: no cover
    try: from simplejson import dumps as json_dumps
    except ImportError: # pragma: no cover
        try: from django.utils.simplejson import dumps as json_dumps
        except ImportError: # pragma: no cover
            json_dumps = None

if sys.version_info &gt;= (3,0,0): # pragma: no cover
    # See Request.POST
    from io import BytesIO
    from io import TextIOWrapper
    class NCTextIOWrapper(TextIOWrapper):
        ''' Garbage collecting an io.TextIOWrapper(buffer) instance closes the
            wrapped buffer. This subclass keeps it open. '''
        def close(self): pass
    StringType = bytes
    def touni(x, enc='utf8'):
        """ Convert anything to unicode """
        return str(x, encoding=enc) if isinstance(x, bytes) else str(x)
else:
    from StringIO import StringIO as BytesIO
    from types import StringType
    NCTextIOWrapper = None
    def touni(x, enc='utf8'):
        """ Convert anything to unicode """
        return x if isinstance(x, unicode) else unicode(str(x), encoding=enc)

</t>
<t tx="newlife.20101201170601.1258">def tob(data, enc='utf8'):
    """ Convert anything to bytes """
    return data.encode(enc) if isinstance(data, unicode) else StringType(data)

</t>
<t tx="newlife.20101201170601.1259"># Convert strings and unicode to native strings
if sys.version_info &gt;= (3,0,0):
    tonat = touni
else:
    tonat = tob
tonat.__doc__ = """ Convert anything to native strings """


# Background compatibility
def depr(message, critical=False):
    if critical: raise DeprecationWarning(message)
    warnings.warn(message, DeprecationWarning, stacklevel=3)

</t>
<t tx="newlife.20101201170601.1260"># Small helpers
def makelist(data):
    if isinstance(data, (tuple, list, set, dict)): return list(data)
    elif data: return [data]
    else: return []






</t>
<t tx="newlife.20101201170601.1261">###############################################################################
# Exceptions and Events ########################################################
###############################################################################

class BottleException(Exception):
    """ A base class for exceptions used by bottle. """
    pass


</t>
<t tx="newlife.20101201170601.1262">class HTTPResponse(BottleException):
    """ Used to break execution and immediately finish the response """
    @others
</t>
<t tx="newlife.20101201170601.1263">def __init__(self, output='', status=200, header=None):
    super(BottleException, self).__init__("HTTP Response %d" % status)
    self.status = int(status)
    self.output = output
    self.headers = HeaderDict(header) if header else None

</t>
<t tx="newlife.20101201170601.1264">def apply(self, response):
    if self.headers:
        for key, value in self.headers.iterallitems():
            response.headers[key] = value
    response.status = self.status


</t>
<t tx="newlife.20101201170601.1265">class HTTPError(HTTPResponse):
    """ Used to generate an error page """
    @others
</t>
<t tx="newlife.20101201170601.1266">def __init__(self, code=500, output='Unknown Error', exception=None, traceback=None, header=None):
    super(HTTPError, self).__init__(output, code, header)
    self.exception = exception
    self.traceback = traceback

</t>
<t tx="newlife.20101201170601.1267">def __repr__(self):
    return ''.join(ERROR_PAGE_TEMPLATE.render(e=self))






</t>
<t tx="newlife.20101201170601.1268">###############################################################################
# Routing ######################################################################
###############################################################################

class RouteError(BottleException):
    """ This is a base class for all routing related exceptions """


</t>
<t tx="newlife.20101201170601.1269">class RouteSyntaxError(RouteError):
    """ The route parser found something not supported by this router """


</t>
<t tx="newlife.20101201170601.1270">class RouteBuildError(RouteError):
    """ The route could not been built """


</t>
<t tx="newlife.20101201170601.1271">class Route(object):
    ''' Represents a single route and can parse the dynamic route syntax '''
    syntax = re.compile(r'(?&lt;!\\):([a-zA-Z_]+)?(?:#(.*?)#)?')
    default = '[^/]+'

    @others
</t>
<t tx="newlife.20101201170601.1272">def __init__(self, route, target=None, name=None, static=False):
    """ Create a Route. The route string may contain `:key`,
        `:key#regexp#` or `:#regexp#` tokens for each dynamic part of the
        route. These can be escaped with a backslash in front of the `:`
        and are completely ignored if static is true. A name may be used
        to refer to this route later (depends on Router)
    """
    self.route = route.replace('\\:',':')
    self.target = target
    self.name = name
    self.realroute = route.replace(':','\\:') if static else route
    self.tokens = self.syntax.split(self.realroute)

</t>
<t tx="newlife.20101201170601.1273">def group_re(self):
    ''' Return a regexp pattern with named groups '''
    out = ''
    for i, part in enumerate(self.tokens):
        if i%3 == 0:   out += re.escape(part.replace('\:',':'))
        elif i%3 == 1: out += '(?P&lt;%s&gt;' % part if part else '(?:'
        else:          out += '%s)' % (part or self.default)
    return out

</t>
<t tx="newlife.20101201170601.1274">def flat_re(self):
    ''' Return a regexp pattern with non-grouping parentheses '''
    rf = lambda m: m.group(0) if len(m.group(1)) % 2 else m.group(1) + '(?:'
    return re.sub(r'(\\*)(\(\?P&lt;[^&gt;]*&gt;|\((?!\?))', rf, self.group_re())

</t>
<t tx="newlife.20101201170601.1275">def format_str(self):
    ''' Return a format string with named fields. '''
    out, c = '', 0
    for i, part in enumerate(self.tokens):
        if i%3 == 0:  out += part.replace('\\:',':').replace('%','%%')
        elif i%3 == 1:
            if not part: part = 'anon%d' % c; c+=1
            out += '%%(%s)s' % part
    return out

</t>
<t tx="newlife.20101201170601.1276">@property
def static(self):
    return len(self.tokens) == 1

</t>
<t tx="newlife.20101201170601.1277">def __repr__(self):
    return "&lt;Route(%s) /&gt;" % repr(self.realroute)

</t>
<t tx="newlife.20101201170601.1278">def __eq__(self, other):
    return (self.realroute) == (other.realroute)


</t>
<t tx="newlife.20101201170601.1279">class Router(object):
    ''' A route associates a string (e.g. URL) with an object (e.g. function)
        Some dynamic routes may extract parts of the string and provide them as
        a dictionary. This router matches a string against multiple routes and
        returns the associated object along with the extracted data.
    '''
    @others
</t>
<t tx="newlife.20101201170601.1280">
def __init__(self):
    self.routes  = []  # List of all installed routes
    self.named   = {}  # Cache for named routes and their format strings
    self.static  = {}  # Cache for static routes
    self.dynamic = []  # Search structure for dynamic routes
    self.compiled = False

</t>
<t tx="newlife.20101201170601.1281">def add(self, route, target=None, **ka):
    """ Add a route-&gt;target pair or a :class:`Route` object to the Router.
        Return the Route object. See :class:`Route` for details.
    """
    if not isinstance(route, Route):
        route = Route(route, target, **ka)
    if self.get_route(route):
        return RouteError('Route %s is not uniqe.' % route)
    self.routes.append(route)
    self.compiled, self.named, self.static, self.dynamic = False, {}, {}, []
    return route

</t>
<t tx="newlife.20101201170601.1282">def get_route(self, route, target=None, **ka):
    ''' Get a route from the router by specifying either the same
        parameters as in :meth:`add` or comparing to an instance of
        :class:`Route`. Note that not all parameters are considered by the
        compare function. '''
    if not isinstance(route, Route):
        route = Route(route, **ka)
    for known in self.routes:
        if route == known:
            return known
    return None

</t>
<t tx="newlife.20101201170601.1283">def match(self, uri):
    ''' Match an URI and return a (target, urlargs) tuple '''
    if uri in self.static:
        return self.static[uri], {}
    for combined, subroutes in self.dynamic:
        match = combined.match(uri)
        if not match: continue
        target, args_re = subroutes[match.lastindex - 1]
        args = args_re.match(uri).groupdict() if args_re else {}
        return target, args
    if not self.compiled: # Late check to reduce overhead on hits
        self.compile() # Compile and try again.
        return self.match(uri)
    return None, {}

</t>
<t tx="newlife.20101201170601.1284">def build(self, _name, **args):
    ''' Build an URI out of a named route and values for the wildcards. '''
    try:
        return self.named[_name] % args
    except KeyError:
        if not self.compiled: # Late check to reduce overhead on hits
            self.compile() # Compile and try again.
            return self.build(_name, **args)
        raise RouteBuildError("No route found with name '%s'." % _name)

</t>
<t tx="newlife.20101201170601.1285">def compile(self):
    ''' Build the search structures. Call this before actually using the
        router.'''
    self.named = {}
    self.static = {}
    self.dynamic = []
    for route in self.routes:
        if route.name:
            self.named[route.name] = route.format_str()
        if route.static:
            self.static[route.route] = route.target
            continue
        gpatt = route.group_re()
        fpatt = route.flat_re()
        try:
            gregexp = re.compile('^(%s)$' % gpatt) if '(?P' in gpatt else None
            combined = '%s|(^%s$)' % (self.dynamic[-1][0].pattern, fpatt)
            self.dynamic[-1] = (re.compile(combined), self.dynamic[-1][1])
            self.dynamic[-1][1].append((route.target, gregexp))
        except (AssertionError, IndexError), e: # AssertionError: Too many groups
            self.dynamic.append((re.compile('(^%s$)'%fpatt),
                                [(route.target, gregexp)]))
        except re.error, e:
            raise RouteSyntaxError("Could not add Route: %s (%s)" % (route, e))
    self.compiled = True

</t>
<t tx="newlife.20101201170601.1286">def __eq__(self, other):
    return self.routes == other.routes






</t>
<t tx="newlife.20101201170601.1287">###############################################################################
# Application Object ###########################################################
###############################################################################

class Bottle(object):
    """ WSGI application """
    @others
</t>
<t tx="newlife.20101201170601.1288">
def __init__(self, catchall=True, autojson=True, config=None):
    """ Create a new bottle instance.
        You usually don't do that. Use `bottle.app.push()` instead.
    """
    self.routes = Router()
    self.mounts = {}
    self.error_handler = {}
    self.catchall = catchall
    self.config = config or {}
    self.serve = True
    self.castfilter = []
    if autojson and json_dumps:
        self.add_filter(dict, dict2json)
    self.hooks = {'before_request': [], 'after_request': []}

</t>
<t tx="newlife.20101201170601.1289">def optimize(self, *a, **ka):
    depr("Bottle.optimize() is obsolete.")

</t>
<t tx="newlife.20101201170601.1290">def mount(self, app, script_path):
    ''' Mount a Bottle application to a specific URL prefix '''
    if not isinstance(app, Bottle):
        raise TypeError('Only Bottle instances are supported for now.')
    script_path = '/'.join(filter(None, script_path.split('/')))
    path_depth = script_path.count('/') + 1
    if not script_path:
        raise TypeError('Empty script_path. Perhaps you want a merge()?')
    for other in self.mounts:
        if other.startswith(script_path):
            raise TypeError('Conflict with existing mount: %s' % other)
    @self.route('/%s/:#.*#' % script_path, method="ANY")
    def mountpoint():
        request.path_shift(path_depth)
        return app.handle(request.path, request.method)
    self.mounts[script_path] = app

</t>
<t tx="newlife.20101201170601.1291">def add_filter(self, ftype, func):
    ''' Register a new output filter. Whenever bottle hits a handler output
        matching `ftype`, `func` is applied to it. '''
    if not isinstance(ftype, type):
        raise TypeError("Expected type object, got %s" % type(ftype))
    self.castfilter = [(t, f) for (t, f) in self.castfilter if t != ftype]
    self.castfilter.append((ftype, func))
    self.castfilter.sort()

</t>
<t tx="newlife.20101201170601.1292">def match_url(self, path, method='GET'):
    """ Find a callback bound to a path and a specific HTTP method.
        Return (callback, param) tuple or raise HTTPError.
        method: HEAD falls back to GET. All methods fall back to ANY.
    """
    path, method = path.strip().lstrip('/'), method.upper()
    callbacks, args = self.routes.match(path)
    if not callbacks:
        raise HTTPError(404, "Not found: " + path)
    if method in callbacks:
        return callbacks[method], args
    if method == 'HEAD' and 'GET' in callbacks:
        return callbacks['GET'], args
    if 'ANY' in callbacks:
        return callbacks['ANY'], args
    allow = [m for m in callbacks if m != 'ANY']
    if 'GET' in allow and 'HEAD' not in allow:
        allow.append('HEAD')
    raise HTTPError(405, "Method not allowed.",
                    header=[('Allow',",".join(allow))])

</t>
<t tx="newlife.20101201170601.1293">def get_url(self, routename, **kargs):
    """ Return a string that matches a named route """
    scriptname = request.environ.get('SCRIPT_NAME', '').strip('/') + '/'
    location = self.routes.build(routename, **kargs).lstrip('/')
    return urljoin(urljoin('/', scriptname), location)

</t>
<t tx="newlife.20101201170601.1294">def route(self, path=None, method='GET', no_hooks=False, decorate=None,
          template=None, template_opts={}, callback=None, **kargs):
    """ Decorator: Bind a callback function to a request path.

        :param path: The request path or a list of paths to listen to. See 
          :class:`Router` for syntax details. If no path is specified, it
          is automatically generated from the callback signature. See
          :func:`yieldroutes` for details.
        :param method: The HTTP method (POST, GET, ...) or a list of
          methods to listen to. (default: GET)
        :param decorate: A decorator or a list of decorators. These are
          applied to the callback in reverse order.
        :param no_hooks: If true, application hooks are not triggered
          by this route. (default: False)
        :param template: The template to use for this callback.
          (default: no template)
        :param template_opts: A dict with additional template parameters.
        :param static: If true, all paths are static even if they contain
          dynamic syntax tokens. (default: False)
        :param name: The name for this route. (default: None)
        :param callback: If set, the route decorator is directly applied
          to the callback and the callback is returned instead. This
          equals ``Bottle.route(...)(callback)``.
    """
    # @route can be used without any parameters
    if callable(path): path, callback = None, path
    # Build up the list of decorators
    decorators = makelist(decorate)
    if template:     decorators.insert(0, view(template, **template_opts))
    if not no_hooks: decorators.append(self._add_hook_wrapper)
    def wrapper(func):
        callback = func
        for decorator in reversed(decorators):
            callback = decorator(callback)
        functools.update_wrapper(callback, func)
        for route in makelist(path) or yieldroutes(func):
            for meth in makelist(method):
                route = route.strip().lstrip('/')
                meth = meth.strip().upper()
                old = self.routes.get_route(route, **kargs)
                if old:
                    old.target[meth] = callback
                else:
                    self.routes.add(route, {meth: callback}, **kargs)
        return func
    return wrapper(callback) if callback else wrapper

</t>
<t tx="newlife.20101201170601.1295">def _add_hook_wrapper(self, func):
    ''' Add hooks to a callable. See #84 '''
    @functools.wraps(func)
    def wrapper(*a, **ka):
        for hook in self.hooks['before_request']: hook()
        response.output = func(*a, **ka)
        for hook in self.hooks['after_request']: hook()
        return response.output
    return wrapper

</t>
<t tx="newlife.20101201170601.1296">def get(self, path=None, method='GET', **kargs):
    """ Decorator: Bind a function to a GET request path.
        See :meth:'route' for details. """
    return self.route(path, method, **kargs)

</t>
<t tx="newlife.20101201170601.1297">def post(self, path=None, method='POST', **kargs):
    """ Decorator: Bind a function to a POST request path.
        See :meth:'route' for details. """
    return self.route(path, method, **kargs)

</t>
<t tx="newlife.20101201170601.1298">def put(self, path=None, method='PUT', **kargs):
    """ Decorator: Bind a function to a PUT request path.
        See :meth:'route' for details. """
    return self.route(path, method, **kargs)

</t>
<t tx="newlife.20101201170601.1299">def delete(self, path=None, method='DELETE', **kargs):
    """ Decorator: Bind a function to a DELETE request path.
        See :meth:'route' for details. """
    return self.route(path, method, **kargs)

</t>
<t tx="newlife.20101201170601.1300">def error(self, code=500):
    """ Decorator: Register an output handler for a HTTP error code"""
    def wrapper(handler):
        self.error_handler[int(code)] = handler
        return handler
    return wrapper

</t>
<t tx="newlife.20101201170601.1301">def hook(self, name):
    """ Return a decorator that adds a callback to the specified hook. """
    def wrapper(func):
        self.add_hook(name, func)
        return func
    return wrapper

</t>
<t tx="newlife.20101201170601.1302">def add_hook(self, name, func):
    ''' Add a callback from a hook. '''
    if name not in self.hooks:
        raise ValueError("Unknown hook name %s" % name)
    if name in ('after_request'):
        self.hooks[name].insert(0, func)
    else:
        self.hooks[name].append(func)

</t>
<t tx="newlife.20101201170601.1303">def remove_hook(self, name, func):
    ''' Remove a callback from a hook. '''
    if name not in self.hooks:
        raise ValueError("Unknown hook name %s" % name)
    self.hooks[name].remove(func)

</t>
<t tx="newlife.20101201170601.1304">def handle(self, url, method):
    """ Execute the handler bound to the specified url and method and return
    its output. If catchall is true, exceptions are catched and returned as
    HTTPError(500) objects. """
    if not self.serve:
        return HTTPError(503, "Server stopped")
    try:
        handler, args = self.match_url(url, method)
        return handler(**args)
    except HTTPResponse, e:
        return e
    except Exception, e:
        if isinstance(e, (KeyboardInterrupt, SystemExit, MemoryError))\
        or not self.catchall:
            raise
        return HTTPError(500, 'Unhandled exception', e, format_exc(10))

</t>
<t tx="newlife.20101201170601.1305">def _cast(self, out, request, response, peek=None):
    """ Try to convert the parameter into something WSGI compatible and set
    correct HTTP headers when possible.
    Support: False, str, unicode, dict, HTTPResponse, HTTPError, file-like,
    iterable of strings and iterable of unicodes
    """
    # Filtered types (recursive, because they may return anything)
    for testtype, filterfunc in self.castfilter:
        if isinstance(out, testtype):
            return self._cast(filterfunc(out), request, response)

    # Empty output is done here
    if not out:
        response.headers['Content-Length'] = 0
        return []
    # Join lists of byte or unicode strings. Mixed lists are NOT supported
    if isinstance(out, (tuple, list))\
    and isinstance(out[0], (StringType, unicode)):
        out = out[0][0:0].join(out) # b'abc'[0:0] -&gt; b''
    # Encode unicode strings
    if isinstance(out, unicode):
        out = out.encode(response.charset)
    # Byte Strings are just returned
    if isinstance(out, StringType):
        response.headers['Content-Length'] = str(len(out))
        return [out]
    # HTTPError or HTTPException (recursive, because they may wrap anything)
    if isinstance(out, HTTPError):
        out.apply(response)
        return self._cast(self.error_handler.get(out.status, repr)(out), request, response)
    if isinstance(out, HTTPResponse):
        out.apply(response)
        return self._cast(out.output, request, response)

    # File-like objects.
    if hasattr(out, 'read'):
        if 'wsgi.file_wrapper' in request.environ:
            return request.environ['wsgi.file_wrapper'](out)
        elif hasattr(out, 'close') or not hasattr(out, '__iter__'):
            return WSGIFileWrapper(out)

    # Handle Iterables. We peek into them to detect their inner type.
    try:
        out = iter(out)
        first = out.next()
        while not first:
            first = out.next()
    except StopIteration:
        return self._cast('', request, response)
    except HTTPResponse, e:
        first = e
    except Exception, e:
        first = HTTPError(500, 'Unhandled exception', e, format_exc(10))
        if isinstance(e, (KeyboardInterrupt, SystemExit, MemoryError))\
        or not self.catchall:
            raise
    # These are the inner types allowed in iterator or generator objects.
    if isinstance(first, HTTPResponse):
        return self._cast(first, request, response)
    if isinstance(first, StringType):
        return itertools.chain([first], out)
    if isinstance(first, unicode):
        return itertools.imap(lambda x: x.encode(response.charset),
                              itertools.chain([first], out))
    return self._cast(HTTPError(500, 'Unsupported response type: %s'\
                                     % type(first)), request, response)

</t>
<t tx="newlife.20101201170601.1306">def wsgi(self, environ, start_response):
    """ The bottle WSGI-interface. """
    try:
        environ['bottle.app'] = self
        request.bind(environ)
        response.bind()
        out = self.handle(request.path, request.method)
        out = self._cast(out, request, response)
        # rfc2616 section 4.3
        if response.status in (100, 101, 204, 304) or request.method == 'HEAD':
            if hasattr(out, 'close'): out.close()
            out = []
        status = '%d %s' % (response.status, HTTP_CODES[response.status])
        start_response(status, response.headerlist)
        return out
    except (KeyboardInterrupt, SystemExit, MemoryError):
        raise
    except Exception, e:
        if not self.catchall: raise
        err = '&lt;h1&gt;Critical error while processing request: %s&lt;/h1&gt;' \
              % environ.get('PATH_INFO', '/')
        if DEBUG:
            err += '&lt;h2&gt;Error:&lt;/h2&gt;\n&lt;pre&gt;%s&lt;/pre&gt;\n' % repr(e)
            err += '&lt;h2&gt;Traceback:&lt;/h2&gt;\n&lt;pre&gt;%s&lt;/pre&gt;\n' % format_exc(10)
        environ['wsgi.errors'].write(err) #TODO: wsgi.error should not get html
        start_response('500 INTERNAL SERVER ERROR', [('Content-Type', 'text/html')])
        return [tob(err)]

</t>
<t tx="newlife.20101201170601.1307">def __call__(self, environ, start_response):
    return self.wsgi(environ, start_response)






</t>
<t tx="newlife.20101201170601.1308">###############################################################################
# HTTP and WSGI Tools ##########################################################
###############################################################################

class Request(threading.local, DictMixin):
    """ Represents a single HTTP request using thread-local attributes.
        The Request object wraps a WSGI environment and can be used as such.
    """
    @others
</t>
<t tx="newlife.20101201170601.1309">def __init__(self, environ=None):
    """ Create a new Request instance.

        You usually don't do this but use the global `bottle.request`
        instance instead.
    """
    self.bind(environ or {},)

</t>
<t tx="newlife.20101201170601.1310">def bind(self, environ):
    """ Bind a new WSGI environment.

        This is done automatically for the global `bottle.request`
        instance on every request.
    """
    self.environ = environ
    # These attributes are used anyway, so it is ok to compute them here
    self.path = '/' + environ.get('PATH_INFO', '/').lstrip('/')
    self.method = environ.get('REQUEST_METHOD', 'GET').upper()

</t>
<t tx="newlife.20101201170601.1311">@property
def _environ(self):
    depr("Request._environ renamed to Request.environ")
    return self.environ

</t>
<t tx="newlife.20101201170601.1312">def copy(self):
    ''' Returns a copy of self '''
    return Request(self.environ.copy())

</t>
<t tx="newlife.20101201170601.1313">def path_shift(self, shift=1):
    ''' Shift path fragments from PATH_INFO to SCRIPT_NAME and vice versa.

       :param shift: The number of path fragments to shift. May be negative
                     to change the shift direction. (default: 1)
    '''
    script_name = self.environ.get('SCRIPT_NAME','/')
    self['SCRIPT_NAME'], self.path = path_shift(script_name, self.path, shift)
    self['PATH_INFO'] = self.path

</t>
<t tx="newlife.20101201170601.1314">def __getitem__(self, key): return self.environ[key]
</t>
<t tx="newlife.20101201170601.1315">def __delitem__(self, key): self[key] = ""; del(self.environ[key])
</t>
<t tx="newlife.20101201170601.1316">def __iter__(self): return iter(self.environ)
</t>
<t tx="newlife.20101201170601.1317">def __len__(self): return len(self.environ)
</t>
<t tx="newlife.20101201170601.1318">def keys(self): return self.environ.keys()
</t>
<t tx="newlife.20101201170601.1319">def __setitem__(self, key, value):
    """ Shortcut for Request.environ.__setitem__ """
    self.environ[key] = value
    todelete = []
    if key in ('PATH_INFO','REQUEST_METHOD'):
        self.bind(self.environ)
    elif key == 'wsgi.input': todelete = ('body','forms','files','params')
    elif key == 'QUERY_STRING': todelete = ('get','params')
    elif key.startswith('HTTP_'): todelete = ('headers', 'cookies')
    for key in todelete:
        if 'bottle.' + key in self.environ:
            del self.environ['bottle.' + key]

</t>
<t tx="newlife.20101201170601.1320">@property
def query_string(self):
    """ The part of the URL following the '?'. """
    return self.environ.get('QUERY_STRING', '')

</t>
<t tx="newlife.20101201170601.1321">@property
def fullpath(self):
    """ Request path including SCRIPT_NAME (if present). """
    return self.environ.get('SCRIPT_NAME', '').rstrip('/') + self.path

</t>
<t tx="newlife.20101201170601.1322">@property
def url(self):
    """ Full URL as requested by the client (computed).

        This value is constructed out of different environment variables
        and includes scheme, host, port, scriptname, path and query string. 
    """
    scheme = self.environ.get('wsgi.url_scheme', 'http')
    host   = self.environ.get('HTTP_X_FORWARDED_HOST')
    host   = host or self.environ.get('HTTP_HOST', None)
    if not host:
        host = self.environ.get('SERVER_NAME')
        port = self.environ.get('SERVER_PORT', '80')
        if (scheme, port) not in (('https','443'), ('http','80')):
            host += ':' + port
    parts = (scheme, host, urlquote(self.fullpath), self.query_string, '')
    return urlunsplit(parts)

</t>
<t tx="newlife.20101201170601.1323">@property
def content_length(self):
    """ Content-Length header as an integer, -1 if not specified """
    return int(self.environ.get('CONTENT_LENGTH', '') or -1)

</t>
<t tx="newlife.20101201170601.1324">@property
def header(self):
    depr("The Request.header property was renamed to Request.headers")
    return self.headers

</t>
<t tx="newlife.20101201170601.1325">@property
def headers(self):
    ''' A dict-like object filled with request headers.

        This dictionary uses case-insensitive keys and native strings as
        keys and values. See :class:`WSGIHeaderDict` for details.
    '''
    if 'bottle.headers' not in self.environ:
        self.environ['bottle.headers'] = WSGIHeaderDict(self.environ)
    return self.environ['bottle.headers']

</t>
<t tx="newlife.20101201170601.1326">@property
def GET(self):
    """ The QUERY_STRING parsed into an instance of :class:`MultiDict`.

        If you expect more than one value for a key, use ``.getall(key)`` on
        this dictionary to get a list of all values. Otherwise, only the
        first value is returned.
    """
    if 'bottle.get' not in self.environ:
        data = parse_qs(self.query_string, keep_blank_values=True)
        get = self.environ['bottle.get'] = MultiDict()
        for key, values in data.iteritems():
            for value in values:
                get[key] = value
    return self.environ['bottle.get']

</t>
<t tx="newlife.20101201170601.1327">@property
def POST(self):
    """ The combined values from :attr:`forms` and :attr:`files`. Values are
        either strings (form values) or instances of
        :class:`cgi.FieldStorage` (file uploads).

        If you expect more than one value for a key, use ``.getall(key)`` on
        this dictionary to get a list of all values. Otherwise, only the
        first value is returned.
    """
    if 'bottle.post' not in self.environ:
        self.environ['bottle.post'] = MultiDict()
        self.environ['bottle.forms'] = MultiDict()
        self.environ['bottle.files'] = MultiDict()
        safe_env = {'QUERY_STRING':''} # Build a safe environment for cgi
        for key in ('REQUEST_METHOD', 'CONTENT_TYPE', 'CONTENT_LENGTH'):
            if key in self.environ: safe_env[key] = self.environ[key]
        if NCTextIOWrapper:
            fb = NCTextIOWrapper(self.body, encoding='ISO-8859-1', newline='\n')
            # TODO: Content-Length may be wrong now. Does cgi.FieldStorage
            # use it at all? I think not, because all tests pass.
        else:
            fb = self.body
        data = cgi.FieldStorage(fp=fb, environ=safe_env, keep_blank_values=True)
        for item in data.list or []:
            if item.filename:
                self.environ['bottle.post'][item.name] = item
                self.environ['bottle.files'][item.name] = item
            else:
                self.environ['bottle.post'][item.name] = item.value
                self.environ['bottle.forms'][item.name] = item.value
    return self.environ['bottle.post']

</t>
<t tx="newlife.20101201170601.1328">@property
def forms(self):
    """ POST form values parsed into an instance of :class:`MultiDict`.

        This property contains form values parsed from an `url-encoded`
        or `multipart/form-data` encoded POST request bidy. The values are
        native strings.

        If you expect more than one value for a key, use ``.getall(key)`` on
        this dictionary to get a list of all values. Otherwise, only the
        first value is returned.
    """
    if 'bottle.forms' not in self.environ: self.POST
    return self.environ['bottle.forms']

</t>
<t tx="newlife.20101201170601.1329">@property
def files(self):
    """ File uploads parsed into an instance of :class:`MultiDict`.

        This property contains file uploads parsed from an
        `multipart/form-data` encoded POST request body. The values are
        instances of :class:`cgi.FieldStorage`.

        If you expect more than one value for a key, use ``.getall(key)`` on
        this dictionary to get a list of all values. Otherwise, only the
        first value is returned.
    """
    if 'bottle.files' not in self.environ: self.POST
    return self.environ['bottle.files']

</t>
<t tx="newlife.20101201170601.1330">@property
def params(self):
    """ A combined :class:`MultiDict` with values from :attr:`forms` and
        :attr:`GET`. File-uploads are not included. """
    if 'bottle.params' not in self.environ:
        self.environ['bottle.params'] = MultiDict(self.GET)
        self.environ['bottle.params'].update(dict(self.forms))
    return self.environ['bottle.params']

</t>
<t tx="newlife.20101201170601.1331">@property
def body(self):
    """ The HTTP request body as a seekable file-like object.

        This property returns a copy of the `wsgi.input` stream and should
        be used instead of `environ['wsgi.input']`.
     """
    if 'bottle.body' not in self.environ:
        maxread = max(0, self.content_length)
        stream = self.environ['wsgi.input']
        body = BytesIO() if maxread &lt; MEMFILE_MAX else TemporaryFile(mode='w+b')
        while maxread &gt; 0:
            part = stream.read(min(maxread, MEMFILE_MAX))
            if not part: #TODO: Wrong content_length. Error? Do nothing?
                break
            body.write(part)
            maxread -= len(part)
        self.environ['wsgi.input'] = body
        self.environ['bottle.body'] = body
    self.environ['bottle.body'].seek(0)
    return self.environ['bottle.body']

</t>
<t tx="newlife.20101201170601.1332">@property
def auth(self): #TODO: Tests and docs. Add support for digest. namedtuple?
    """ HTTP authorization data as a (user, passwd) tuple. (experimental)

        This implementation currently only supports basic auth and returns
        None on errors.
    """
    return parse_auth(self.headers.get('Authorization',''))

</t>
<t tx="newlife.20101201170601.1333">@property
def COOKIES(self):
    """ Cookies parsed into a dictionary. Secure cookies are NOT decoded
        automatically. See :meth:`get_cookie` for details.
    """
    if 'bottle.cookies' not in self.environ:
        raw_dict = SimpleCookie(self.headers.get('Cookie',''))
        self.environ['bottle.cookies'] = {}
        for cookie in raw_dict.itervalues():
            self.environ['bottle.cookies'][cookie.key] = cookie.value
    return self.environ['bottle.cookies']

</t>
<t tx="newlife.20101201170601.1334">def get_cookie(self, key, secret=None):
    """ Return the content of a cookie. To read a `Secure Cookies`, use the
        same `secret` as used to create the cookie (see
        :meth:`Response.set_cookie`). If anything goes wrong, None is
        returned.
    """
    value = self.COOKIES.get(key)
    if secret and value:
        dec = cookie_decode(value, secret) # (key, value) tuple or None
        return dec[1] if dec and dec[0] == key else None
    return value or None

</t>
<t tx="newlife.20101201170601.1335">@property
def is_ajax(self):
    ''' True if the request was generated using XMLHttpRequest '''
    #TODO: write tests
    return self.header.get('X-Requested-With') == 'XMLHttpRequest'



</t>
<t tx="newlife.20101201170601.1336">class Response(threading.local):
    """ Represents a single HTTP response using thread-local attributes.
    """
    @others
    content_type = property(get_content_type, set_content_type, None,
                            get_content_type.__doc__)






</t>
<t tx="newlife.20101201170601.1337">
def __init__(self):
    self.bind()

</t>
<t tx="newlife.20101201170601.1338">def bind(self):
    """ Resets the Response object to its factory defaults. """
    self._COOKIES = None
    self.status = 200
    self.headers = HeaderDict()
    self.content_type = 'text/html; charset=UTF-8'

</t>
<t tx="newlife.20101201170601.1339">@property
def header(self):
    depr("Response.header renamed to Response.headers")
    return self.headers

</t>
<t tx="newlife.20101201170601.1340">def copy(self):
    ''' Returns a copy of self. '''
    copy = Response()
    copy.status = self.status
    copy.headers = self.headers.copy()
    copy.content_type = self.content_type
    return copy

</t>
<t tx="newlife.20101201170601.1341">def wsgiheader(self):
    ''' Returns a wsgi conform list of header/value pairs. '''
    for c in self.COOKIES.values():
        if c.OutputString() not in self.headers.getall('Set-Cookie'):
            self.headers.append('Set-Cookie', c.OutputString())
    # rfc2616 section 10.2.3, 10.3.5
    if self.status in (204, 304) and 'content-type' in self.headers:
        del self.headers['content-type']
    if self.status == 304:
        for h in ('allow', 'content-encoding', 'content-language',
                  'content-length', 'content-md5', 'content-range',
                  'content-type', 'last-modified'): # + c-location, expires?
            if h in self.headers:
                 del self.headers[h]
    return list(self.headers.iterallitems())
</t>
<t tx="newlife.20101201170601.1342">headerlist = property(wsgiheader)

@property
def charset(self):
    """ Return the charset specified in the content-type header.

        This defaults to `UTF-8`.
    """
    if 'charset=' in self.content_type:
        return self.content_type.split('charset=')[-1].split(';')[0].strip()
    return 'UTF-8'

</t>
<t tx="newlife.20101201170601.1343">@property
def COOKIES(self):
    """ A dict-like SimpleCookie instance. Use :meth:`set_cookie` instead. """
    if not self._COOKIES:
        self._COOKIES = SimpleCookie()
    return self._COOKIES

</t>
<t tx="newlife.20101201170601.1344">def set_cookie(self, key, value, secret=None, **kargs):
    ''' Add a cookie. If the `secret` parameter is set, this creates a
        `Secure Cookie` (described below).

        :param key: the name of the cookie.
        :param value: the value of the cookie.
        :param secret: required for secure cookies. (default: None)
        :param max_age: maximum age in seconds. (default: None)
        :param expires: a datetime object or UNIX timestamp. (defaut: None)
        :param domain: the domain that is allowed to read the cookie.
          (default: current domain)
        :param path: limits the cookie to a given path (default: /)

        If neither `expires` nor `max_age` are set (default), the cookie
        lasts only as long as the browser is not closed.

        Secure cookies may store any pickle-able object and are
        cryptographically signed to prevent manipulation. Keep in mind that
        cookies are limited to 4kb in most browsers.

        Warning: Secure cookies are not encrypted (the client can still see
        the content) and not copy-protected (the client can restore an old
        cookie). The main intention is to make pickling and unpickling
        save, not to store secret information at client side.
    '''
    if secret:
        value = touni(cookie_encode((key, value), secret))
    elif not isinstance(value, basestring):
        raise TypeError('Secret missing for non-string Cookie.')

    self.COOKIES[key] = value
    for k, v in kargs.iteritems():
        self.COOKIES[key][k.replace('_', '-')] = v

</t>
<t tx="newlife.20101201170601.1345">def delete_cookie(self, key, **kwargs):
    ''' Delete a cookie. Be sure to use the same `domain` and `path`
        parameters as used to create the cookie. '''
    kwargs['max_age'] = -1
    kwargs['expires'] = 0
    self.set_cookie(key, **kwargs)

</t>
<t tx="newlife.20101201170601.1346">def get_content_type(self):
    """ Current 'Content-Type' header. """
    return self.headers['Content-Type']

</t>
<t tx="newlife.20101201170601.1347">def set_content_type(self, value):
    self.headers['Content-Type'] = value

</t>
<t tx="newlife.20101201170601.1348">###############################################################################
# Common Utilities #############################################################
###############################################################################

class MultiDict(DictMixin):
    """ A dict that remembers old values for each key """
    @others
</t>
<t tx="newlife.20101201170601.1349"># collections.MutableMapping would be better for Python &gt;= 2.6
def __init__(self, *a, **k):
    self.dict = dict()
    for k, v in dict(*a, **k).iteritems():
        self[k] = v

</t>
<t tx="newlife.20101201170601.1350">def __len__(self): return len(self.dict)
</t>
<t tx="newlife.20101201170601.1351">def __iter__(self): return iter(self.dict)
</t>
<t tx="newlife.20101201170601.1352">def __contains__(self, key): return key in self.dict
</t>
<t tx="newlife.20101201170601.1353">def __delitem__(self, key): del self.dict[key]
</t>
<t tx="newlife.20101201170601.1354">def keys(self): return self.dict.keys()
</t>
<t tx="newlife.20101201170601.1355">def __getitem__(self, key): return self.get(key, KeyError, -1)
</t>
<t tx="newlife.20101201170601.1356">def __setitem__(self, key, value): self.append(key, value)

</t>
<t tx="newlife.20101201170601.1357">def append(self, key, value): self.dict.setdefault(key, []).append(value)
</t>
<t tx="newlife.20101201170601.1358">def replace(self, key, value): self.dict[key] = [value]
</t>
<t tx="newlife.20101201170601.1359">def getall(self, key): return self.dict.get(key) or []

</t>
<t tx="newlife.20101201170601.1360">def get(self, key, default=None, index=-1):
    if key not in self.dict and default != KeyError:
        return [default][index]
    return self.dict[key][index]

</t>
<t tx="newlife.20101201170601.1361">def iterallitems(self):
    for key, values in self.dict.iteritems():
        for value in values:
            yield key, value


</t>
<t tx="newlife.20101201170601.1362">class HeaderDict(MultiDict):
    """ Same as :class:`MultiDict`, but title()s the keys and overwrites by default. """
    @others
</t>
<t tx="newlife.20101201170601.1363">def __contains__(self, key): return MultiDict.__contains__(self, self.httpkey(key))
</t>
<t tx="newlife.20101201170601.1364">def __getitem__(self, key): return MultiDict.__getitem__(self, self.httpkey(key))
</t>
<t tx="newlife.20101201170601.1365">def __delitem__(self, key): return MultiDict.__delitem__(self, self.httpkey(key))
</t>
<t tx="newlife.20101201170601.1366">def __setitem__(self, key, value): self.replace(key, value)
</t>
<t tx="newlife.20101201170601.1367">def get(self, key, default=None, index=-1): return MultiDict.get(self, self.httpkey(key), default, index)
</t>
<t tx="newlife.20101201170601.1368">def append(self, key, value): return MultiDict.append(self, self.httpkey(key), str(value))
</t>
<t tx="newlife.20101201170601.1369">def replace(self, key, value): return MultiDict.replace(self, self.httpkey(key), str(value))
</t>
<t tx="newlife.20101201170601.1370">def getall(self, key): return MultiDict.getall(self, self.httpkey(key))
</t>
<t tx="newlife.20101201170601.1371">def httpkey(self, key): return str(key).replace('_','-').title()



</t>
<t tx="newlife.20101201170601.1372">class WSGIHeaderDict(DictMixin):
    ''' This dict-like class takes a WSGI environ dict and provides convenient
        access to HTTP_* fields. Keys and values are stored as native strings
        (bytes/unicode) based on the python version used (2/3) and keys are
        case-insensitive. If the WSGI environment contains non-native strings,
        these are de- or encoded using 'utf8' (default) or 'latin1' (fallback)
        charset. To get the original value, use the .raw(key) method.

        This is not a MultiDict because incoming headers are unique. The API
        will remain stable even on WSGI spec changes, if possible.
        '''
    @others
</t>
<t tx="newlife.20101201170601.1373">
def __init__(self, environ):
    self.cache = {}
    self.environ = environ
    for key, value in self.environ.iteritems():
        key = tonat(key, 'latin1') # Headers are limited to ASCII anyway
        if key.startswith('HTTP_'):
            self[key[5:].replace('_','-')] = value

</t>
<t tx="newlife.20101201170601.1374">def __len__(self): return len(self.cache)
</t>
<t tx="newlife.20101201170601.1375">def keys(self): return self.cache.keys()
</t>
<t tx="newlife.20101201170601.1376">def __iter__(self): return iter(self.cache)
</t>
<t tx="newlife.20101201170601.1377">def __contains__(self, key): return key.title() in self.keys()
</t>
<t tx="newlife.20101201170601.1378">def __delitem__(self, key): del self.cache[key.title()]
</t>
<t tx="newlife.20101201170601.1379">def __getitem__(self, key): return self.cache[key.title()]
</t>
<t tx="newlife.20101201170601.1380">def __setitem__(self, key, value):
    try:
        self.cache[key.title()] = tonat(value, 'utf8')
    except UnicodeError:
        self.cache[key.title()] = tonat(value, 'latin1')

</t>
<t tx="newlife.20101201170601.1381">def raw(self, key, default=None):
    ''' Return the raw WSGI header value for that key. '''
    ekey = 'HTTP_%s' % key.replace('-','_').upper()
    return self.environ.get(ekey, default)




</t>
<t tx="newlife.20101201170601.1382">class AppStack(list):
    """ A stack implementation. """
    @others
</t>
<t tx="newlife.20101201170601.1383">
def __call__(self):
    """ Return the current default app. """
    return self[-1]

</t>
<t tx="newlife.20101201170601.1384">def push(self, value=None):
    """ Add a new Bottle instance to the stack """
    if not isinstance(value, Bottle):
        value = Bottle()
    self.append(value)
    return value

</t>
<t tx="newlife.20101201170601.1385">class WSGIFileWrapper(object):
   @others
</t>
<t tx="newlife.20101201170601.1386">
def __init__(self, fp, buffer_size=1024*64):
    self.fp, self.buffer_size = fp, buffer_size
    for attr in ('fileno', 'close', 'read', 'readlines'):
        if hasattr(fp, attr): setattr(self, attr, getattr(fp, attr))

</t>
<t tx="newlife.20101201170601.1387">def __iter__(self):
    read, buff = self.fp.read, self.buffer_size
    while True:
        part = read(buff)
        if not part: break
        yield part






</t>
<t tx="newlife.20101201170601.1388">###############################################################################
# Application Helper ###########################################################
###############################################################################

def dict2json(d):
    response.content_type = 'application/json'
    return json_dumps(d)


</t>
<t tx="newlife.20101201170601.1389">def abort(code=500, text='Unknown Error: Application stopped.'):
    """ Aborts execution and causes a HTTP error. """
    raise HTTPError(code, text)


</t>
<t tx="newlife.20101201170601.1390">def redirect(url, code=303):
    """ Aborts execution and causes a 303 redirect """
    scriptname = request.environ.get('SCRIPT_NAME', '').rstrip('/') + '/'
    location = urljoin(request.url, urljoin(scriptname, url))
    raise HTTPResponse("", status=code, header=dict(Location=location))


</t>
<t tx="newlife.20101201170601.1391">def send_file(*a, **k): #BC 0.6.4
    """ Raises the output of static_file(). (deprecated) """
    raise static_file(*a, **k)


</t>
<t tx="newlife.20101201170601.1392">def static_file(filename, root, guessmime=True, mimetype=None, download=False):
    """ Opens a file in a safe way and returns a HTTPError object with status
        code 200, 305, 401 or 404. Sets Content-Type, Content-Length and
        Last-Modified header. Obeys If-Modified-Since header and HEAD requests.
    """
    root = os.path.abspath(root) + os.sep
    filename = os.path.abspath(os.path.join(root, filename.strip('/\\')))
    header = dict()

    if not filename.startswith(root):
        return HTTPError(403, "Access denied.")
    if not os.path.exists(filename) or not os.path.isfile(filename):
        return HTTPError(404, "File does not exist.")
    if not os.access(filename, os.R_OK):
        return HTTPError(403, "You do not have permission to access this file.")

    if not mimetype and guessmime:
        header['Content-Type'] = mimetypes.guess_type(filename)[0]
    else:
        header['Content-Type'] = mimetype if mimetype else 'text/plain'

    if download == True:
        download = os.path.basename(filename)
    if download:
        header['Content-Disposition'] = 'attachment; filename="%s"' % download

    stats = os.stat(filename)
    lm = time.strftime("%a, %d %b %Y %H:%M:%S GMT", time.gmtime(stats.st_mtime))
    header['Last-Modified'] = lm
    ims = request.environ.get('HTTP_IF_MODIFIED_SINCE')
    if ims:
        ims = ims.split(";")[0].strip() # IE sends "&lt;date&gt;; length=146"
        ims = parse_date(ims)
        if ims is not None and ims &gt;= int(stats.st_mtime):
            header['Date'] = time.strftime("%a, %d %b %Y %H:%M:%S GMT", time.gmtime())
            return HTTPResponse(status=304, header=header)
    header['Content-Length'] = stats.st_size
    if request.method == 'HEAD':
        return HTTPResponse('', header=header)
    else:
        return HTTPResponse(open(filename, 'rb'), header=header)






</t>
<t tx="newlife.20101201170601.1393">###############################################################################
# HTTP Utilities and MISC (TODO) ###############################################
###############################################################################

def debug(mode=True):
    """ Change the debug level.
    There is only one debug level supported at the moment."""
    global DEBUG
    DEBUG = bool(mode)


</t>
<t tx="newlife.20101201170601.1394">def parse_date(ims):
    """ Parse rfc1123, rfc850 and asctime timestamps and return UTC epoch. """
    try:
        ts = email.utils.parsedate_tz(ims)
        return time.mktime(ts[:8] + (0,)) - (ts[9] or 0) - time.timezone
    except (TypeError, ValueError, IndexError):
        return None


</t>
<t tx="newlife.20101201170601.1395">def parse_auth(header):
    """ Parse rfc2617 HTTP authentication header string (basic) and return (user,pass) tuple or None"""
    try:
        method, data = header.split(None, 1)
        if method.lower() == 'basic':
            name, pwd = base64.b64decode(data).split(':', 1)
            return name, pwd
    except (KeyError, ValueError, TypeError):
        return None


</t>
<t tx="newlife.20101201170601.1396">def cookie_encode(data, key):
    ''' Encode and sign a pickle-able object. Return a (byte) string '''
    msg = base64.b64encode(pickle.dumps(data, -1))
    sig = base64.b64encode(hmac.new(key, msg).digest())
    return tob('!') + sig + tob('?') + msg


</t>
<t tx="newlife.20101201170601.1397">def cookie_decode(data, key):
    ''' Verify and decode an encoded string. Return an object or None.'''
    data = tob(data)
    if cookie_is_encoded(data):
        sig, msg = data.split(tob('?'), 1)
        if sig[1:] == base64.b64encode(hmac.new(key, msg).digest()):
            return pickle.loads(base64.b64decode(msg))
    return None


</t>
<t tx="newlife.20101201170601.1398">def cookie_is_encoded(data):
    ''' Return True if the argument looks like a encoded cookie.'''
    return bool(data.startswith(tob('!')) and tob('?') in data)


</t>
<t tx="newlife.20101201170601.1399">def yieldroutes(func):
    """ Return a generator for routes that match the signature (name, args) 
    of the func parameter. This may yield more than one route if the function
    takes optional keyword arguments. The output is best described by example::

        a()         -&gt; '/a'
        b(x, y)     -&gt; '/b/:x/:y'
        c(x, y=5)   -&gt; '/c/:x' and '/c/:x/:y'
        d(x=5, y=6) -&gt; '/d' and '/d/:x' and '/d/:x/:y'
    """
    path = func.__name__.replace('__','/').lstrip('/')
    spec = inspect.getargspec(func)
    argc = len(spec[0]) - len(spec[3] or [])
    path += ('/:%s' * argc) % tuple(spec[0][:argc])
    yield path
    for arg in spec[0][argc:]:
        path += '/:%s' % arg
        yield path

</t>
<t tx="newlife.20101201170601.1400">def path_shift(script_name, path_info, shift=1):
    ''' Shift path fragments from PATH_INFO to SCRIPT_NAME and vice versa.

        :return: The modified paths.
        :param script_name: The SCRIPT_NAME path.
        :param script_name: The PATH_INFO path.
        :param shift: The number of path fragments to shift. May be negative to
          change the shift direction. (default: 1)
    '''
    if shift == 0: return script_name, path_info
    pathlist = path_info.strip('/').split('/')
    scriptlist = script_name.strip('/').split('/')
    if pathlist and pathlist[0] == '': pathlist = []
    if scriptlist and scriptlist[0] == '': scriptlist = []
    if shift &gt; 0 and shift &lt;= len(pathlist):
        moved = pathlist[:shift]
        scriptlist = scriptlist + moved
        pathlist = pathlist[shift:]
    elif shift &lt; 0 and shift &gt;= -len(scriptlist):
        moved = scriptlist[shift:]
        pathlist = moved + pathlist
        scriptlist = scriptlist[:shift]
    else:
        empty = 'SCRIPT_NAME' if shift &lt; 0 else 'PATH_INFO'
        raise AssertionError("Cannot shift. Nothing left from %s" % empty)
    new_script_name = '/' + '/'.join(scriptlist)
    new_path_info = '/' + '/'.join(pathlist)
    if path_info.endswith('/') and pathlist: new_path_info += '/'
    return new_script_name, new_path_info



</t>
<t tx="newlife.20101201170601.1401"># Decorators
#TODO: Replace default_app() with app()

def validate(**vkargs):
    """
    Validates and manipulates keyword arguments by user defined callables.
    Handles ValueError and missing arguments by raising HTTPError(403).
    """
    def decorator(func):
        def wrapper(**kargs):
            for key, value in vkargs.iteritems():
                if key not in kargs:
                    abort(403, 'Missing parameter: %s' % key)
                try:
                    kargs[key] = value(kargs[key])
                except ValueError:
                    abort(403, 'Wrong parameter format for: %s' % key)
            return func(**kargs)
        return wrapper
    return decorator


</t>
<t tx="newlife.20101201170601.1402">def make_default_app_wrapper(name):
    ''' Return a callable that relays calls to the current default app. '''
    @functools.wraps(getattr(Bottle, name))
    def wrapper(*a, **ka):
        return getattr(app(), name)(*a, **ka)
    return wrapper

</t>
<t tx="newlife.20101201170601.1403">for name in 'route get post put delete error mount hook'.split():
    globals()[name] = make_default_app_wrapper(name)

url = make_default_app_wrapper('get_url')


def default():
    depr("The default() decorator is deprecated. Use @error(404) instead.")
    return error(404)






</t>
<t tx="newlife.20101201170601.1404">###############################################################################
# Server Adapter ###############################################################
###############################################################################

class ServerAdapter(object):
    quiet = False
    @others
</t>
<t tx="newlife.20101201170601.1405">def __init__(self, host='127.0.0.1', port=8080, **config):
    self.options = config
    self.host = host
    self.port = int(port)

</t>
<t tx="newlife.20101201170601.1406">def run(self, handler): # pragma: no cover
    pass

</t>
<t tx="newlife.20101201170601.1407">def __repr__(self):
    args = ', '.join(['%s=%s'%(k,repr(v)) for k, v in self.options.items()])
    return "%s(%s)" % (self.__class__.__name__, args)


</t>
<t tx="newlife.20101201170601.1408">class CGIServer(ServerAdapter):
    quiet = True
    @others
</t>
<t tx="newlife.20101201170601.1409">def run(self, handler): # pragma: no cover
    from wsgiref.handlers import CGIHandler
    CGIHandler().run(handler) # Just ignore host and port here


</t>
<t tx="newlife.20101201170601.1410">class FlupFCGIServer(ServerAdapter):
    @others
</t>
<t tx="newlife.20101201170601.1411">def run(self, handler): # pragma: no cover
    import flup.server.fcgi
    kwargs = {'bindAddress':(self.host, self.port)}
    kwargs.update(self.options) # allow to override bindAddress and others
    flup.server.fcgi.WSGIServer(handler, **kwargs).run()


</t>
<t tx="newlife.20101201170601.1412">class WSGIRefServer(ServerAdapter):
    @others
</t>
<t tx="newlife.20101201170601.1413">def run(self, handler): # pragma: no cover
    from wsgiref.simple_server import make_server, WSGIRequestHandler
    if self.quiet:
        class QuietHandler(WSGIRequestHandler):
            def log_request(*args, **kw): pass
        self.options['handler_class'] = QuietHandler
    srv = make_server(self.host, self.port, handler, **self.options)
    srv.serve_forever()


</t>
<t tx="newlife.20101201170601.1414">class CherryPyServer(ServerAdapter):
    @others
</t>
<t tx="newlife.20101201170601.1415">def run(self, handler): # pragma: no cover
    from cherrypy import wsgiserver
    server = wsgiserver.CherryPyWSGIServer((self.host, self.port), handler)
    server.start()


</t>
<t tx="newlife.20101201170601.1416">class PasteServer(ServerAdapter):
    @others
</t>
<t tx="newlife.20101201170601.1417">def run(self, handler): # pragma: no cover
    from paste import httpserver
    if not self.quiet:
        from paste.translogger import TransLogger
        handler = TransLogger(handler)
    httpserver.serve(handler, host=self.host, port=str(self.port),
                     **self.options)

</t>
<t tx="newlife.20101201170601.1418">class MeinheldServer(ServerAdapter):
    @others
</t>
<t tx="newlife.20101201170601.1419">def run(self, handler):
    from meinheld import server
    server.listen((self.host, self.port))
    server.run(handler)

</t>
<t tx="newlife.20101201170601.1420">class FapwsServer(ServerAdapter):
    """ Extremely fast webserver using libev. See http://www.fapws.org/ """
    @others
</t>
<t tx="newlife.20101201170601.1421">def run(self, handler): # pragma: no cover
    import fapws._evwsgi as evwsgi
    from fapws import base, config
    port = self.port
    if float(config.SERVER_IDENT[-2:]) &gt; 0.4:
        # fapws3 silently changed its API in 0.5
        port = str(port)
    evwsgi.start(self.host, port)
    # fapws3 never releases the GIL. Complain upstream. I tried. No luck.
    if 'BOTTLE_CHILD' in os.environ and not self.quiet:
        print "WARNING: Auto-reloading does not work with Fapws3."
        print "         (Fapws3 breaks python thread support)"
    evwsgi.set_base_module(base)
    def app(environ, start_response):
        environ['wsgi.multiprocess'] = False
        return handler(environ, start_response)
    evwsgi.wsgi_cb(('', app))
    evwsgi.run()


</t>
<t tx="newlife.20101201170601.1422">class TornadoServer(ServerAdapter):
    """ The super hyped asynchronous server by facebook. Untested. """
    @others
</t>
<t tx="newlife.20101201170601.1423">def run(self, handler): # pragma: no cover
    import tornado.wsgi
    import tornado.httpserver
    import tornado.ioloop
    container = tornado.wsgi.WSGIContainer(handler)
    server = tornado.httpserver.HTTPServer(container)
    server.listen(port=self.port)
    tornado.ioloop.IOLoop.instance().start()


</t>
<t tx="newlife.20101201170601.1424">class AppEngineServer(ServerAdapter):
    """ Adapter for Google App Engine. """
    quiet = True
    @others
</t>
<t tx="newlife.20101201170601.1425">def run(self, handler):
    from google.appengine.ext.webapp import util
    util.run_wsgi_app(handler)


</t>
<t tx="newlife.20101201170601.1426">class TwistedServer(ServerAdapter):
    """ Untested. """
    @others
</t>
<t tx="newlife.20101201170601.1427">def run(self, handler):
    from twisted.web import server, wsgi
    from twisted.python.threadpool import ThreadPool
    from twisted.internet import reactor
    thread_pool = ThreadPool()
    thread_pool.start()
    reactor.addSystemEventTrigger('after', 'shutdown', thread_pool.stop)
    factory = server.Site(wsgi.WSGIResource(reactor, thread_pool, handler))
    reactor.listenTCP(self.port, factory, interface=self.host)
    reactor.run()


</t>
<t tx="newlife.20101201170601.1428">class DieselServer(ServerAdapter):
    """ Untested. """
    @others
</t>
<t tx="newlife.20101201170601.1429">def run(self, handler):
    from diesel.protocols.wsgi import WSGIApplication
    app = WSGIApplication(handler, port=self.port)
    app.run()


</t>
<t tx="newlife.20101201170601.1430">class GeventServer(ServerAdapter):
    """ Untested. """
    @others
</t>
<t tx="newlife.20101201170601.1431">def run(self, handler):
    from gevent import wsgi
    #from gevent.hub import getcurrent
    #self.set_context_ident(getcurrent, weakref=True) # see contextlocal
    wsgi.WSGIServer((self.host, self.port), handler).serve_forever()


</t>
<t tx="newlife.20101201170601.1432">class GunicornServer(ServerAdapter):
    """ Untested. """
    @others
</t>
<t tx="newlife.20101201170601.1433">def run(self, handler):
    from gunicorn.arbiter import Arbiter
    from gunicorn.config import Config
    handler.cfg = Config({'bind': "%s:%d" % (self.host, self.port), 'workers': 4})
    arbiter = Arbiter(handler)
    arbiter.run()


</t>
<t tx="newlife.20101201170601.1434">class EventletServer(ServerAdapter):
    """ Untested """
    @others
</t>
<t tx="newlife.20101201170601.1435">def run(self, handler):
    from eventlet import wsgi, listen
    wsgi.server(listen((self.host, self.port)), handler)


</t>
<t tx="newlife.20101201170601.1436">class RocketServer(ServerAdapter):
    """ Untested. As requested in issue 63
        http://github.com/defnull/bottle/issues/#issue/63 """
    @others
</t>
<t tx="newlife.20101201170601.1437">def run(self, handler):
    from rocket import Rocket
    server = Rocket((self.host, self.port), 'wsgi', { 'wsgi_app' : handler })
    server.start()


</t>
<t tx="newlife.20101201170601.1438">class AutoServer(ServerAdapter):
    """ Untested. """
    adapters = [PasteServer, CherryPyServer, TwistedServer, WSGIRefServer]
    @others
</t>
<t tx="newlife.20101201170601.1439">def run(self, handler):
    for sa in self.adapters:
        try:
            return sa(self.host, self.port, **self.options).run(handler)
        except ImportError:
            pass


</t>
<t tx="newlife.20101201170601.1440">server_names = {
    'cgi': CGIServer,
    'flup': FlupFCGIServer,
    'wsgiref': WSGIRefServer,
    'cherrypy': CherryPyServer,
    'paste': PasteServer,
    'fapws3': FapwsServer,
    'tornado': TornadoServer,
    'gae': AppEngineServer,
    'twisted': TwistedServer,
    'diesel': DieselServer,
    'meinheld': MeinheldServer,
    'gunicorn': GunicornServer,
    'eventlet': EventletServer,
    'gevent': GeventServer,
    'rocket': RocketServer,
    'auto': AutoServer,
}






###############################################################################
# Application Control ##########################################################
###############################################################################


def _load(target, **kwargs):
    """ Fetch something from a module. The exact behaviour depends on the the
        target string:

        If the target is a valid python import path (e.g. `package.module`), 
        the rightmost part is returned as a module object.
        If the target contains a colon (e.g. `package.module:var`) the module
        variable specified after the colon is returned.
        If the part after the colon contains any non-alphanumeric characters
        (e.g. `package.module:function(argument)`) the result of the expression
        is returned. The exec namespace is updated with the keyword arguments
        provided to this function.

        Example::
        &gt;&gt;&gt; _load('bottle')
        &lt;module 'bottle' from 'bottle.py'&gt;
        &gt;&gt;&gt; _load('bottle:Bottle')
        &lt;class 'bottle.Bottle'&gt;
        &gt;&gt;&gt; _load('bottle:cookie_encode(v, secret)', v='foo', secret='bar')
        '!F+hN4dQxaDJ4QxxaZ+Z3jw==?gAJVA2Zvb3EBLg=='

    """
    module, target = target.split(":", 1) if ':' in target else (target, None)
    if module not in sys.modules:
        __import__(module)
    if not target:
        return sys.modules[module]
    if target.isalnum():
        return getattr(sys.modules[module], target)
    package_name = module.split('.')[0]
    kwargs[package_name] = sys.modules[package_name]
    return eval('%s.%s' % (module, target), kwargs)

</t>
<t tx="newlife.20101201170601.1441">def load_app(target):
    """ Load a bottle application based on a target string and return the
        application object.

        If the target is an import path (e.g. package.module), the application
        stack is used to isolate the routes defined in that module.
        If the target contains a colon (e.g. package.module:myapp) the
        module variable specified after the colon is returned instead.
    """
    tmp = app.push() # Create a new "default application"
    rv = _load(target) # Import the target module
    app.remove(tmp) # Remove the temporary added default application
    return rv if isinstance(rv, Bottle) else tmp


</t>
<t tx="newlife.20101201170601.1442">def run(app=None, server='wsgiref', host='127.0.0.1', port=8080,
        interval=1, reloader=False, quiet=False, **kargs):
    """ Start a server instance. This method blocks until the server terminates.

        :param app: WSGI application or target string supported by
               :func:`load_app`. (default: :func:`default_app`)
        :param server: Server adapter to use. See :data:`server_names` keys
               for valid names or pass a :class:`ServerAdapter` subclass.
               (default: `wsgiref`)
        :param host: Server address to bind to. Pass ``0.0.0.0`` to listens on
               all interfaces including the external one. (default: 127.0.0.1)
        :param host: Server port to bind to. Values below 1024 require root
               privileges. (default: 8080)
        :param reloader: Start auto-reloading server? (default: False)
        :param interval: Auto-reloader interval in seconds (default: 1)
        :param quiet: Suppress output to stdout and stderr? (default: False)
        :param options: Options passed to the server adapter.
     """
    app = app or default_app()
    if isinstance(app, basestring):
        app = load_app(app)
    if isinstance(server, basestring):
        server = server_names.get(server)
    if isinstance(server, type):
        server = server(host=host, port=port, **kargs)
    if not isinstance(server, ServerAdapter):
        raise RuntimeError("Server must be a subclass of ServerAdapter")
    server.quiet = server.quiet or quiet
    if not server.quiet and not os.environ.get('BOTTLE_CHILD'):
        print "Bottle server starting up (using %s)..." % repr(server)
        print "Listening on http://%s:%d/" % (server.host, server.port)
        print "Use Ctrl-C to quit."
        print
    try:
        if reloader:
            interval = min(interval, 1)
            if os.environ.get('BOTTLE_CHILD'):
                _reloader_child(server, app, interval)
            else:
                _reloader_observer(server, app, interval)
        else:
            server.run(app)
    except KeyboardInterrupt:
        pass
    if not server.quiet and not os.environ.get('BOTTLE_CHILD'):
        print "Shutting down..."


</t>
<t tx="newlife.20101201170601.1443">class FileCheckerThread(threading.Thread):
    ''' Thread that periodically checks for changed module files. '''
    @others
</t>
<t tx="newlife.20101201170601.1444">
def __init__(self, lockfile, interval):
    threading.Thread.__init__(self)
    self.lockfile, self.interval = lockfile, interval
    #1: lockfile to old; 2: lockfile missing
    #3: module file changed; 5: external exit
    self.status = 0

</t>
<t tx="newlife.20101201170601.1445">def run(self):
    exists = os.path.exists
    mtime = lambda path: os.stat(path).st_mtime
    files = dict()
    for module in sys.modules.values():
        try:
            path = inspect.getsourcefile(module)
            if path and exists(path): files[path] = mtime(path)
        except TypeError:
            pass
    while not self.status:
        for path, lmtime in files.iteritems():
            if not exists(path) or mtime(path) &gt; lmtime:
                self.status = 3
        if not exists(self.lockfile):
            self.status = 2
        elif mtime(self.lockfile) &lt; time.time() - self.interval - 5:
            self.status = 1
        if not self.status:
            time.sleep(self.interval)
    if self.status != 5:
        thread.interrupt_main()


</t>
<t tx="newlife.20101201170601.1446">def _reloader_child(server, app, interval):
    ''' Start the server and check for modified files in a background thread.
        As soon as an update is detected, KeyboardInterrupt is thrown in
        the main thread to exit the server loop. The process exists with status
        code 3 to request a reload by the observer process. If the lockfile
        is not modified in 2*interval second or missing, we assume that the
        observer process died and exit with status code 1 or 2.
    '''
    lockfile = os.environ.get('BOTTLE_LOCKFILE')
    bgcheck = FileCheckerThread(lockfile, interval)
    try:
        bgcheck.start()
        server.run(app)
    except KeyboardInterrupt:
        pass
    bgcheck.status, status = 5, bgcheck.status
    bgcheck.join() # bgcheck.status == 5 --&gt; silent exit
    if status: sys.exit(status)


</t>
<t tx="newlife.20101201170601.1447">def _reloader_observer(server, app, interval):
    ''' Start a child process with identical commandline arguments and restart
        it as long as it exists with status code 3. Also create a lockfile and
        touch it (update mtime) every interval seconds.
    '''
    fd, lockfile = tempfile.mkstemp(prefix='bottle-reloader.', suffix='.lock')
    os.close(fd) # We only need this file to exist. We never write to it
    try:
        while os.path.exists(lockfile):
            args = [sys.executable] + sys.argv
            environ = os.environ.copy()
            environ['BOTTLE_CHILD'] = 'true'
            environ['BOTTLE_LOCKFILE'] = lockfile
            p = subprocess.Popen(args, env=environ)
            while p.poll() is None: # Busy wait...
                os.utime(lockfile, None) # I am alive!
                time.sleep(interval)
            if p.poll() != 3:
                if os.path.exists(lockfile): os.unlink(lockfile)
                sys.exit(p.poll())
            elif not server.quiet:
                print "Reloading server..."
    except KeyboardInterrupt:
        pass
    if os.path.exists(lockfile): os.unlink(lockfile)






</t>
<t tx="newlife.20101201170601.1448">###############################################################################
# Template Adapters ############################################################
###############################################################################

class TemplateError(HTTPError):
    @others
</t>
<t tx="newlife.20101201170601.1449">def __init__(self, message):
    HTTPError.__init__(self, 500, message)


</t>
<t tx="newlife.20101201170601.1450">class BaseTemplate(object):
    """ Base class and minimal API for template adapters """
    extentions = ['tpl','html','thtml','stpl']
    settings = {} #used in prepare()
    defaults = {} #used in render()

    @others
</t>
<t tx="newlife.20101201170601.1451">def __init__(self, source=None, name=None, lookup=[], encoding='utf8', **settings):
    """ Create a new template.
    If the source parameter (str or buffer) is missing, the name argument
    is used to guess a template filename. Subclasses can assume that
    self.source and/or self.filename are set. Both are strings.
    The lookup, encoding and settings parameters are stored as instance
    variables.
    The lookup parameter stores a list containing directory paths.
    The encoding parameter should be used to decode byte strings or files.
    The settings parameter contains a dict for engine-specific settings.
    """
    self.name = name
    self.source = source.read() if hasattr(source, 'read') else source
    self.filename = source.filename if hasattr(source, 'filename') else None
    self.lookup = map(os.path.abspath, lookup)
    self.encoding = encoding
    self.settings = self.settings.copy() # Copy from class variable
    self.settings.update(settings) # Apply 
    if not self.source and self.name:
        self.filename = self.search(self.name, self.lookup)
        if not self.filename:
            raise TemplateError('Template %s not found.' % repr(name))
    if not self.source and not self.filename:
        raise TemplateError('No template specified.')
    self.prepare(**self.settings)

</t>
<t tx="newlife.20101201170601.1452">@classmethod
def search(cls, name, lookup=[]):
    """ Search name in all directories specified in lookup.
    First without, then with common extensions. Return first hit. """
    if os.path.isfile(name): return name
    for spath in lookup:
        fname = os.path.join(spath, name)
        if os.path.isfile(fname):
            return fname
        for ext in cls.extentions:
            if os.path.isfile('%s.%s' % (fname, ext)):
                return '%s.%s' % (fname, ext)

</t>
<t tx="newlife.20101201170601.1453">@classmethod
def global_config(cls, key, *args):
    ''' This reads or sets the global settings stored in class.settings. '''
    if args:
        cls.settings[key] = args[0]
    else:
        return cls.settings[key]

</t>
<t tx="newlife.20101201170601.1454">def prepare(self, **options):
    """ Run preparations (parsing, caching, ...).
    It should be possible to call this again to refresh a template or to
    update settings.
    """
    raise NotImplementedError

</t>
<t tx="newlife.20101201170601.1455">def render(self, *args, **kwargs):
    """ Render the template with the specified local variables and return
    a single byte or unicode string. If it is a byte string, the encoding
    must match self.encoding. This method must be thread-safe!
    Local variables may be provided in dictionaries (*args)
    or directly, as keywords (**kwargs).
    """
    raise NotImplementedError


</t>
<t tx="newlife.20101201170601.1456">class MakoTemplate(BaseTemplate):
    @others
</t>
<t tx="newlife.20101201170601.1457">def prepare(self, **options):
    from mako.template import Template
    from mako.lookup import TemplateLookup
    options.update({'input_encoding':self.encoding})
    #TODO: This is a hack... http://github.com/defnull/bottle/issues#issue/8
    mylookup = TemplateLookup(directories=['.']+self.lookup, **options)
    if self.source:
        self.tpl = Template(self.source, lookup=mylookup)
    else: #mako cannot guess extentions. We can, but only at top level...
        name = self.name
        if not os.path.splitext(name)[1]:
            name += os.path.splitext(self.filename)[1]
        self.tpl = mylookup.get_template(name)

</t>
<t tx="newlife.20101201170601.1458">def render(self, *args, **kwargs):
    for dictarg in args: kwargs.update(dictarg)
    _defaults = self.defaults.copy()
    _defaults.update(kwargs)
    return self.tpl.render(**_defaults)


</t>
<t tx="newlife.20101201170601.1459">class CheetahTemplate(BaseTemplate):
    @others
</t>
<t tx="newlife.20101201170601.1460">def prepare(self, **options):
    from Cheetah.Template import Template
    self.context = threading.local()
    self.context.vars = {}
    options['searchList'] = [self.context.vars]
    if self.source:
        self.tpl = Template(source=self.source, **options)
    else:
        self.tpl = Template(file=self.filename, **options)

</t>
<t tx="newlife.20101201170601.1461">def render(self, *args, **kwargs):
    for dictarg in args: kwargs.update(dictarg)
    self.context.vars.update(self.defaults)
    self.context.vars.update(kwargs)
    out = str(self.tpl)
    self.context.vars.clear()
    return [out]


</t>
<t tx="newlife.20101201170601.1462">class Jinja2Template(BaseTemplate):
    @others
</t>
<t tx="newlife.20101201170601.1463">def prepare(self, filters=None, tests=None, **kwargs):
    from jinja2 import Environment, FunctionLoader
    if 'prefix' in kwargs: # TODO: to be removed after a while
        raise RuntimeError('The keyword argument `prefix` has been removed. '
            'Use the full jinja2 environment name line_statement_prefix instead.')
    self.env = Environment(loader=FunctionLoader(self.loader), **kwargs)
    if filters: self.env.filters.update(filters)
    if tests: self.env.tests.update(tests)
    if self.source:
        self.tpl = self.env.from_string(self.source)
    else:
        self.tpl = self.env.get_template(self.filename)

</t>
<t tx="newlife.20101201170601.1464">def render(self, *args, **kwargs):
    for dictarg in args: kwargs.update(dictarg)
    _defaults = self.defaults.copy()
    _defaults.update(kwargs)
    return self.tpl.render(**_defaults).encode("utf-8")

</t>
<t tx="newlife.20101201170601.1465">def loader(self, name):
    fname = self.search(name, self.lookup)
    if fname:
        with open(fname, "rb") as f:
            return f.read().decode(self.encoding)

</t>
<t tx="newlife.20101201170601.1466">class SimpleTALTemplate(BaseTemplate):
    ''' Untested! '''
    @others
</t>
<t tx="newlife.20101201170601.1467">def prepare(self, **options):
    from simpletal import simpleTAL
    # TODO: add option to load METAL files during render
    if self.source:
        self.tpl = simpleTAL.compileHTMLTemplate(self.source)
    else:
        with open(self.filename, 'rb') as fp:
            self.tpl = simpleTAL.compileHTMLTemplate(tonat(fp.read()))

</t>
<t tx="newlife.20101201170601.1468">def render(self, *args, **kwargs):
    from simpletal import simpleTALES
    from StringIO import StringIO
    for dictarg in args: kwargs.update(dictarg)
    # TODO: maybe reuse a context instead of always creating one
    context = simpleTALES.Context()
    for k,v in self.defaults.items():
        context.addGlobal(k, v)
    for k,v in kwargs.items():
        context.addGlobal(k, v)
    output = StringIO()
    self.tpl.expand(context, output)
    return output.getvalue()



</t>
<t tx="newlife.20101201170601.1469">class SimpleTemplate(BaseTemplate):
    blocks = ('if','elif','else','try','except','finally','for','while','with','def','class')
    dedent_blocks = ('elif', 'else', 'except', 'finally')

    @others
</t>
<t tx="newlife.20101201170601.1470">def prepare(self, escape_func=cgi.escape, noescape=False):
    self.cache = {}
    if self.source:
        self.code = self.translate(self.source)
        self.co = compile(self.code, '&lt;string&gt;', 'exec')
    else:
        self.code = self.translate(open(self.filename).read())
        self.co = compile(self.code, self.filename, 'exec')
    enc = self.encoding
    self._str = lambda x: touni(x, enc)
    self._escape = lambda x: escape_func(touni(x, enc))
    if noescape:
        self._str, self._escape = self._escape, self._str

</t>
<t tx="newlife.20101201170601.1471">def translate(self, template):
    stack = [] # Current Code indentation
    lineno = 0 # Current line of code
    ptrbuffer = [] # Buffer for printable strings and token tuple instances
    codebuffer = [] # Buffer for generated python code
    multiline = dedent = oneline = False

    def yield_tokens(line):
        for i, part in enumerate(re.split(r'\{\{(.*?)\}\}', line)):
            if i % 2:
                if part.startswith('!'): yield 'RAW', part[1:]
                else: yield 'CMD', part
            else: yield 'TXT', part

    def split_comment(codeline):
        """ Removes comments from a line of code. """
        line = codeline.splitlines()[0]
        try:
            tokens = list(tokenize.generate_tokens(iter(line).next))
        except tokenize.TokenError:
            return line.rsplit('#',1) if '#' in line else (line, '')
        for token in tokens:
            if token[0] == tokenize.COMMENT:
                start, end = token[2][1], token[3][1]
                return codeline[:start] + codeline[end:], codeline[start:end]
        return line, ''

    def flush(): # Flush the ptrbuffer
        if not ptrbuffer: return
        cline = ''
        for line in ptrbuffer:
            for token, value in line:
                if token == 'TXT': cline += repr(value)
                elif token == 'RAW': cline += '_str(%s)' % value
                elif token == 'CMD': cline += '_escape(%s)' % value
                cline +=  ', '
            cline = cline[:-2] + '\\\n'
        cline = cline[:-2]
        if cline[:-1].endswith('\\\\\\\\\\n'):
            cline = cline[:-7] + cline[-1] # 'nobr\\\\\n' --&gt; 'nobr'
        cline = '_printlist([' + cline + '])'
        del ptrbuffer[:] # Do this before calling code() again
        code(cline)

    def code(stmt):
        for line in stmt.splitlines():
            codebuffer.append('  ' * len(stack) + line.strip())

    for line in template.splitlines(True):
        lineno += 1
        line = line if isinstance(line, unicode)\
                    else unicode(line, encoding=self.encoding)
        if lineno &lt;= 2:
            m = re.search(r"%.*coding[:=]\s*([-\w\.]+)", line)
            if m: self.encoding = m.group(1)
            if m: line = line.replace('coding','coding (removed)')
        if line.strip()[:2].count('%') == 1:
            line = line.split('%',1)[1].lstrip() # Full line following the %
            cline = split_comment(line)[0].strip()
            cmd = re.split(r'[^a-zA-Z0-9_]', cline)[0]
            flush() ##encodig (TODO: why?)
            if cmd in self.blocks or multiline:
                cmd = multiline or cmd
                dedent = cmd in self.dedent_blocks # "else:"
                if dedent and not oneline and not multiline:
                    cmd = stack.pop()
                code(line)
                oneline = not cline.endswith(':') # "if 1: pass"
                multiline = cmd if cline.endswith('\\') else False
                if not oneline and not multiline:
                    stack.append(cmd)
            elif cmd == 'end' and stack:
                code('#end(%s) %s' % (stack.pop(), line.strip()[3:]))
            elif cmd == 'include':
                p = cline.split(None, 2)[1:]
                if len(p) == 2:
                    code("_=_include(%s, _stdout, %s)" % (repr(p[0]), p[1]))
                elif p:
                    code("_=_include(%s, _stdout)" % repr(p[0]))
                else: # Empty %include -&gt; reverse of %rebase
                    code("_printlist(_base)")
            elif cmd == 'rebase':
                p = cline.split(None, 2)[1:]
                if len(p) == 2:
                    code("globals()['_rebase']=(%s, dict(%s))" % (repr(p[0]), p[1]))
                elif p:
                    code("globals()['_rebase']=(%s, {})" % repr(p[0]))
            else:
                code(line)
        else: # Line starting with text (not '%') or '%%' (escaped)
            if line.strip().startswith('%%'):
                line = line.replace('%%', '%', 1)
            ptrbuffer.append(yield_tokens(line))
    flush()
    return '\n'.join(codebuffer) + '\n'

</t>
<t tx="newlife.20101201170601.1472">def subtemplate(self, _name, _stdout, *args, **kwargs):
    for dictarg in args: kwargs.update(dictarg)
    if _name not in self.cache:
        self.cache[_name] = self.__class__(name=_name, lookup=self.lookup)
    return self.cache[_name].execute(_stdout, kwargs)

</t>
<t tx="newlife.20101201170601.1473">def execute(self, _stdout, *args, **kwargs):
    for dictarg in args: kwargs.update(dictarg)
    env = self.defaults.copy()
    env.update({'_stdout': _stdout, '_printlist': _stdout.extend,
           '_include': self.subtemplate, '_str': self._str,
           '_escape': self._escape})
    env.update(kwargs)
    eval(self.co, env)
    if '_rebase' in env:
        subtpl, rargs = env['_rebase']
        subtpl = self.__class__(name=subtpl, lookup=self.lookup)
        rargs['_base'] = _stdout[:] #copy stdout
        del _stdout[:] # clear stdout
        return subtpl.execute(_stdout, rargs)
    return env

</t>
<t tx="newlife.20101201170601.1474">def render(self, *args, **kwargs):
    """ Render the template using keyword arguments as local variables. """
    for dictarg in args: kwargs.update(dictarg)
    stdout = []
    self.execute(stdout, kwargs)
    return ''.join(stdout)


</t>
<t tx="newlife.20101201170601.1475">def template(*args, **kwargs):
    '''
    Get a rendered template as a string iterator.
    You can use a name, a filename or a template string as first parameter.
    Template rendering arguments can be passed as dictionaries
    or directly (as keyword arguments).
    '''
    tpl = args[0] if args else None
    template_adapter = kwargs.pop('template_adapter', SimpleTemplate)
    if tpl not in TEMPLATES or DEBUG:
        settings = kwargs.pop('template_settings', {})
        lookup = kwargs.pop('template_lookup', TEMPLATE_PATH)
        if isinstance(tpl, template_adapter):
            TEMPLATES[tpl] = tpl
            if settings: TEMPLATES[tpl].prepare(**settings)
        elif "\n" in tpl or "{" in tpl or "%" in tpl or '$' in tpl:
            TEMPLATES[tpl] = template_adapter(source=tpl, lookup=lookup, **settings)
        else:
            TEMPLATES[tpl] = template_adapter(name=tpl, lookup=lookup, **settings)
    if not TEMPLATES[tpl]:
        abort(500, 'Template (%s) not found' % tpl)
    for dictarg in args[1:]: kwargs.update(dictarg)
    return TEMPLATES[tpl].render(kwargs)

</t>
<t tx="newlife.20101201170601.1476">mako_template = functools.partial(template, template_adapter=MakoTemplate)
cheetah_template = functools.partial(template, template_adapter=CheetahTemplate)
jinja2_template = functools.partial(template, template_adapter=Jinja2Template)
simpletal_template = functools.partial(template, template_adapter=SimpleTALTemplate)

def view(tpl_name, **defaults):
    ''' Decorator: renders a template for a handler.
        The handler can control its behavior like that:

          - return a dict of template vars to fill out the template
          - return something other than a dict and the view decorator will not
            process the template, but return the handler result as is.
            This includes returning a HTTPResponse(dict) to get,
            for instance, JSON with autojson or other castfilters.
    '''
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            result = func(*args, **kwargs)
            if isinstance(result, (dict, DictMixin)):
                tplvars = defaults.copy()
                tplvars.update(result)
                return template(tpl_name, **tplvars)
            return result
        return wrapper
    return decorator

</t>
<t tx="newlife.20101201170601.1477">The @file directive shown in the highlighted headline is similar to the @root directive shown in the first tutorial. The @file directive is explained in greater detail later in this tutorial. 

The @language directive indicates that Java syntax highlighting will be used. The @others directive indicates that all unnamed  sections will be derived. An unnamed section is a node defined without angle brackets.</t>
<t tx="newlife.20101201170601.1478">@language python
@tabwidth -4
@others

if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))
</t>
<t tx="newlife.20101201170601.1479"># -*- coding: utf-8 -*-
""" This is a command line tool to load and serve bottle.py web applications.
"""

import bottle
import logging
import sys
from optparse import OptionParser
import os
import subprocess
import time
import thread
import tempfile
import inspect

logging.basicConfig()
log = logging.getLogger('bottle.starter')

servernames = ['AutoServer']
servernames.extend(x.__name__ for x in bottle.AutoServer.adapters)
reloading_servernames = ['WSGIRefServer']


parser = OptionParser(usage="usage: %prog [options] module1 [module2 ...]")
parser.add_option("-s", "--server",
    type="choice",
    choices=servernames,
    default=servernames[0],
    help='Server backend: %s (default), %s or %s'
        % (servernames[0], ", ".join(servernames[1:-1]), servernames[-1]))
parser.add_option("-a", "--host",
    default='localhost',
    help="Host address or name to bind to (default: localhost)")
parser.add_option("-r", "--reload",
    default=False,
    action='store_true',
    help="Use auto reloading? (default: off)")
parser.add_option("-p", "--port",
    type="int",
    default=8080,
    help="TCP Port to bind to (default: 8080)")
parser.add_option("-l", "--log",
    help="Path to the logfile (default: stderr)")
parser.add_option("-d", "--debug",
    action="store_true",
    help="Log debug messages and include a stacktrace to HTTP-500 error pages (dangerous on public servers)")
parser.add_option("-v", "--verbose",
    action="store_true",
    help="Same as -d")


</t>
<t tx="newlife.20101201170601.1480">def terminate(process):
    """ Kills a subprocess. """
    if hasattr(process, 'terminate'):
        return process.terminate()
    try:
        import win32process
        return win32process.TerminateProcess(process._handle, -1)
    except ImportError:
        import os
        import signal
        return os.kill(process.pid, signal.SIGTERM)


</t>
<t tx="newlife.20101201170601.1481">def set_exit_handler(func):
    try:
        import win32api
        win32api.SetConsoleCtrlHandler(func, True)
    except ImportError:
        import signal
        signal.signal(signal.SIGTERM, func)


</t>
<t tx="newlife.20101201170601.1482">class ModuleChecker(object):
    @others
</t>
<t tx="newlife.20101201170601.1483">def __init__(self):
    self.files = {}
    self.changed = []
    for module in sys.modules.values():
        try:
            path = inspect.getsourcefile(module)
            self.add(path)
        except TypeError:
            continue

</t>
<t tx="newlife.20101201170601.1484">def add(self, path):
    self.files[path] = self.mtime(path)

</t>
<t tx="newlife.20101201170601.1485">def mtime(self, path):
    return os.path.getmtime(path) if os.path.exists(path) else 0

</t>
<t tx="newlife.20101201170601.1486">def check(self):
    for path, mtime in self.files.iteritems():
        newtime = self.mtime(path)
        &lt;&lt; test_change&gt;&gt;
    return self.changed

</t>
<t tx="newlife.20101201170601.1487">def reset(self):
    self.changed = []

</t>
<t tx="newlife.20101201170601.1488">def loop(self, interval, callback):
    while not self.check():
        time.sleep(interval)
    callback()


</t>
<t tx="newlife.20101201170601.1489">def run_child(**runargs):
    """ Run as a child process and check for changed files in a separate thread.
        As soon as a file change is detected, KeyboardInterrupt is thrown in
        the main thread to exit the server loop. """
    checker = ModuleChecker()
    thread.start_new_thread(checker.loop, (1, thread.interrupt_main), {})
    bottle.run(**runargs) # This blocks until KeyboardInterrupt
    if checker.changed:
        log.info("Changed files: %s; Reloading...", ', '.join(checker.changed))
        return 3
    return 0


</t>
<t tx="newlife.20101201170601.1490">def run_observer():
    """ The observer loop: Start a child process and wait for it to terminate.
        If the return code equals 3, restart it. Exit otherwise.
        On an exception or SIGTERM, kill the child the hard way. """
    global child
    child_argv = [sys.executable] + sys.argv
    child_environ = os.environ.copy()
    child_environ['BOTTLE_CHILD'] = 'true'

    def onexit(*argv):
        if child.poll() == None:
            terminate(child)

    set_exit_handler(onexit)

    while True: # Child restart loop
        child = subprocess.Popen(child_argv, env=child_environ)
        try:
            code = child.wait()
            if code != 3:
                log.info("Child terminated with exit code %d. We do the same", code)
                return code
        except KeyboardInterrupt:
            log.info("User exit. Waiting for Child to terminate...")
            return child.wait()
        except OSError, e:
            # This happens on SIGTERM during child.wait(). We ignore it
            onexit()
            return child.wait()
        except Exception, e:
            onexit()
            log.exception("Uh oh...")
            raise


</t>
<t tx="newlife.20101201170601.1491">def main(argv):
    opt, args = parser.parse_args(argv)

    # Logging
    if opt.log:
        log.addHandler(logging.handlers.FileHandler(opt.log))
    else:
        logging.basicConfig()

    # DEBUG mode
    if opt.verbose or opt.debug:
        bottle.debug(True)
        log.setLevel(logging.DEBUG)

    # Importing modules
    sys.path.append('./')
    if not args:
        log.error("No modules specified")
        return 1
    for mod in args:
        try:
            __import__(mod)
        except ImportError:
            log.exception("Failed to import module '%s' (ImportError)", mod)
            return 1

    # First case: We are a reloading observer process
    if opt.reload and not os.environ.get('BOTTLE_CHILD'):
        return run_observer()

    # Arguments for bottle.run()
    runargs = {}
    runargs['server'] = getattr(bottle, opt.server) 
    runargs['port'] = int(opt.port)
    runargs['host'] = opt.host

    # Second case: We are a reloading child process
    if os.environ.get('BOTTLE_CHILD'):
        if runargs['server'] != bottle.WSGIRefServer:
            log.warning("Currently only WSGIRefServer is known to support reloading")
            runargs['server'] = bottle.WSGIRefServer
        return run_child(**runargs)

    # Third case: We are not reloading a all
    bottle.run(**runargs)
    return 0




</t>
<t tx="newlife.20101201170601.1492">if mtime != newtime:
    self.changed.append(path)
    self.files[path] = newtime</t>
</tnodes>
</leo_file>
